{
  "shortuuid": [
    {
      "type": "function",
      "qualified_name": "shortuuid.cli.cli",
      "module": "shortuuid.cli",
      "signature": "(*args: Any) -> None",
      "parameters": {
        "args": {
          "default": null,
          "annotation": "typing.Any",
          "kind": "VAR_POSITIONAL",
          "description": null
        }
      },
      "returns": "None",
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "def cli(*args: Any) -> None:\n    parser = argparse.ArgumentParser(\n        description=\"Generate, encode and decode shortuuids\",\n        epilog=\"top-level command generates a random shortuuid\",\n    )\n\n    subparsers = parser.add_subparsers(help=\"sub-command help\")\n\n    encode_parser = subparsers.add_parser(\n        \"encode\", help=\"Encode a UUID into a short UUID\", description=encode.__doc__\n    )\n    encode_parser.add_argument(\"uuid\", type=UUID, help=\"UUID to be encoded\")\n    encode_parser.set_defaults(func=encode_cli)\n\n    decode_parser = subparsers.add_parser(\n        \"decode\", help=\"Decode a short UUID into a UUID\", description=decode.__doc__\n    )\n    decode_parser.add_argument(\"shortuuid\", type=str, help=\"Short UUID to be decoded\")\n    decode_parser.add_argument(\"--legacy\", action=\"store_true\")\n    decode_parser.set_defaults(func=decode_cli)\n\n    passed_args = parser.parse_args(*args)\n\n    if hasattr(passed_args, \"func\"):\n        passed_args.func(passed_args)\n    else:\n        # Maintain legacy behaviour\n        print(uuid())\n"
    },
    {
      "type": "function",
      "qualified_name": "shortuuid.cli.decode_cli",
      "module": "shortuuid.cli",
      "signature": "(args: argparse.Namespace)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": "<class 'argparse.Namespace'>",
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "def decode_cli(args: argparse.Namespace):\n    print(str(decode(args.shortuuid, legacy=args.legacy)))\n"
    },
    {
      "type": "function",
      "qualified_name": "shortuuid.cli.encode_cli",
      "module": "shortuuid.cli",
      "signature": "(args: argparse.Namespace)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": "<class 'argparse.Namespace'>",
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "def encode_cli(args: argparse.Namespace):\n    print(encode(args.uuid))\n"
    },
    {
      "type": "function",
      "qualified_name": "shortuuid.main.int_to_string",
      "module": "shortuuid.main",
      "signature": "(number: int, alphabet: List[str], padding: Optional[int] = None) -> str",
      "parameters": {
        "number": {
          "default": null,
          "annotation": "<class 'int'>",
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "alphabet": {
          "default": null,
          "annotation": "typing.List[str]",
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "padding": {
          "default": "None",
          "annotation": "typing.Optional[int]",
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": "<class 'str'>",
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Convert a number to a string, using the given alphabet.\n\nThe output has the most significant digit first.",
      "source_code": "def int_to_string(\n    number: int, alphabet: List[str], padding: Optional[int] = None\n) -> str:\n    \"\"\"\n    Convert a number to a string, using the given alphabet.\n\n    The output has the most significant digit first.\n    \"\"\"\n    output = \"\"\n    alpha_len = len(alphabet)\n    while number:\n        number, digit = divmod(number, alpha_len)\n        output += alphabet[digit]\n    if padding:\n        remainder = max(padding - len(output), 0)\n        output = output + alphabet[0] * remainder\n    return output[::-1]\n"
    },
    {
      "type": "function",
      "qualified_name": "shortuuid.main.string_to_int",
      "module": "shortuuid.main",
      "signature": "(string: str, alphabet: List[str]) -> int",
      "parameters": {
        "string": {
          "default": null,
          "annotation": "<class 'str'>",
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "alphabet": {
          "default": null,
          "annotation": "typing.List[str]",
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": "<class 'int'>",
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Convert a string to a number, using the given alphabet.\n\nThe input is assumed to have the most significant digit first.",
      "source_code": "def string_to_int(string: str, alphabet: List[str]) -> int:\n    \"\"\"\n    Convert a string to a number, using the given alphabet.\n\n    The input is assumed to have the most significant digit first.\n    \"\"\"\n    number = 0\n    alpha_len = len(alphabet)\n    for char in string:\n        number = number * alpha_len + alphabet.index(char)\n    return number\n"
    },
    {
      "type": "function",
      "qualified_name": "shortuuid.test_shortuuid.cli",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args: Any) -> None",
      "parameters": {
        "args": {
          "default": null,
          "annotation": "typing.Any",
          "kind": "VAR_POSITIONAL",
          "description": null
        }
      },
      "returns": "None",
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "def cli(*args: Any) -> None:\n    parser = argparse.ArgumentParser(\n        description=\"Generate, encode and decode shortuuids\",\n        epilog=\"top-level command generates a random shortuuid\",\n    )\n\n    subparsers = parser.add_subparsers(help=\"sub-command help\")\n\n    encode_parser = subparsers.add_parser(\n        \"encode\", help=\"Encode a UUID into a short UUID\", description=encode.__doc__\n    )\n    encode_parser.add_argument(\"uuid\", type=UUID, help=\"UUID to be encoded\")\n    encode_parser.set_defaults(func=encode_cli)\n\n    decode_parser = subparsers.add_parser(\n        \"decode\", help=\"Decode a short UUID into a UUID\", description=decode.__doc__\n    )\n    decode_parser.add_argument(\"shortuuid\", type=str, help=\"Short UUID to be decoded\")\n    decode_parser.add_argument(\"--legacy\", action=\"store_true\")\n    decode_parser.set_defaults(func=decode_cli)\n\n    passed_args = parser.parse_args(*args)\n\n    if hasattr(passed_args, \"func\"):\n        passed_args.func(passed_args)\n    else:\n        # Maintain legacy behaviour\n        print(uuid())\n"
    },
    {
      "type": "function",
      "qualified_name": "shortuuid.test_shortuuid.patch",
      "module": "shortuuid.test_shortuuid",
      "signature": "(target, new=sentinel.DEFAULT, spec=None, create=False, spec_set=None, autospec=None, new_callable=None, *, unsafe=False, **kwargs)",
      "parameters": {
        "target": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "new": {
          "default": "sentinel.DEFAULT",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "spec": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "create": {
          "default": "False",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "spec_set": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "autospec": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "new_callable": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "unsafe": {
          "default": "False",
          "annotation": null,
          "kind": "KEYWORD_ONLY",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "`patch` acts as a function decorator, class decorator or a context\nmanager. Inside the body of the function or with statement, the `target`\nis patched with a `new` object. When the function/with statement exits\nthe patch is undone.\n\nIf `new` is omitted, then the target is replaced with an\n`AsyncMock if the patched object is an async function or a\n`MagicMock` otherwise. If `patch` is used as a decorator and `new` is\nomitted, the created mock is passed in as an extra argument to the\ndecorated function. If `patch` is used as a context manager the created\nmock is returned by the context manager.\n\n`target` should be a string in the form `'package.module.ClassName'`. The\n`target` is imported and the specified object replaced with the `new`\nobject, so the `target` must be importable from the environment you are\ncalling `patch` from. The target is imported when the decorated function\nis executed, not at decoration time.\n\nThe `spec` and `spec_set` keyword arguments are passed to the `MagicMock`\nif patch is creating one for you.\n\nIn addition you can pass `spec=True` or `spec_set=True`, which causes\npatch to pass in the object being mocked as the spec/spec_set object.\n\n`new_callable` allows you to specify a different class, or callable object,\nthat will be called to create the `new` object. By default `AsyncMock` is\nused for async functions and `MagicMock` for the rest.\n\nA more powerful form of `spec` is `autospec`. If you set `autospec=True`\nthen the mock will be created with a spec from the object being replaced.\nAll attributes of the mock will also have the spec of the corresponding\nattribute of the object being replaced. Methods and functions being\nmocked will have their arguments checked and will raise a `TypeError` if\nthey are called with the wrong signature. For mocks replacing a class,\ntheir return value (the 'instance') will have the same spec as the class.\n\nInstead of `autospec=True` you can pass `autospec=some_object` to use an\narbitrary object as the spec instead of the one being replaced.\n\nBy default `patch` will fail to replace attributes that don't exist. If\nyou pass in `create=True`, and the attribute doesn't exist, patch will\ncreate the attribute for you when the patched function is called, and\ndelete it again afterwards. This is useful for writing tests against\nattributes that your production code creates at runtime. It is off by\ndefault because it can be dangerous. With it switched on you can write\npassing tests against APIs that don't actually exist!\n\nPatch can be used as a `TestCase` class decorator. It works by\ndecorating each test method in the class. This reduces the boilerplate\ncode when your test methods share a common patchings set. `patch` finds\ntests by looking for method names that start with `patch.TEST_PREFIX`.\nBy default this is `test`, which matches the way `unittest` finds tests.\nYou can specify an alternative prefix by setting `patch.TEST_PREFIX`.\n\nPatch can be used as a context manager, with the with statement. Here the\npatching applies to the indented block after the with statement. If you\nuse \"as\" then the patched object will be bound to the name after the\n\"as\"; very useful if `patch` is creating a mock object for you.\n\nPatch will raise a `RuntimeError` if passed some common misspellings of\nthe arguments autospec and spec_set. Pass the argument `unsafe` with the\nvalue True to disable that check.\n\n`patch` takes arbitrary keyword arguments. These will be passed to\n`AsyncMock` if the patched object is asynchronous, to `MagicMock`\notherwise or to `new_callable` if specified.\n\n`patch.dict(...)`, `patch.multiple(...)` and `patch.object(...)` are\navailable for alternate use-cases.",
      "source_code": "def patch(\n        target, new=DEFAULT, spec=None, create=False,\n        spec_set=None, autospec=None, new_callable=None, *, unsafe=False, **kwargs\n    ):\n    \"\"\"\n    `patch` acts as a function decorator, class decorator or a context\n    manager. Inside the body of the function or with statement, the `target`\n    is patched with a `new` object. When the function/with statement exits\n    the patch is undone.\n\n    If `new` is omitted, then the target is replaced with an\n    `AsyncMock if the patched object is an async function or a\n    `MagicMock` otherwise. If `patch` is used as a decorator and `new` is\n    omitted, the created mock is passed in as an extra argument to the\n    decorated function. If `patch` is used as a context manager the created\n    mock is returned by the context manager.\n\n    `target` should be a string in the form `'package.module.ClassName'`. The\n    `target` is imported and the specified object replaced with the `new`\n    object, so the `target` must be importable from the environment you are\n    calling `patch` from. The target is imported when the decorated function\n    is executed, not at decoration time.\n\n    The `spec` and `spec_set` keyword arguments are passed to the `MagicMock`\n    if patch is creating one for you.\n\n    In addition you can pass `spec=True` or `spec_set=True`, which causes\n    patch to pass in the object being mocked as the spec/spec_set object.\n\n    `new_callable` allows you to specify a different class, or callable object,\n    that will be called to create the `new` object. By default `AsyncMock` is\n    used for async functions and `MagicMock` for the rest.\n\n    A more powerful form of `spec` is `autospec`. If you set `autospec=True`\n    then the mock will be created with a spec from the object being replaced.\n    All attributes of the mock will also have the spec of the corresponding\n    attribute of the object being replaced. Methods and functions being\n    mocked will have their arguments checked and will raise a `TypeError` if\n    they are called with the wrong signature. For mocks replacing a class,\n    their return value (the 'instance') will have the same spec as the class.\n\n    Instead of `autospec=True` you can pass `autospec=some_object` to use an\n    arbitrary object as the spec instead of the one being replaced.\n\n    By default `patch` will fail to replace attributes that don't exist. If\n    you pass in `create=True`, and the attribute doesn't exist, patch will\n    create the attribute for you when the patched function is called, and\n    delete it again afterwards. This is useful for writing tests against\n    attributes that your production code creates at runtime. It is off by\n    default because it can be dangerous. With it switched on you can write\n    passing tests against APIs that don't actually exist!\n\n    Patch can be used as a `TestCase` class decorator. It works by\n    decorating each test method in the class. This reduces the boilerplate\n    code when your test methods share a common patchings set. `patch` finds\n    tests by looking for method names that start with `patch.TEST_PREFIX`.\n    By default this is `test`, which matches the way `unittest` finds tests.\n    You can specify an alternative prefix by setting `patch.TEST_PREFIX`.\n\n    Patch can be used as a context manager, with the with statement. Here the\n    patching applies to the indented block after the with statement. If you\n    use \"as\" then the patched object will be bound to the name after the\n    \"as\"; very useful if `patch` is creating a mock object for you.\n\n    Patch will raise a `RuntimeError` if passed some common misspellings of\n    the arguments autospec and spec_set. Pass the argument `unsafe` with the\n    value True to disable that check.\n\n    `patch` takes arbitrary keyword arguments. These will be passed to\n    `AsyncMock` if the patched object is asynchronous, to `MagicMock`\n    otherwise or to `new_callable` if specified.\n\n    `patch.dict(...)`, `patch.multiple(...)` and `patch.object(...)` are\n    available for alternate use-cases.\n    \"\"\"\n    getter, attribute = _get_target(target)\n    return _patch(\n        getter, attribute, new, spec, create,\n        spec_set, autospec, new_callable, kwargs, unsafe=unsafe\n    )\n"
    },
    {
      "type": "function",
      "qualified_name": "shortuuid.test_shortuuid.uuid4",
      "module": "shortuuid.test_shortuuid",
      "signature": "()",
      "parameters": {},
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Generate a random UUID.",
      "source_code": "def uuid4():\n    \"\"\"Generate a random UUID.\"\"\"\n    return UUID(bytes=os.urandom(16), version=4)\n"
    },
    {
      "type": "class",
      "qualified_name": "shortuuid.ShortUUID",
      "module": "shortuuid",
      "signature": "(self, alphabet: Optional[str] = None) -> None",
      "return_description": null,
      "raises": [],
      "decorators": [
        "property"
      ],
      "examples": [],
      "docstring": "",
      "source_code": "class ShortUUID(object):\n    def __init__(self, alphabet: Optional[str] = None) -> None:\n        if alphabet is None:\n            alphabet = \"23456789ABCDEFGHJKLMNPQRSTUVWXYZ\" \"abcdefghijkmnopqrstuvwxyz\"\n\n        self.set_alphabet(alphabet)\n\n    @property\n    def _length(self) -> int:\n        \"\"\"Return the necessary length to fit the entire UUID given the current alphabet.\"\"\"\n        return int(math.ceil(math.log(2**128, self._alpha_len)))\n\n    def encode(self, uuid: _uu.UUID, pad_length: Optional[int] = None) -> str:\n        \"\"\"\n        Encode a UUID into a string (LSB first) according to the alphabet.\n\n        If leftmost (MSB) bits are 0, the string might be shorter.\n        \"\"\"\n        if not isinstance(uuid, _uu.UUID):\n            raise ValueError(\"Input `uuid` must be a UUID object.\")\n        if pad_length is None:\n            pad_length = self._length\n        return int_to_string(uuid.int, self._alphabet, padding=pad_length)\n\n    def decode(self, string: str, legacy: bool = False) -> _uu.UUID:\n        \"\"\"\n        Decode a string according to the current alphabet into a UUID.\n\n        Raises ValueError when encountering illegal characters or a too-long string.\n\n        If string too short, fills leftmost (MSB) bits with 0.\n\n        Pass `legacy=True` if your UUID was encoded with a ShortUUID version prior to\n        1.0.0.\n        \"\"\"\n        if not isinstance(string, str):\n            raise ValueError(\"Input `string` must be a str.\")\n        if legacy:\n            string = string[::-1]\n        return _uu.UUID(int=string_to_int(string, self._alphabet))\n\n    def uuid(self, name: Optional[str] = None, pad_length: Optional[int] = None) -> str:\n        \"\"\"\n        Generate and return a UUID.\n\n        If the name parameter is provided, set the namespace to the provided\n        name and generate a UUID.\n        \"\"\"\n        if pad_length is None:\n            pad_length = self._length\n\n        # If no name is given, generate a random UUID.\n        if name is None:\n            u = _uu.uuid4()\n        elif name.lower().startswith((\"http://\", \"https://\")):\n            u = _uu.uuid5(_uu.NAMESPACE_URL, name)\n        else:\n            u = _uu.uuid5(_uu.NAMESPACE_DNS, name)\n        return self.encode(u, pad_length)\n\n    def random(self, length: Optional[int] = None) -> str:\n        \"\"\"Generate and return a cryptographically secure short random string of `length`.\"\"\"\n        if length is None:\n            length = self._length\n\n        return \"\".join(secrets.choice(self._alphabet) for _ in range(length))\n\n    def get_alphabet(self) -> str:\n        \"\"\"Return the current alphabet used for new UUIDs.\"\"\"\n        return \"\".join(self._alphabet)\n\n    def set_alphabet(self, alphabet: str) -> None:\n        \"\"\"Set the alphabet to be used for new UUIDs.\"\"\"\n        # Turn the alphabet into a set and sort it to prevent duplicates\n        # and ensure reproducibility.\n        new_alphabet = list(sorted(set(alphabet)))\n        if len(new_alphabet) > 1:\n            self._alphabet = new_alphabet\n            self._alpha_len = len(self._alphabet)\n        else:\n            raise ValueError(\"Alphabet with more than \" \"one unique symbols required.\")\n\n    def encoded_length(self, num_bytes: int = 16) -> int:\n        \"\"\"Return the string length of the shortened UUID.\"\"\"\n        factor = math.log(256) / math.log(self._alpha_len)\n        return int(math.ceil(factor * num_bytes))\n"
    },
    {
      "type": "class",
      "qualified_name": "shortuuid.cli.UUID",
      "module": "shortuuid.cli",
      "signature": "(self, hex=None, bytes=None, bytes_le=None, fields=None, int=None, version=None, *, is_safe=<SafeUUID.unknown: None>)",
      "return_description": null,
      "raises": [],
      "decorators": [
        "property",
        "property",
        "property",
        "property",
        "property",
        "property",
        "property",
        "property",
        "property",
        "property",
        "property",
        "property",
        "property",
        "property",
        "property"
      ],
      "examples": [],
      "docstring": "Instances of the UUID class represent UUIDs as specified in RFC 4122.\nUUID objects are immutable, hashable, and usable as dictionary keys.\nConverting a UUID to a string with str() yields something in the form\n'12345678-1234-1234-1234-123456789abc'.  The UUID constructor accepts\nfive possible forms: a similar string of hexadecimal digits, or a tuple\nof six integer fields (with 32-bit, 16-bit, 16-bit, 8-bit, 8-bit, and\n48-bit values respectively) as an argument named 'fields', or a string\nof 16 bytes (with all the integer fields in big-endian order) as an\nargument named 'bytes', or a string of 16 bytes (with the first three\nfields in little-endian order) as an argument named 'bytes_le', or a\nsingle 128-bit integer as an argument named 'int'.\n\nUUIDs have these read-only attributes:\n\n    bytes       the UUID as a 16-byte string (containing the six\n                integer fields in big-endian byte order)\n\n    bytes_le    the UUID as a 16-byte string (with time_low, time_mid,\n                and time_hi_version in little-endian byte order)\n\n    fields      a tuple of the six integer fields of the UUID,\n                which are also available as six individual attributes\n                and two derived attributes:\n\n        time_low                the first 32 bits of the UUID\n        time_mid                the next 16 bits of the UUID\n        time_hi_version         the next 16 bits of the UUID\n        clock_seq_hi_variant    the next 8 bits of the UUID\n        clock_seq_low           the next 8 bits of the UUID\n        node                    the last 48 bits of the UUID\n\n        time                    the 60-bit timestamp\n        clock_seq               the 14-bit sequence number\n\n    hex         the UUID as a 32-character hexadecimal string\n\n    int         the UUID as a 128-bit integer\n\n    urn         the UUID as a URN as specified in RFC 4122\n\n    variant     the UUID variant (one of the constants RESERVED_NCS,\n                RFC_4122, RESERVED_MICROSOFT, or RESERVED_FUTURE)\n\n    version     the UUID version number (1 through 5, meaningful only\n                when the variant is RFC_4122)\n\n    is_safe     An enum indicating whether the UUID has been generated in\n                a way that is safe for multiprocessing applications, via\n                uuid_generate_time_safe(3).",
      "source_code": "class UUID:\n    \"\"\"Instances of the UUID class represent UUIDs as specified in RFC 4122.\n    UUID objects are immutable, hashable, and usable as dictionary keys.\n    Converting a UUID to a string with str() yields something in the form\n    '12345678-1234-1234-1234-123456789abc'.  The UUID constructor accepts\n    five possible forms: a similar string of hexadecimal digits, or a tuple\n    of six integer fields (with 32-bit, 16-bit, 16-bit, 8-bit, 8-bit, and\n    48-bit values respectively) as an argument named 'fields', or a string\n    of 16 bytes (with all the integer fields in big-endian order) as an\n    argument named 'bytes', or a string of 16 bytes (with the first three\n    fields in little-endian order) as an argument named 'bytes_le', or a\n    single 128-bit integer as an argument named 'int'.\n\n    UUIDs have these read-only attributes:\n\n        bytes       the UUID as a 16-byte string (containing the six\n                    integer fields in big-endian byte order)\n\n        bytes_le    the UUID as a 16-byte string (with time_low, time_mid,\n                    and time_hi_version in little-endian byte order)\n\n        fields      a tuple of the six integer fields of the UUID,\n                    which are also available as six individual attributes\n                    and two derived attributes:\n\n            time_low                the first 32 bits of the UUID\n            time_mid                the next 16 bits of the UUID\n            time_hi_version         the next 16 bits of the UUID\n            clock_seq_hi_variant    the next 8 bits of the UUID\n            clock_seq_low           the next 8 bits of the UUID\n            node                    the last 48 bits of the UUID\n\n            time                    the 60-bit timestamp\n            clock_seq               the 14-bit sequence number\n\n        hex         the UUID as a 32-character hexadecimal string\n\n        int         the UUID as a 128-bit integer\n\n        urn         the UUID as a URN as specified in RFC 4122\n\n        variant     the UUID variant (one of the constants RESERVED_NCS,\n                    RFC_4122, RESERVED_MICROSOFT, or RESERVED_FUTURE)\n\n        version     the UUID version number (1 through 5, meaningful only\n                    when the variant is RFC_4122)\n\n        is_safe     An enum indicating whether the UUID has been generated in\n                    a way that is safe for multiprocessing applications, via\n                    uuid_generate_time_safe(3).\n    \"\"\"\n\n    __slots__ = ('int', 'is_safe', '__weakref__')\n\n    def __init__(self, hex=None, bytes=None, bytes_le=None, fields=None,\n                       int=None, version=None,\n                       *, is_safe=SafeUUID.unknown):\n        r\"\"\"Create a UUID from either a string of 32 hexadecimal digits,\n        a string of 16 bytes as the 'bytes' argument, a string of 16 bytes\n        in little-endian order as the 'bytes_le' argument, a tuple of six\n        integers (32-bit time_low, 16-bit time_mid, 16-bit time_hi_version,\n        8-bit clock_seq_hi_variant, 8-bit clock_seq_low, 48-bit node) as\n        the 'fields' argument, or a single 128-bit integer as the 'int'\n        argument.  When a string of hex digits is given, curly braces,\n        hyphens, and a URN prefix are all optional.  For example, these\n        expressions all yield the same UUID:\n\n        UUID('{12345678-1234-5678-1234-567812345678}')\n        UUID('12345678123456781234567812345678')\n        UUID('urn:uuid:12345678-1234-5678-1234-567812345678')\n        UUID(bytes='\\x12\\x34\\x56\\x78'*4)\n        UUID(bytes_le='\\x78\\x56\\x34\\x12\\x34\\x12\\x78\\x56' +\n                      '\\x12\\x34\\x56\\x78\\x12\\x34\\x56\\x78')\n        UUID(fields=(0x12345678, 0x1234, 0x5678, 0x12, 0x34, 0x567812345678))\n        UUID(int=0x12345678123456781234567812345678)\n\n        Exactly one of 'hex', 'bytes', 'bytes_le', 'fields', or 'int' must\n        be given.  The 'version' argument is optional; if given, the resulting\n        UUID will have its variant and version set according to RFC 4122,\n        overriding the given 'hex', 'bytes', 'bytes_le', 'fields', or 'int'.\n\n        is_safe is an enum exposed as an attribute on the instance.  It\n        indicates whether the UUID has been generated in a way that is safe\n        for multiprocessing applications, via uuid_generate_time_safe(3).\n        \"\"\"\n\n        if [hex, bytes, bytes_le, fields, int].count(None) != 4:\n            raise TypeError('one of the hex, bytes, bytes_le, fields, '\n                            'or int arguments must be given')\n        if hex is not None:\n            hex = hex.replace('urn:', '').replace('uuid:', '')\n            hex = hex.strip('{}').replace('-', '')\n            if len(hex) != 32:\n                raise ValueError('badly formed hexadecimal UUID string')\n            int = int_(hex, 16)\n        if bytes_le is not None:\n            if len(bytes_le) != 16:\n                raise ValueError('bytes_le is not a 16-char string')\n            bytes = (bytes_le[4-1::-1] + bytes_le[6-1:4-1:-1] +\n                     bytes_le[8-1:6-1:-1] + bytes_le[8:])\n        if bytes is not None:\n            if len(bytes) != 16:\n                raise ValueError('bytes is not a 16-char string')\n            assert isinstance(bytes, bytes_), repr(bytes)\n            int = int_.from_bytes(bytes, byteorder='big')\n        if fields is not None:\n            if len(fields) != 6:\n                raise ValueError('fields is not a 6-tuple')\n            (time_low, time_mid, time_hi_version,\n             clock_seq_hi_variant, clock_seq_low, node) = fields\n            if not 0 <= time_low < 1<<32:\n                raise ValueError('field 1 out of range (need a 32-bit value)')\n            if not 0 <= time_mid < 1<<16:\n                raise ValueError('field 2 out of range (need a 16-bit value)')\n            if not 0 <= time_hi_version < 1<<16:\n                raise ValueError('field 3 out of range (need a 16-bit value)')\n            if not 0 <= clock_seq_hi_variant < 1<<8:\n                raise ValueError('field 4 out of range (need an 8-bit value)')\n            if not 0 <= clock_seq_low < 1<<8:\n                raise ValueError('field 5 out of range (need an 8-bit value)')\n            if not 0 <= node < 1<<48:\n                raise ValueError('field 6 out of range (need a 48-bit value)')\n            clock_seq = (clock_seq_hi_variant << 8) | clock_seq_low\n            int = ((time_low << 96) | (time_mid << 80) |\n                   (time_hi_version << 64) | (clock_seq << 48) | node)\n        if int is not None:\n            if not 0 <= int < 1<<128:\n                raise ValueError('int is out of range (need a 128-bit value)')\n        if version is not None:\n            if not 1 <= version <= 5:\n                raise ValueError('illegal version number')\n            # Set the variant to RFC 4122.\n            int &= ~(0xc000 << 48)\n            int |= 0x8000 << 48\n            # Set the version number.\n            int &= ~(0xf000 << 64)\n            int |= version << 76\n        object.__setattr__(self, 'int', int)\n        object.__setattr__(self, 'is_safe', is_safe)\n\n    def __getstate__(self):\n        d = {'int': self.int}\n        if self.is_safe != SafeUUID.unknown:\n            # is_safe is a SafeUUID instance.  Return just its value, so that\n            # it can be un-pickled in older Python versions without SafeUUID.\n            d['is_safe'] = self.is_safe.value\n        return d\n\n    def __setstate__(self, state):\n        object.__setattr__(self, 'int', state['int'])\n        # is_safe was added in 3.7; it is also omitted when it is \"unknown\"\n        object.__setattr__(self, 'is_safe',\n                           SafeUUID(state['is_safe'])\n                           if 'is_safe' in state else SafeUUID.unknown)\n\n    def __eq__(self, other):\n        if isinstance(other, UUID):\n            return self.int == other.int\n        return NotImplemented\n\n    # Q. What's the value of being able to sort UUIDs?\n    # A. Use them as keys in a B-Tree or similar mapping.\n\n    def __lt__(self, other):\n        if isinstance(other, UUID):\n            return self.int < other.int\n        return NotImplemented\n\n    def __gt__(self, other):\n        if isinstance(other, UUID):\n            return self.int > other.int\n        return NotImplemented\n\n    def __le__(self, other):\n        if isinstance(other, UUID):\n            return self.int <= other.int\n        return NotImplemented\n\n    def __ge__(self, other):\n        if isinstance(other, UUID):\n            return self.int >= other.int\n        return NotImplemented\n\n    def __hash__(self):\n        return hash(self.int)\n\n    def __int__(self):\n        return self.int\n\n    def __repr__(self):\n        return '%s(%r)' % (self.__class__.__name__, str(self))\n\n    def __setattr__(self, name, value):\n        raise TypeError('UUID objects are immutable')\n\n    def __str__(self):\n        hex = '%032x' % self.int\n        return '%s-%s-%s-%s-%s' % (\n            hex[:8], hex[8:12], hex[12:16], hex[16:20], hex[20:])\n\n    @property\n    def bytes(self):\n        return self.int.to_bytes(16, 'big')\n\n    @property\n    def bytes_le(self):\n        bytes = self.bytes\n        return (bytes[4-1::-1] + bytes[6-1:4-1:-1] + bytes[8-1:6-1:-1] +\n                bytes[8:])\n\n    @property\n    def fields(self):\n        return (self.time_low, self.time_mid, self.time_hi_version,\n                self.clock_seq_hi_variant, self.clock_seq_low, self.node)\n\n    @property\n    def time_low(self):\n        return self.int >> 96\n\n    @property\n    def time_mid(self):\n        return (self.int >> 80) & 0xffff\n\n    @property\n    def time_hi_version(self):\n        return (self.int >> 64) & 0xffff\n\n    @property\n    def clock_seq_hi_variant(self):\n        return (self.int >> 56) & 0xff\n\n    @property\n    def clock_seq_low(self):\n        return (self.int >> 48) & 0xff\n\n    @property\n    def time(self):\n        return (((self.time_hi_version & 0x0fff) << 48) |\n                (self.time_mid << 32) | self.time_low)\n\n    @property\n    def clock_seq(self):\n        return (((self.clock_seq_hi_variant & 0x3f) << 8) |\n                self.clock_seq_low)\n\n    @property\n    def node(self):\n        return self.int & 0xffffffffffff\n\n    @property\n    def hex(self):\n        return '%032x' % self.int\n\n    @property\n    def urn(self):\n        return 'urn:uuid:' + str(self)\n\n    @property\n    def variant(self):\n        if not self.int & (0x8000 << 48):\n            return RESERVED_NCS\n        elif not self.int & (0x4000 << 48):\n            return RFC_4122\n        elif not self.int & (0x2000 << 48):\n            return RESERVED_MICROSOFT\n        else:\n            return RESERVED_FUTURE\n\n    @property\n    def version(self):\n        # The version bits are only meaningful for RFC 4122 UUIDs.\n        if self.variant == RFC_4122:\n            return int((self.int >> 76) & 0xf)\n"
    },
    {
      "type": "class",
      "qualified_name": "shortuuid.main.ShortUUID",
      "module": "shortuuid.main",
      "signature": "(self, alphabet: Optional[str] = None) -> None",
      "return_description": null,
      "raises": [],
      "decorators": [
        "property"
      ],
      "examples": [],
      "docstring": "",
      "source_code": "class ShortUUID(object):\n    def __init__(self, alphabet: Optional[str] = None) -> None:\n        if alphabet is None:\n            alphabet = \"23456789ABCDEFGHJKLMNPQRSTUVWXYZ\" \"abcdefghijkmnopqrstuvwxyz\"\n\n        self.set_alphabet(alphabet)\n\n    @property\n    def _length(self) -> int:\n        \"\"\"Return the necessary length to fit the entire UUID given the current alphabet.\"\"\"\n        return int(math.ceil(math.log(2**128, self._alpha_len)))\n\n    def encode(self, uuid: _uu.UUID, pad_length: Optional[int] = None) -> str:\n        \"\"\"\n        Encode a UUID into a string (LSB first) according to the alphabet.\n\n        If leftmost (MSB) bits are 0, the string might be shorter.\n        \"\"\"\n        if not isinstance(uuid, _uu.UUID):\n            raise ValueError(\"Input `uuid` must be a UUID object.\")\n        if pad_length is None:\n            pad_length = self._length\n        return int_to_string(uuid.int, self._alphabet, padding=pad_length)\n\n    def decode(self, string: str, legacy: bool = False) -> _uu.UUID:\n        \"\"\"\n        Decode a string according to the current alphabet into a UUID.\n\n        Raises ValueError when encountering illegal characters or a too-long string.\n\n        If string too short, fills leftmost (MSB) bits with 0.\n\n        Pass `legacy=True` if your UUID was encoded with a ShortUUID version prior to\n        1.0.0.\n        \"\"\"\n        if not isinstance(string, str):\n            raise ValueError(\"Input `string` must be a str.\")\n        if legacy:\n            string = string[::-1]\n        return _uu.UUID(int=string_to_int(string, self._alphabet))\n\n    def uuid(self, name: Optional[str] = None, pad_length: Optional[int] = None) -> str:\n        \"\"\"\n        Generate and return a UUID.\n\n        If the name parameter is provided, set the namespace to the provided\n        name and generate a UUID.\n        \"\"\"\n        if pad_length is None:\n            pad_length = self._length\n\n        # If no name is given, generate a random UUID.\n        if name is None:\n            u = _uu.uuid4()\n        elif name.lower().startswith((\"http://\", \"https://\")):\n            u = _uu.uuid5(_uu.NAMESPACE_URL, name)\n        else:\n            u = _uu.uuid5(_uu.NAMESPACE_DNS, name)\n        return self.encode(u, pad_length)\n\n    def random(self, length: Optional[int] = None) -> str:\n        \"\"\"Generate and return a cryptographically secure short random string of `length`.\"\"\"\n        if length is None:\n            length = self._length\n\n        return \"\".join(secrets.choice(self._alphabet) for _ in range(length))\n\n    def get_alphabet(self) -> str:\n        \"\"\"Return the current alphabet used for new UUIDs.\"\"\"\n        return \"\".join(self._alphabet)\n\n    def set_alphabet(self, alphabet: str) -> None:\n        \"\"\"Set the alphabet to be used for new UUIDs.\"\"\"\n        # Turn the alphabet into a set and sort it to prevent duplicates\n        # and ensure reproducibility.\n        new_alphabet = list(sorted(set(alphabet)))\n        if len(new_alphabet) > 1:\n            self._alphabet = new_alphabet\n            self._alpha_len = len(self._alphabet)\n        else:\n            raise ValueError(\"Alphabet with more than \" \"one unique symbols required.\")\n\n    def encoded_length(self, num_bytes: int = 16) -> int:\n        \"\"\"Return the string length of the shortened UUID.\"\"\"\n        factor = math.log(256) / math.log(self._alpha_len)\n        return int(math.ceil(factor * num_bytes))\n"
    },
    {
      "type": "class",
      "qualified_name": "shortuuid.test_shortuuid.ClassShortUUIDTest",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, methodName='runTest')",
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "A class whose instances are single test cases.\n\nBy default, the test code itself should be placed in a method named\n'runTest'.\n\nIf the fixture may be used for many test cases, create as\nmany test methods as are needed. When instantiating such a TestCase\nsubclass, specify in the constructor arguments the name of the test method\nthat the instance is to execute.\n\nTest authors should subclass TestCase for their own tests. Construction\nand deconstruction of the test's environment ('fixture') can be\nimplemented by overriding the 'setUp' and 'tearDown' methods respectively.\n\nIf it is necessary to override the __init__ method, the base class\n__init__ method must always be called. It is important that subclasses\nshould not change the signature of their __init__ method, since instances\nof the classes are instantiated automatically by parts of the framework\nin order to be run.\n\nWhen subclassing TestCase, you can set these attributes:\n* failureException: determines which exception will be raised when\n    the instance's assertion methods fail; test methods raising this\n    exception will be deemed to have 'failed' rather than 'errored'.\n* longMessage: determines whether long messages (including repr of\n    objects used in assert methods) will be printed on failure in *addition*\n    to any explicit message passed.\n* maxDiff: sets the maximum length of a diff in failure messages\n    by assert methods using difflib. It is looked up as an instance\n    attribute so can be configured by individual tests if required.",
      "source_code": "class ClassShortUUIDTest(unittest.TestCase):\n    def test_generation(self):\n        su = ShortUUID()\n        self.assertTrue(20 < len(su.uuid()) < 24)\n        self.assertTrue(20 < len(su.uuid(\"http://www.example.com/\")) < 24)\n        self.assertTrue(20 < len(su.uuid(\"HTTP://www.example.com/\")) < 24)\n        self.assertTrue(20 < len(su.uuid(\"example.com/\")) < 24)\n\n    def test_encoding(self):\n        su = ShortUUID()\n        u = UUID(\"{3b1f8b40-222c-4a6e-b77e-779d5a94e21c}\")\n        self.assertEqual(su.encode(u), \"CXc85b4rqinB7s5J52TRYb\")\n\n    def test_decoding(self):\n        su = ShortUUID()\n        u = UUID(\"{3b1f8b40-222c-4a6e-b77e-779d5a94e21c}\")\n        self.assertEqual(su.decode(\"CXc85b4rqinB7s5J52TRYb\"), u)\n\n    def test_random(self):\n        su = ShortUUID()\n        for i in range(1000):\n            self.assertEqual(len(su.random()), 22)\n\n        for i in range(1, 100):\n            self.assertEqual(len(su.random(i)), i)\n\n    def test_alphabet(self):\n        alphabet = \"01\"\n        su1 = ShortUUID(alphabet)\n        su2 = ShortUUID()\n\n        self.assertEqual(alphabet, su1.get_alphabet())\n\n        su1.set_alphabet(\"01010101010101\")\n        self.assertEqual(alphabet, su1.get_alphabet())\n\n        self.assertEqual(set(su1.uuid()), set(\"01\"))\n        self.assertTrue(116 < len(su1.uuid()) < 140)\n        self.assertTrue(20 < len(su2.uuid()) < 24)\n\n        u = uuid4()\n        self.assertEqual(u, su1.decode(su1.encode(u)))\n\n        u = su1.uuid()\n        self.assertEqual(u, su1.encode(su1.decode(u)))\n\n        self.assertRaises(ValueError, su1.set_alphabet, \"1\")\n        self.assertRaises(ValueError, su1.set_alphabet, \"1111111\")\n\n    def test_encoded_length(self):\n        su1 = ShortUUID()\n        self.assertEqual(su1.encoded_length(), 22)\n\n        base64_alphabet = (\n            string.ascii_uppercase + string.ascii_lowercase + string.digits + \"+/\"\n        )\n\n        su2 = ShortUUID(base64_alphabet)\n        self.assertEqual(su2.encoded_length(), 22)\n\n        binary_alphabet = \"01\"\n        su3 = ShortUUID(binary_alphabet)\n        self.assertEqual(su3.encoded_length(), 128)\n\n        su4 = ShortUUID()\n        self.assertEqual(su4.encoded_length(num_bytes=8), 11)\n"
    },
    {
      "type": "class",
      "qualified_name": "shortuuid.test_shortuuid.CliTest",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, methodName='runTest')",
      "return_description": null,
      "raises": [],
      "decorators": [
        "patch(\"shortuuid.cli.print\")",
        "patch(\"shortuuid.cli.print\")",
        "patch(\"shortuuid.cli.print\")"
      ],
      "examples": [],
      "docstring": "A class whose instances are single test cases.\n\nBy default, the test code itself should be placed in a method named\n'runTest'.\n\nIf the fixture may be used for many test cases, create as\nmany test methods as are needed. When instantiating such a TestCase\nsubclass, specify in the constructor arguments the name of the test method\nthat the instance is to execute.\n\nTest authors should subclass TestCase for their own tests. Construction\nand deconstruction of the test's environment ('fixture') can be\nimplemented by overriding the 'setUp' and 'tearDown' methods respectively.\n\nIf it is necessary to override the __init__ method, the base class\n__init__ method must always be called. It is important that subclasses\nshould not change the signature of their __init__ method, since instances\nof the classes are instantiated automatically by parts of the framework\nin order to be run.\n\nWhen subclassing TestCase, you can set these attributes:\n* failureException: determines which exception will be raised when\n    the instance's assertion methods fail; test methods raising this\n    exception will be deemed to have 'failed' rather than 'errored'.\n* longMessage: determines whether long messages (including repr of\n    objects used in assert methods) will be printed on failure in *addition*\n    to any explicit message passed.\n* maxDiff: sets the maximum length of a diff in failure messages\n    by assert methods using difflib. It is looked up as an instance\n    attribute so can be configured by individual tests if required.",
      "source_code": "class CliTest(unittest.TestCase):\n    @patch(\"shortuuid.cli.print\")\n    def test_shortuuid_command_produces_uuid(self, mock_print):\n        # When we call the main cli function\n        cli([])\n        # Then a shortuuid is printed out\n        mock_print.assert_called()\n        terminal_output = mock_print.call_args[0][0]\n        self.assertEqual(len(terminal_output), 22)\n\n    @patch(\"shortuuid.cli.print\")\n    def test_encode_command(self, mock_print):\n        cli([\"encode\", \"3b1f8b40-222c-4a6e-b77e-779d5a94e21c\"])\n\n        terminal_output = mock_print.call_args[0][0]\n        self.assertEqual(terminal_output, \"CXc85b4rqinB7s5J52TRYb\")\n\n    @patch(\"shortuuid.cli.print\")\n    def test_decode_command(self, mock_print):\n        cli([\"decode\", \"CXc85b4rqinB7s5J52TRYb\"])\n\n        terminal_output = mock_print.call_args[0][0]\n        self.assertEqual(terminal_output, \"3b1f8b40-222c-4a6e-b77e-779d5a94e21c\")\n"
    },
    {
      "type": "class",
      "qualified_name": "shortuuid.test_shortuuid.DecodingEdgeCasesTest",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, methodName='runTest')",
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "A class whose instances are single test cases.\n\nBy default, the test code itself should be placed in a method named\n'runTest'.\n\nIf the fixture may be used for many test cases, create as\nmany test methods as are needed. When instantiating such a TestCase\nsubclass, specify in the constructor arguments the name of the test method\nthat the instance is to execute.\n\nTest authors should subclass TestCase for their own tests. Construction\nand deconstruction of the test's environment ('fixture') can be\nimplemented by overriding the 'setUp' and 'tearDown' methods respectively.\n\nIf it is necessary to override the __init__ method, the base class\n__init__ method must always be called. It is important that subclasses\nshould not change the signature of their __init__ method, since instances\nof the classes are instantiated automatically by parts of the framework\nin order to be run.\n\nWhen subclassing TestCase, you can set these attributes:\n* failureException: determines which exception will be raised when\n    the instance's assertion methods fail; test methods raising this\n    exception will be deemed to have 'failed' rather than 'errored'.\n* longMessage: determines whether long messages (including repr of\n    objects used in assert methods) will be printed on failure in *addition*\n    to any explicit message passed.\n* maxDiff: sets the maximum length of a diff in failure messages\n    by assert methods using difflib. It is looked up as an instance\n    attribute so can be configured by individual tests if required.",
      "source_code": "class DecodingEdgeCasesTest(unittest.TestCase):\n    def test_decode_dict(self):\n        su = ShortUUID()\n        self.assertRaises(ValueError, su.decode, [])\n        self.assertRaises(ValueError, su.decode, {})\n        self.assertRaises(ValueError, su.decode, (2,))\n        self.assertRaises(ValueError, su.decode, 42)\n        self.assertRaises(ValueError, su.decode, 42.0)\n"
    },
    {
      "type": "class",
      "qualified_name": "shortuuid.test_shortuuid.EncodingEdgeCasesTest",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, methodName='runTest')",
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "A class whose instances are single test cases.\n\nBy default, the test code itself should be placed in a method named\n'runTest'.\n\nIf the fixture may be used for many test cases, create as\nmany test methods as are needed. When instantiating such a TestCase\nsubclass, specify in the constructor arguments the name of the test method\nthat the instance is to execute.\n\nTest authors should subclass TestCase for their own tests. Construction\nand deconstruction of the test's environment ('fixture') can be\nimplemented by overriding the 'setUp' and 'tearDown' methods respectively.\n\nIf it is necessary to override the __init__ method, the base class\n__init__ method must always be called. It is important that subclasses\nshould not change the signature of their __init__ method, since instances\nof the classes are instantiated automatically by parts of the framework\nin order to be run.\n\nWhen subclassing TestCase, you can set these attributes:\n* failureException: determines which exception will be raised when\n    the instance's assertion methods fail; test methods raising this\n    exception will be deemed to have 'failed' rather than 'errored'.\n* longMessage: determines whether long messages (including repr of\n    objects used in assert methods) will be printed on failure in *addition*\n    to any explicit message passed.\n* maxDiff: sets the maximum length of a diff in failure messages\n    by assert methods using difflib. It is looked up as an instance\n    attribute so can be configured by individual tests if required.",
      "source_code": "class EncodingEdgeCasesTest(unittest.TestCase):\n    def test_decode_dict(self):\n        su = ShortUUID()\n        self.assertRaises(ValueError, su.encode, [])\n        self.assertRaises(ValueError, su.encode, {})\n        self.assertRaises(ValueError, su.decode, (2,))\n        self.assertRaises(ValueError, su.encode, 42)\n        self.assertRaises(ValueError, su.encode, 42.0)\n"
    },
    {
      "type": "class",
      "qualified_name": "shortuuid.test_shortuuid.LegacyShortUUIDTest",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, methodName='runTest')",
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "A class whose instances are single test cases.\n\nBy default, the test code itself should be placed in a method named\n'runTest'.\n\nIf the fixture may be used for many test cases, create as\nmany test methods as are needed. When instantiating such a TestCase\nsubclass, specify in the constructor arguments the name of the test method\nthat the instance is to execute.\n\nTest authors should subclass TestCase for their own tests. Construction\nand deconstruction of the test's environment ('fixture') can be\nimplemented by overriding the 'setUp' and 'tearDown' methods respectively.\n\nIf it is necessary to override the __init__ method, the base class\n__init__ method must always be called. It is important that subclasses\nshould not change the signature of their __init__ method, since instances\nof the classes are instantiated automatically by parts of the framework\nin order to be run.\n\nWhen subclassing TestCase, you can set these attributes:\n* failureException: determines which exception will be raised when\n    the instance's assertion methods fail; test methods raising this\n    exception will be deemed to have 'failed' rather than 'errored'.\n* longMessage: determines whether long messages (including repr of\n    objects used in assert methods) will be printed on failure in *addition*\n    to any explicit message passed.\n* maxDiff: sets the maximum length of a diff in failure messages\n    by assert methods using difflib. It is looked up as an instance\n    attribute so can be configured by individual tests if required.",
      "source_code": "class LegacyShortUUIDTest(unittest.TestCase):\n    def test_generation(self):\n        self.assertTrue(20 < len(uuid()) < 24)\n        self.assertTrue(20 < len(uuid(\"http://www.example.com/\")) < 24)\n        self.assertTrue(20 < len(uuid(\"HTTP://www.example.com/\")) < 24)\n        self.assertTrue(20 < len(uuid(\"example.com/\")) < 24)\n\n    def test_encoding(self):\n        u = UUID(\"{3b1f8b40-222c-4a6e-b77e-779d5a94e21c}\")\n        self.assertEqual(encode(u), \"CXc85b4rqinB7s5J52TRYb\")\n\n    def test_decoding(self):\n        u = UUID(\"{3b1f8b40-222c-4a6e-b77e-779d5a94e21c}\")\n        self.assertEqual(decode(\"CXc85b4rqinB7s5J52TRYb\"), u)\n\n    def test_alphabet(self):\n        backup_alphabet = get_alphabet()\n\n        alphabet = \"01\"\n        set_alphabet(alphabet)\n        self.assertEqual(alphabet, get_alphabet())\n\n        set_alphabet(\"01010101010101\")\n        self.assertEqual(alphabet, get_alphabet())\n\n        self.assertEqual(set(uuid()), set(\"01\"))\n        self.assertTrue(116 < len(uuid()) < 140)\n\n        u = uuid4()\n        self.assertEqual(u, decode(encode(u)))\n\n        u = uuid()\n        self.assertEqual(u, encode(decode(u)))\n\n        self.assertRaises(ValueError, set_alphabet, \"1\")\n        self.assertRaises(ValueError, set_alphabet, \"1111111\")\n\n        set_alphabet(backup_alphabet)\n\n        self.assertRaises(ValueError, lambda x: ShortUUID(x), \"0\")\n\n    def test_random(self):\n        self.assertEqual(len(random()), 22)\n        for i in range(1, 100):\n            self.assertEqual(len(random(i)), i)\n"
    },
    {
      "type": "class",
      "qualified_name": "shortuuid.test_shortuuid.ShortUUID",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, alphabet: Optional[str] = None) -> None",
      "return_description": null,
      "raises": [],
      "decorators": [
        "property"
      ],
      "examples": [],
      "docstring": "",
      "source_code": "class ShortUUID(object):\n    def __init__(self, alphabet: Optional[str] = None) -> None:\n        if alphabet is None:\n            alphabet = \"23456789ABCDEFGHJKLMNPQRSTUVWXYZ\" \"abcdefghijkmnopqrstuvwxyz\"\n\n        self.set_alphabet(alphabet)\n\n    @property\n    def _length(self) -> int:\n        \"\"\"Return the necessary length to fit the entire UUID given the current alphabet.\"\"\"\n        return int(math.ceil(math.log(2**128, self._alpha_len)))\n\n    def encode(self, uuid: _uu.UUID, pad_length: Optional[int] = None) -> str:\n        \"\"\"\n        Encode a UUID into a string (LSB first) according to the alphabet.\n\n        If leftmost (MSB) bits are 0, the string might be shorter.\n        \"\"\"\n        if not isinstance(uuid, _uu.UUID):\n            raise ValueError(\"Input `uuid` must be a UUID object.\")\n        if pad_length is None:\n            pad_length = self._length\n        return int_to_string(uuid.int, self._alphabet, padding=pad_length)\n\n    def decode(self, string: str, legacy: bool = False) -> _uu.UUID:\n        \"\"\"\n        Decode a string according to the current alphabet into a UUID.\n\n        Raises ValueError when encountering illegal characters or a too-long string.\n\n        If string too short, fills leftmost (MSB) bits with 0.\n\n        Pass `legacy=True` if your UUID was encoded with a ShortUUID version prior to\n        1.0.0.\n        \"\"\"\n        if not isinstance(string, str):\n            raise ValueError(\"Input `string` must be a str.\")\n        if legacy:\n            string = string[::-1]\n        return _uu.UUID(int=string_to_int(string, self._alphabet))\n\n    def uuid(self, name: Optional[str] = None, pad_length: Optional[int] = None) -> str:\n        \"\"\"\n        Generate and return a UUID.\n\n        If the name parameter is provided, set the namespace to the provided\n        name and generate a UUID.\n        \"\"\"\n        if pad_length is None:\n            pad_length = self._length\n\n        # If no name is given, generate a random UUID.\n        if name is None:\n            u = _uu.uuid4()\n        elif name.lower().startswith((\"http://\", \"https://\")):\n            u = _uu.uuid5(_uu.NAMESPACE_URL, name)\n        else:\n            u = _uu.uuid5(_uu.NAMESPACE_DNS, name)\n        return self.encode(u, pad_length)\n\n    def random(self, length: Optional[int] = None) -> str:\n        \"\"\"Generate and return a cryptographically secure short random string of `length`.\"\"\"\n        if length is None:\n            length = self._length\n\n        return \"\".join(secrets.choice(self._alphabet) for _ in range(length))\n\n    def get_alphabet(self) -> str:\n        \"\"\"Return the current alphabet used for new UUIDs.\"\"\"\n        return \"\".join(self._alphabet)\n\n    def set_alphabet(self, alphabet: str) -> None:\n        \"\"\"Set the alphabet to be used for new UUIDs.\"\"\"\n        # Turn the alphabet into a set and sort it to prevent duplicates\n        # and ensure reproducibility.\n        new_alphabet = list(sorted(set(alphabet)))\n        if len(new_alphabet) > 1:\n            self._alphabet = new_alphabet\n            self._alpha_len = len(self._alphabet)\n        else:\n            raise ValueError(\"Alphabet with more than \" \"one unique symbols required.\")\n\n    def encoded_length(self, num_bytes: int = 16) -> int:\n        \"\"\"Return the string length of the shortened UUID.\"\"\"\n        factor = math.log(256) / math.log(self._alpha_len)\n        return int(math.ceil(factor * num_bytes))\n"
    },
    {
      "type": "class",
      "qualified_name": "shortuuid.test_shortuuid.ShortUUIDPaddingTest",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, methodName='runTest')",
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "A class whose instances are single test cases.\n\nBy default, the test code itself should be placed in a method named\n'runTest'.\n\nIf the fixture may be used for many test cases, create as\nmany test methods as are needed. When instantiating such a TestCase\nsubclass, specify in the constructor arguments the name of the test method\nthat the instance is to execute.\n\nTest authors should subclass TestCase for their own tests. Construction\nand deconstruction of the test's environment ('fixture') can be\nimplemented by overriding the 'setUp' and 'tearDown' methods respectively.\n\nIf it is necessary to override the __init__ method, the base class\n__init__ method must always be called. It is important that subclasses\nshould not change the signature of their __init__ method, since instances\nof the classes are instantiated automatically by parts of the framework\nin order to be run.\n\nWhen subclassing TestCase, you can set these attributes:\n* failureException: determines which exception will be raised when\n    the instance's assertion methods fail; test methods raising this\n    exception will be deemed to have 'failed' rather than 'errored'.\n* longMessage: determines whether long messages (including repr of\n    objects used in assert methods) will be printed on failure in *addition*\n    to any explicit message passed.\n* maxDiff: sets the maximum length of a diff in failure messages\n    by assert methods using difflib. It is looked up as an instance\n    attribute so can be configured by individual tests if required.",
      "source_code": "class ShortUUIDPaddingTest(unittest.TestCase):\n    def test_padding(self):\n        su = ShortUUID()\n        random_uid = uuid4()\n        smallest_uid = UUID(int=0)\n\n        encoded_random = su.encode(random_uid)\n        encoded_small = su.encode(smallest_uid)\n\n        self.assertEqual(len(encoded_random), len(encoded_small))\n\n    def test_decoding(self):\n        su = ShortUUID()\n        random_uid = uuid4()\n        smallest_uid = UUID(int=0)\n\n        encoded_random = su.encode(random_uid)\n        encoded_small = su.encode(smallest_uid)\n\n        self.assertEqual(su.decode(encoded_small), smallest_uid)\n        self.assertEqual(su.decode(encoded_random), random_uid)\n\n    def test_consistency(self):\n        su = ShortUUID()\n        num_iterations = 1000\n        uid_lengths = defaultdict(int)\n\n        for count in range(num_iterations):\n            random_uid = uuid4()\n            encoded_random = su.encode(random_uid)\n            uid_lengths[len(encoded_random)] += 1\n            decoded_random = su.decode(encoded_random)\n\n            self.assertEqual(random_uid, decoded_random)\n\n        self.assertEqual(len(uid_lengths), 1)\n        uid_length = next(iter(uid_lengths.keys()))  # Get the 1 value\n\n        self.assertEqual(uid_lengths[uid_length], num_iterations)\n"
    },
    {
      "type": "class",
      "qualified_name": "shortuuid.test_shortuuid.UUID",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, hex=None, bytes=None, bytes_le=None, fields=None, int=None, version=None, *, is_safe=<SafeUUID.unknown: None>)",
      "return_description": null,
      "raises": [],
      "decorators": [
        "property",
        "property",
        "property",
        "property",
        "property",
        "property",
        "property",
        "property",
        "property",
        "property",
        "property",
        "property",
        "property",
        "property",
        "property"
      ],
      "examples": [],
      "docstring": "Instances of the UUID class represent UUIDs as specified in RFC 4122.\nUUID objects are immutable, hashable, and usable as dictionary keys.\nConverting a UUID to a string with str() yields something in the form\n'12345678-1234-1234-1234-123456789abc'.  The UUID constructor accepts\nfive possible forms: a similar string of hexadecimal digits, or a tuple\nof six integer fields (with 32-bit, 16-bit, 16-bit, 8-bit, 8-bit, and\n48-bit values respectively) as an argument named 'fields', or a string\nof 16 bytes (with all the integer fields in big-endian order) as an\nargument named 'bytes', or a string of 16 bytes (with the first three\nfields in little-endian order) as an argument named 'bytes_le', or a\nsingle 128-bit integer as an argument named 'int'.\n\nUUIDs have these read-only attributes:\n\n    bytes       the UUID as a 16-byte string (containing the six\n                integer fields in big-endian byte order)\n\n    bytes_le    the UUID as a 16-byte string (with time_low, time_mid,\n                and time_hi_version in little-endian byte order)\n\n    fields      a tuple of the six integer fields of the UUID,\n                which are also available as six individual attributes\n                and two derived attributes:\n\n        time_low                the first 32 bits of the UUID\n        time_mid                the next 16 bits of the UUID\n        time_hi_version         the next 16 bits of the UUID\n        clock_seq_hi_variant    the next 8 bits of the UUID\n        clock_seq_low           the next 8 bits of the UUID\n        node                    the last 48 bits of the UUID\n\n        time                    the 60-bit timestamp\n        clock_seq               the 14-bit sequence number\n\n    hex         the UUID as a 32-character hexadecimal string\n\n    int         the UUID as a 128-bit integer\n\n    urn         the UUID as a URN as specified in RFC 4122\n\n    variant     the UUID variant (one of the constants RESERVED_NCS,\n                RFC_4122, RESERVED_MICROSOFT, or RESERVED_FUTURE)\n\n    version     the UUID version number (1 through 5, meaningful only\n                when the variant is RFC_4122)\n\n    is_safe     An enum indicating whether the UUID has been generated in\n                a way that is safe for multiprocessing applications, via\n                uuid_generate_time_safe(3).",
      "source_code": "class UUID:\n    \"\"\"Instances of the UUID class represent UUIDs as specified in RFC 4122.\n    UUID objects are immutable, hashable, and usable as dictionary keys.\n    Converting a UUID to a string with str() yields something in the form\n    '12345678-1234-1234-1234-123456789abc'.  The UUID constructor accepts\n    five possible forms: a similar string of hexadecimal digits, or a tuple\n    of six integer fields (with 32-bit, 16-bit, 16-bit, 8-bit, 8-bit, and\n    48-bit values respectively) as an argument named 'fields', or a string\n    of 16 bytes (with all the integer fields in big-endian order) as an\n    argument named 'bytes', or a string of 16 bytes (with the first three\n    fields in little-endian order) as an argument named 'bytes_le', or a\n    single 128-bit integer as an argument named 'int'.\n\n    UUIDs have these read-only attributes:\n\n        bytes       the UUID as a 16-byte string (containing the six\n                    integer fields in big-endian byte order)\n\n        bytes_le    the UUID as a 16-byte string (with time_low, time_mid,\n                    and time_hi_version in little-endian byte order)\n\n        fields      a tuple of the six integer fields of the UUID,\n                    which are also available as six individual attributes\n                    and two derived attributes:\n\n            time_low                the first 32 bits of the UUID\n            time_mid                the next 16 bits of the UUID\n            time_hi_version         the next 16 bits of the UUID\n            clock_seq_hi_variant    the next 8 bits of the UUID\n            clock_seq_low           the next 8 bits of the UUID\n            node                    the last 48 bits of the UUID\n\n            time                    the 60-bit timestamp\n            clock_seq               the 14-bit sequence number\n\n        hex         the UUID as a 32-character hexadecimal string\n\n        int         the UUID as a 128-bit integer\n\n        urn         the UUID as a URN as specified in RFC 4122\n\n        variant     the UUID variant (one of the constants RESERVED_NCS,\n                    RFC_4122, RESERVED_MICROSOFT, or RESERVED_FUTURE)\n\n        version     the UUID version number (1 through 5, meaningful only\n                    when the variant is RFC_4122)\n\n        is_safe     An enum indicating whether the UUID has been generated in\n                    a way that is safe for multiprocessing applications, via\n                    uuid_generate_time_safe(3).\n    \"\"\"\n\n    __slots__ = ('int', 'is_safe', '__weakref__')\n\n    def __init__(self, hex=None, bytes=None, bytes_le=None, fields=None,\n                       int=None, version=None,\n                       *, is_safe=SafeUUID.unknown):\n        r\"\"\"Create a UUID from either a string of 32 hexadecimal digits,\n        a string of 16 bytes as the 'bytes' argument, a string of 16 bytes\n        in little-endian order as the 'bytes_le' argument, a tuple of six\n        integers (32-bit time_low, 16-bit time_mid, 16-bit time_hi_version,\n        8-bit clock_seq_hi_variant, 8-bit clock_seq_low, 48-bit node) as\n        the 'fields' argument, or a single 128-bit integer as the 'int'\n        argument.  When a string of hex digits is given, curly braces,\n        hyphens, and a URN prefix are all optional.  For example, these\n        expressions all yield the same UUID:\n\n        UUID('{12345678-1234-5678-1234-567812345678}')\n        UUID('12345678123456781234567812345678')\n        UUID('urn:uuid:12345678-1234-5678-1234-567812345678')\n        UUID(bytes='\\x12\\x34\\x56\\x78'*4)\n        UUID(bytes_le='\\x78\\x56\\x34\\x12\\x34\\x12\\x78\\x56' +\n                      '\\x12\\x34\\x56\\x78\\x12\\x34\\x56\\x78')\n        UUID(fields=(0x12345678, 0x1234, 0x5678, 0x12, 0x34, 0x567812345678))\n        UUID(int=0x12345678123456781234567812345678)\n\n        Exactly one of 'hex', 'bytes', 'bytes_le', 'fields', or 'int' must\n        be given.  The 'version' argument is optional; if given, the resulting\n        UUID will have its variant and version set according to RFC 4122,\n        overriding the given 'hex', 'bytes', 'bytes_le', 'fields', or 'int'.\n\n        is_safe is an enum exposed as an attribute on the instance.  It\n        indicates whether the UUID has been generated in a way that is safe\n        for multiprocessing applications, via uuid_generate_time_safe(3).\n        \"\"\"\n\n        if [hex, bytes, bytes_le, fields, int].count(None) != 4:\n            raise TypeError('one of the hex, bytes, bytes_le, fields, '\n                            'or int arguments must be given')\n        if hex is not None:\n            hex = hex.replace('urn:', '').replace('uuid:', '')\n            hex = hex.strip('{}').replace('-', '')\n            if len(hex) != 32:\n                raise ValueError('badly formed hexadecimal UUID string')\n            int = int_(hex, 16)\n        if bytes_le is not None:\n            if len(bytes_le) != 16:\n                raise ValueError('bytes_le is not a 16-char string')\n            bytes = (bytes_le[4-1::-1] + bytes_le[6-1:4-1:-1] +\n                     bytes_le[8-1:6-1:-1] + bytes_le[8:])\n        if bytes is not None:\n            if len(bytes) != 16:\n                raise ValueError('bytes is not a 16-char string')\n            assert isinstance(bytes, bytes_), repr(bytes)\n            int = int_.from_bytes(bytes, byteorder='big')\n        if fields is not None:\n            if len(fields) != 6:\n                raise ValueError('fields is not a 6-tuple')\n            (time_low, time_mid, time_hi_version,\n             clock_seq_hi_variant, clock_seq_low, node) = fields\n            if not 0 <= time_low < 1<<32:\n                raise ValueError('field 1 out of range (need a 32-bit value)')\n            if not 0 <= time_mid < 1<<16:\n                raise ValueError('field 2 out of range (need a 16-bit value)')\n            if not 0 <= time_hi_version < 1<<16:\n                raise ValueError('field 3 out of range (need a 16-bit value)')\n            if not 0 <= clock_seq_hi_variant < 1<<8:\n                raise ValueError('field 4 out of range (need an 8-bit value)')\n            if not 0 <= clock_seq_low < 1<<8:\n                raise ValueError('field 5 out of range (need an 8-bit value)')\n            if not 0 <= node < 1<<48:\n                raise ValueError('field 6 out of range (need a 48-bit value)')\n            clock_seq = (clock_seq_hi_variant << 8) | clock_seq_low\n            int = ((time_low << 96) | (time_mid << 80) |\n                   (time_hi_version << 64) | (clock_seq << 48) | node)\n        if int is not None:\n            if not 0 <= int < 1<<128:\n                raise ValueError('int is out of range (need a 128-bit value)')\n        if version is not None:\n            if not 1 <= version <= 5:\n                raise ValueError('illegal version number')\n            # Set the variant to RFC 4122.\n            int &= ~(0xc000 << 48)\n            int |= 0x8000 << 48\n            # Set the version number.\n            int &= ~(0xf000 << 64)\n            int |= version << 76\n        object.__setattr__(self, 'int', int)\n        object.__setattr__(self, 'is_safe', is_safe)\n\n    def __getstate__(self):\n        d = {'int': self.int}\n        if self.is_safe != SafeUUID.unknown:\n            # is_safe is a SafeUUID instance.  Return just its value, so that\n            # it can be un-pickled in older Python versions without SafeUUID.\n            d['is_safe'] = self.is_safe.value\n        return d\n\n    def __setstate__(self, state):\n        object.__setattr__(self, 'int', state['int'])\n        # is_safe was added in 3.7; it is also omitted when it is \"unknown\"\n        object.__setattr__(self, 'is_safe',\n                           SafeUUID(state['is_safe'])\n                           if 'is_safe' in state else SafeUUID.unknown)\n\n    def __eq__(self, other):\n        if isinstance(other, UUID):\n            return self.int == other.int\n        return NotImplemented\n\n    # Q. What's the value of being able to sort UUIDs?\n    # A. Use them as keys in a B-Tree or similar mapping.\n\n    def __lt__(self, other):\n        if isinstance(other, UUID):\n            return self.int < other.int\n        return NotImplemented\n\n    def __gt__(self, other):\n        if isinstance(other, UUID):\n            return self.int > other.int\n        return NotImplemented\n\n    def __le__(self, other):\n        if isinstance(other, UUID):\n            return self.int <= other.int\n        return NotImplemented\n\n    def __ge__(self, other):\n        if isinstance(other, UUID):\n            return self.int >= other.int\n        return NotImplemented\n\n    def __hash__(self):\n        return hash(self.int)\n\n    def __int__(self):\n        return self.int\n\n    def __repr__(self):\n        return '%s(%r)' % (self.__class__.__name__, str(self))\n\n    def __setattr__(self, name, value):\n        raise TypeError('UUID objects are immutable')\n\n    def __str__(self):\n        hex = '%032x' % self.int\n        return '%s-%s-%s-%s-%s' % (\n            hex[:8], hex[8:12], hex[12:16], hex[16:20], hex[20:])\n\n    @property\n    def bytes(self):\n        return self.int.to_bytes(16, 'big')\n\n    @property\n    def bytes_le(self):\n        bytes = self.bytes\n        return (bytes[4-1::-1] + bytes[6-1:4-1:-1] + bytes[8-1:6-1:-1] +\n                bytes[8:])\n\n    @property\n    def fields(self):\n        return (self.time_low, self.time_mid, self.time_hi_version,\n                self.clock_seq_hi_variant, self.clock_seq_low, self.node)\n\n    @property\n    def time_low(self):\n        return self.int >> 96\n\n    @property\n    def time_mid(self):\n        return (self.int >> 80) & 0xffff\n\n    @property\n    def time_hi_version(self):\n        return (self.int >> 64) & 0xffff\n\n    @property\n    def clock_seq_hi_variant(self):\n        return (self.int >> 56) & 0xff\n\n    @property\n    def clock_seq_low(self):\n        return (self.int >> 48) & 0xff\n\n    @property\n    def time(self):\n        return (((self.time_hi_version & 0x0fff) << 48) |\n                (self.time_mid << 32) | self.time_low)\n\n    @property\n    def clock_seq(self):\n        return (((self.clock_seq_hi_variant & 0x3f) << 8) |\n                self.clock_seq_low)\n\n    @property\n    def node(self):\n        return self.int & 0xffffffffffff\n\n    @property\n    def hex(self):\n        return '%032x' % self.int\n\n    @property\n    def urn(self):\n        return 'urn:uuid:' + str(self)\n\n    @property\n    def variant(self):\n        if not self.int & (0x8000 << 48):\n            return RESERVED_NCS\n        elif not self.int & (0x4000 << 48):\n            return RFC_4122\n        elif not self.int & (0x2000 << 48):\n            return RESERVED_MICROSOFT\n        else:\n            return RESERVED_FUTURE\n\n    @property\n    def version(self):\n        # The version bits are only meaningful for RFC 4122 UUIDs.\n        if self.variant == RFC_4122:\n            return int((self.int >> 76) & 0xf)\n"
    },
    {
      "type": "class",
      "qualified_name": "shortuuid.test_shortuuid.defaultdict",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, /, *args, **kwargs)",
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "defaultdict(default_factory=None, /, [...]) --> dict with default factory\n\nThe default factory is called without arguments to produce\na new value when a key is not present, in __getitem__ only.\nA defaultdict compares equal to a dict with the same items.\nAll remaining arguments are treated the same as if they were\npassed to the dict constructor, including keyword arguments.",
      "source_code": null
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.ShortUUID.decode",
      "module": "shortuuid",
      "signature": "(self, string: str, legacy: bool = False) -> uuid.UUID",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "string": {
          "default": null,
          "annotation": "<class 'str'>",
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "legacy": {
          "default": "False",
          "annotation": "<class 'bool'>",
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": "<class 'uuid.UUID'>",
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Decode a string according to the current alphabet into a UUID.\n\nRaises ValueError when encountering illegal characters or a too-long string.\n\nIf string too short, fills leftmost (MSB) bits with 0.\n\nPass `legacy=True` if your UUID was encoded with a ShortUUID version prior to\n1.0.0.",
      "source_code": "    def decode(self, string: str, legacy: bool = False) -> _uu.UUID:\n        \"\"\"\n        Decode a string according to the current alphabet into a UUID.\n\n        Raises ValueError when encountering illegal characters or a too-long string.\n\n        If string too short, fills leftmost (MSB) bits with 0.\n\n        Pass `legacy=True` if your UUID was encoded with a ShortUUID version prior to\n        1.0.0.\n        \"\"\"\n        if not isinstance(string, str):\n            raise ValueError(\"Input `string` must be a str.\")\n        if legacy:\n            string = string[::-1]\n        return _uu.UUID(int=string_to_int(string, self._alphabet))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.ShortUUID.encode",
      "module": "shortuuid",
      "signature": "(self, uuid: uuid.UUID, pad_length: Optional[int] = None) -> str",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "uuid": {
          "default": null,
          "annotation": "<class 'uuid.UUID'>",
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "pad_length": {
          "default": "None",
          "annotation": "typing.Optional[int]",
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": "<class 'str'>",
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Encode a UUID into a string (LSB first) according to the alphabet.\n\nIf leftmost (MSB) bits are 0, the string might be shorter.",
      "source_code": "    def encode(self, uuid: _uu.UUID, pad_length: Optional[int] = None) -> str:\n        \"\"\"\n        Encode a UUID into a string (LSB first) according to the alphabet.\n\n        If leftmost (MSB) bits are 0, the string might be shorter.\n        \"\"\"\n        if not isinstance(uuid, _uu.UUID):\n            raise ValueError(\"Input `uuid` must be a UUID object.\")\n        if pad_length is None:\n            pad_length = self._length\n        return int_to_string(uuid.int, self._alphabet, padding=pad_length)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.ShortUUID.encoded_length",
      "module": "shortuuid",
      "signature": "(self, num_bytes: int = 16) -> int",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "num_bytes": {
          "default": "16",
          "annotation": "<class 'int'>",
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": "<class 'int'>",
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Return the string length of the shortened UUID.",
      "source_code": "    def encoded_length(self, num_bytes: int = 16) -> int:\n        \"\"\"Return the string length of the shortened UUID.\"\"\"\n        factor = math.log(256) / math.log(self._alpha_len)\n        return int(math.ceil(factor * num_bytes))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.ShortUUID.get_alphabet",
      "module": "shortuuid",
      "signature": "(self) -> str",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": "<class 'str'>",
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Return the current alphabet used for new UUIDs.",
      "source_code": "    def get_alphabet(self) -> str:\n        \"\"\"Return the current alphabet used for new UUIDs.\"\"\"\n        return \"\".join(self._alphabet)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.ShortUUID.random",
      "module": "shortuuid",
      "signature": "(self, length: Optional[int] = None) -> str",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "length": {
          "default": "None",
          "annotation": "typing.Optional[int]",
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": "<class 'str'>",
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Generate and return a cryptographically secure short random string of `length`.",
      "source_code": "    def random(self, length: Optional[int] = None) -> str:\n        \"\"\"Generate and return a cryptographically secure short random string of `length`.\"\"\"\n        if length is None:\n            length = self._length\n\n        return \"\".join(secrets.choice(self._alphabet) for _ in range(length))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.ShortUUID.set_alphabet",
      "module": "shortuuid",
      "signature": "(self, alphabet: str) -> None",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "alphabet": {
          "default": null,
          "annotation": "<class 'str'>",
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": "None",
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Set the alphabet to be used for new UUIDs.",
      "source_code": "    def set_alphabet(self, alphabet: str) -> None:\n        \"\"\"Set the alphabet to be used for new UUIDs.\"\"\"\n        # Turn the alphabet into a set and sort it to prevent duplicates\n        # and ensure reproducibility.\n        new_alphabet = list(sorted(set(alphabet)))\n        if len(new_alphabet) > 1:\n            self._alphabet = new_alphabet\n            self._alpha_len = len(self._alphabet)\n        else:\n            raise ValueError(\"Alphabet with more than \" \"one unique symbols required.\")\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.ShortUUID.uuid",
      "module": "shortuuid",
      "signature": "(self, name: Optional[str] = None, pad_length: Optional[int] = None) -> str",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "name": {
          "default": "None",
          "annotation": "typing.Optional[str]",
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "pad_length": {
          "default": "None",
          "annotation": "typing.Optional[int]",
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": "<class 'str'>",
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Generate and return a UUID.\n\nIf the name parameter is provided, set the namespace to the provided\nname and generate a UUID.",
      "source_code": "    def uuid(self, name: Optional[str] = None, pad_length: Optional[int] = None) -> str:\n        \"\"\"\n        Generate and return a UUID.\n\n        If the name parameter is provided, set the namespace to the provided\n        name and generate a UUID.\n        \"\"\"\n        if pad_length is None:\n            pad_length = self._length\n\n        # If no name is given, generate a random UUID.\n        if name is None:\n            u = _uu.uuid4()\n        elif name.lower().startswith((\"http://\", \"https://\")):\n            u = _uu.uuid5(_uu.NAMESPACE_URL, name)\n        else:\n            u = _uu.uuid5(_uu.NAMESPACE_DNS, name)\n        return self.encode(u, pad_length)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.main.ShortUUID.decode",
      "module": "shortuuid.main",
      "signature": "(self, string: str, legacy: bool = False) -> uuid.UUID",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "string": {
          "default": null,
          "annotation": "<class 'str'>",
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "legacy": {
          "default": "False",
          "annotation": "<class 'bool'>",
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": "<class 'uuid.UUID'>",
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Decode a string according to the current alphabet into a UUID.\n\nRaises ValueError when encountering illegal characters or a too-long string.\n\nIf string too short, fills leftmost (MSB) bits with 0.\n\nPass `legacy=True` if your UUID was encoded with a ShortUUID version prior to\n1.0.0.",
      "source_code": "    def decode(self, string: str, legacy: bool = False) -> _uu.UUID:\n        \"\"\"\n        Decode a string according to the current alphabet into a UUID.\n\n        Raises ValueError when encountering illegal characters or a too-long string.\n\n        If string too short, fills leftmost (MSB) bits with 0.\n\n        Pass `legacy=True` if your UUID was encoded with a ShortUUID version prior to\n        1.0.0.\n        \"\"\"\n        if not isinstance(string, str):\n            raise ValueError(\"Input `string` must be a str.\")\n        if legacy:\n            string = string[::-1]\n        return _uu.UUID(int=string_to_int(string, self._alphabet))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.main.ShortUUID.encode",
      "module": "shortuuid.main",
      "signature": "(self, uuid: uuid.UUID, pad_length: Optional[int] = None) -> str",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "uuid": {
          "default": null,
          "annotation": "<class 'uuid.UUID'>",
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "pad_length": {
          "default": "None",
          "annotation": "typing.Optional[int]",
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": "<class 'str'>",
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Encode a UUID into a string (LSB first) according to the alphabet.\n\nIf leftmost (MSB) bits are 0, the string might be shorter.",
      "source_code": "    def encode(self, uuid: _uu.UUID, pad_length: Optional[int] = None) -> str:\n        \"\"\"\n        Encode a UUID into a string (LSB first) according to the alphabet.\n\n        If leftmost (MSB) bits are 0, the string might be shorter.\n        \"\"\"\n        if not isinstance(uuid, _uu.UUID):\n            raise ValueError(\"Input `uuid` must be a UUID object.\")\n        if pad_length is None:\n            pad_length = self._length\n        return int_to_string(uuid.int, self._alphabet, padding=pad_length)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.main.ShortUUID.encoded_length",
      "module": "shortuuid.main",
      "signature": "(self, num_bytes: int = 16) -> int",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "num_bytes": {
          "default": "16",
          "annotation": "<class 'int'>",
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": "<class 'int'>",
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Return the string length of the shortened UUID.",
      "source_code": "    def encoded_length(self, num_bytes: int = 16) -> int:\n        \"\"\"Return the string length of the shortened UUID.\"\"\"\n        factor = math.log(256) / math.log(self._alpha_len)\n        return int(math.ceil(factor * num_bytes))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.main.ShortUUID.get_alphabet",
      "module": "shortuuid.main",
      "signature": "(self) -> str",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": "<class 'str'>",
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Return the current alphabet used for new UUIDs.",
      "source_code": "    def get_alphabet(self) -> str:\n        \"\"\"Return the current alphabet used for new UUIDs.\"\"\"\n        return \"\".join(self._alphabet)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.main.ShortUUID.random",
      "module": "shortuuid.main",
      "signature": "(self, length: Optional[int] = None) -> str",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "length": {
          "default": "None",
          "annotation": "typing.Optional[int]",
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": "<class 'str'>",
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Generate and return a cryptographically secure short random string of `length`.",
      "source_code": "    def random(self, length: Optional[int] = None) -> str:\n        \"\"\"Generate and return a cryptographically secure short random string of `length`.\"\"\"\n        if length is None:\n            length = self._length\n\n        return \"\".join(secrets.choice(self._alphabet) for _ in range(length))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.main.ShortUUID.set_alphabet",
      "module": "shortuuid.main",
      "signature": "(self, alphabet: str) -> None",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "alphabet": {
          "default": null,
          "annotation": "<class 'str'>",
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": "None",
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Set the alphabet to be used for new UUIDs.",
      "source_code": "    def set_alphabet(self, alphabet: str) -> None:\n        \"\"\"Set the alphabet to be used for new UUIDs.\"\"\"\n        # Turn the alphabet into a set and sort it to prevent duplicates\n        # and ensure reproducibility.\n        new_alphabet = list(sorted(set(alphabet)))\n        if len(new_alphabet) > 1:\n            self._alphabet = new_alphabet\n            self._alpha_len = len(self._alphabet)\n        else:\n            raise ValueError(\"Alphabet with more than \" \"one unique symbols required.\")\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.main.ShortUUID.uuid",
      "module": "shortuuid.main",
      "signature": "(self, name: Optional[str] = None, pad_length: Optional[int] = None) -> str",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "name": {
          "default": "None",
          "annotation": "typing.Optional[str]",
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "pad_length": {
          "default": "None",
          "annotation": "typing.Optional[int]",
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": "<class 'str'>",
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Generate and return a UUID.\n\nIf the name parameter is provided, set the namespace to the provided\nname and generate a UUID.",
      "source_code": "    def uuid(self, name: Optional[str] = None, pad_length: Optional[int] = None) -> str:\n        \"\"\"\n        Generate and return a UUID.\n\n        If the name parameter is provided, set the namespace to the provided\n        name and generate a UUID.\n        \"\"\"\n        if pad_length is None:\n            pad_length = self._length\n\n        # If no name is given, generate a random UUID.\n        if name is None:\n            u = _uu.uuid4()\n        elif name.lower().startswith((\"http://\", \"https://\")):\n            u = _uu.uuid5(_uu.NAMESPACE_URL, name)\n        else:\n            u = _uu.uuid5(_uu.NAMESPACE_DNS, name)\n        return self.encode(u, pad_length)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ClassShortUUIDTest.addCleanup",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, function, /, *args, **kwargs)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_ONLY",
          "description": null
        },
        "function": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_ONLY",
          "description": null
        },
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Add a function, with arguments, to be called when the test is\ncompleted. Functions added are called on a LIFO basis and are\ncalled after tearDown on test failure or success.\n\nCleanup items are called even if setUp fails (unlike tearDown).",
      "source_code": "    def addCleanup(self, function, /, *args, **kwargs):\n        \"\"\"Add a function, with arguments, to be called when the test is\n        completed. Functions added are called on a LIFO basis and are\n        called after tearDown on test failure or success.\n\n        Cleanup items are called even if setUp fails (unlike tearDown).\"\"\"\n        self._cleanups.append((function, args, kwargs))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ClassShortUUIDTest.addTypeEqualityFunc",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, typeobj, function)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "typeobj": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "function": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Add a type specific assertEqual style function to compare a type.\n\nThis method is for use by TestCase subclasses that need to register\ntheir own type equality functions to provide nicer error messages.\n\nArgs:\n    typeobj: The data type to call this function on when both values\n            are of the same type in assertEqual().\n    function: The callable taking two arguments and an optional\n            msg= argument that raises self.failureException with a\n            useful error message when the two arguments are not equal.",
      "source_code": "    def addTypeEqualityFunc(self, typeobj, function):\n        \"\"\"Add a type specific assertEqual style function to compare a type.\n\n        This method is for use by TestCase subclasses that need to register\n        their own type equality functions to provide nicer error messages.\n\n        Args:\n            typeobj: The data type to call this function on when both values\n                    are of the same type in assertEqual().\n            function: The callable taking two arguments and an optional\n                    msg= argument that raises self.failureException with a\n                    useful error message when the two arguments are not equal.\n        \"\"\"\n        self._type_equality_funcs[typeobj] = function\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ClassShortUUIDTest.assertAlmostEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, first, second, places=None, msg=None, delta=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "first": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "second": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "places": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "delta": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Fail if the two objects are unequal as determined by their\ndifference rounded to the given number of decimal places\n(default 7) and comparing to zero, or by comparing that the\ndifference between the two objects is more than the given\ndelta.\n\nNote that decimal places (from zero) are usually not the same\nas significant digits (measured from the most significant digit).\n\nIf the two objects compare equal then they will automatically\ncompare almost equal.",
      "source_code": "    def assertAlmostEqual(self, first, second, places=None, msg=None,\n                          delta=None):\n        \"\"\"Fail if the two objects are unequal as determined by their\n           difference rounded to the given number of decimal places\n           (default 7) and comparing to zero, or by comparing that the\n           difference between the two objects is more than the given\n           delta.\n\n           Note that decimal places (from zero) are usually not the same\n           as significant digits (measured from the most significant digit).\n\n           If the two objects compare equal then they will automatically\n           compare almost equal.\n        \"\"\"\n        if first == second:\n            # shortcut\n            return\n        if delta is not None and places is not None:\n            raise TypeError(\"specify delta or places not both\")\n\n        diff = abs(first - second)\n        if delta is not None:\n            if diff <= delta:\n                return\n\n            standardMsg = '%s != %s within %s delta (%s difference)' % (\n                safe_repr(first),\n                safe_repr(second),\n                safe_repr(delta),\n                safe_repr(diff))\n        else:\n            if places is None:\n                places = 7\n\n            if round(diff, places) == 0:\n                return\n\n            standardMsg = '%s != %s within %r places (%s difference)' % (\n                safe_repr(first),\n                safe_repr(second),\n                places,\n                safe_repr(diff))\n        msg = self._formatMessage(msg, standardMsg)\n        raise self.failureException(msg)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ClassShortUUIDTest.assertAlmostEquals",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ClassShortUUIDTest.assertCountEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, first, second, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "first": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "second": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Asserts that two iterables have the same elements, the same number of\ntimes, without regard to order.\n\n    self.assertEqual(Counter(list(first)),\n                     Counter(list(second)))\n\n Example:\n    - [0, 1, 1] and [1, 0, 1] compare equal.\n    - [0, 0, 1] and [0, 1] compare unequal.",
      "source_code": "    def assertCountEqual(self, first, second, msg=None):\n        \"\"\"Asserts that two iterables have the same elements, the same number of\n        times, without regard to order.\n\n            self.assertEqual(Counter(list(first)),\n                             Counter(list(second)))\n\n         Example:\n            - [0, 1, 1] and [1, 0, 1] compare equal.\n            - [0, 0, 1] and [0, 1] compare unequal.\n\n        \"\"\"\n        first_seq, second_seq = list(first), list(second)\n        try:\n            first = collections.Counter(first_seq)\n            second = collections.Counter(second_seq)\n        except TypeError:\n            # Handle case with unhashable elements\n            differences = _count_diff_all_purpose(first_seq, second_seq)\n        else:\n            if first == second:\n                return\n            differences = _count_diff_hashable(first_seq, second_seq)\n\n        if differences:\n            standardMsg = 'Element counts were not equal:\\n'\n            lines = ['First has %d, Second has %d:  %r' % diff for diff in differences]\n            diffMsg = '\\n'.join(lines)\n            standardMsg = self._truncateMessage(standardMsg, diffMsg)\n            msg = self._formatMessage(msg, standardMsg)\n            self.fail(msg)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ClassShortUUIDTest.assertDictContainsSubset",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, subset, dictionary, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "subset": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "dictionary": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Checks whether dictionary is a superset of subset.",
      "source_code": "    def assertDictContainsSubset(self, subset, dictionary, msg=None):\n        \"\"\"Checks whether dictionary is a superset of subset.\"\"\"\n        warnings.warn('assertDictContainsSubset is deprecated',\n                      DeprecationWarning,\n                      stacklevel=2)\n        missing = []\n        mismatched = []\n        for key, value in subset.items():\n            if key not in dictionary:\n                missing.append(key)\n            elif value != dictionary[key]:\n                mismatched.append('%s, expected: %s, actual: %s' %\n                                  (safe_repr(key), safe_repr(value),\n                                   safe_repr(dictionary[key])))\n\n        if not (missing or mismatched):\n            return\n\n        standardMsg = ''\n        if missing:\n            standardMsg = 'Missing: %s' % ','.join(safe_repr(m) for m in\n                                                    missing)\n        if mismatched:\n            if standardMsg:\n                standardMsg += '; '\n            standardMsg += 'Mismatched values: %s' % ','.join(mismatched)\n\n        self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ClassShortUUIDTest.assertDictEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, d1, d2, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "d1": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "d2": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def assertDictEqual(self, d1, d2, msg=None):\n        self.assertIsInstance(d1, dict, 'First argument is not a dictionary')\n        self.assertIsInstance(d2, dict, 'Second argument is not a dictionary')\n\n        if d1 != d2:\n            standardMsg = '%s != %s' % _common_shorten_repr(d1, d2)\n            diff = ('\\n' + '\\n'.join(difflib.ndiff(\n                           pprint.pformat(d1).splitlines(),\n                           pprint.pformat(d2).splitlines())))\n            standardMsg = self._truncateMessage(standardMsg, diff)\n            self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ClassShortUUIDTest.assertEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, first, second, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "first": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "second": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Fail if the two objects are unequal as determined by the '=='\noperator.",
      "source_code": "    def assertEqual(self, first, second, msg=None):\n        \"\"\"Fail if the two objects are unequal as determined by the '=='\n           operator.\n        \"\"\"\n        assertion_func = self._getAssertEqualityFunc(first, second)\n        assertion_func(first, second, msg=msg)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ClassShortUUIDTest.assertEquals",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ClassShortUUIDTest.assertFalse",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, expr, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "expr": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Check that the expression is false.",
      "source_code": "    def assertFalse(self, expr, msg=None):\n        \"\"\"Check that the expression is false.\"\"\"\n        if expr:\n            msg = self._formatMessage(msg, \"%s is not false\" % safe_repr(expr))\n            raise self.failureException(msg)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ClassShortUUIDTest.assertGreater",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, a, b, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "a": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "b": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Just like self.assertTrue(a > b), but with a nicer default message.",
      "source_code": "    def assertGreater(self, a, b, msg=None):\n        \"\"\"Just like self.assertTrue(a > b), but with a nicer default message.\"\"\"\n        if not a > b:\n            standardMsg = '%s not greater than %s' % (safe_repr(a), safe_repr(b))\n            self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ClassShortUUIDTest.assertGreaterEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, a, b, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "a": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "b": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Just like self.assertTrue(a >= b), but with a nicer default message.",
      "source_code": "    def assertGreaterEqual(self, a, b, msg=None):\n        \"\"\"Just like self.assertTrue(a >= b), but with a nicer default message.\"\"\"\n        if not a >= b:\n            standardMsg = '%s not greater than or equal to %s' % (safe_repr(a), safe_repr(b))\n            self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ClassShortUUIDTest.assertIn",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, member, container, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "member": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "container": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Just like self.assertTrue(a in b), but with a nicer default message.",
      "source_code": "    def assertIn(self, member, container, msg=None):\n        \"\"\"Just like self.assertTrue(a in b), but with a nicer default message.\"\"\"\n        if member not in container:\n            standardMsg = '%s not found in %s' % (safe_repr(member),\n                                                  safe_repr(container))\n            self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ClassShortUUIDTest.assertIs",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, expr1, expr2, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "expr1": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "expr2": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Just like self.assertTrue(a is b), but with a nicer default message.",
      "source_code": "    def assertIs(self, expr1, expr2, msg=None):\n        \"\"\"Just like self.assertTrue(a is b), but with a nicer default message.\"\"\"\n        if expr1 is not expr2:\n            standardMsg = '%s is not %s' % (safe_repr(expr1),\n                                             safe_repr(expr2))\n            self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ClassShortUUIDTest.assertIsInstance",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, obj, cls, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "obj": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "cls": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Same as self.assertTrue(isinstance(obj, cls)), with a nicer\ndefault message.",
      "source_code": "    def assertIsInstance(self, obj, cls, msg=None):\n        \"\"\"Same as self.assertTrue(isinstance(obj, cls)), with a nicer\n        default message.\"\"\"\n        if not isinstance(obj, cls):\n            standardMsg = '%s is not an instance of %r' % (safe_repr(obj), cls)\n            self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ClassShortUUIDTest.assertIsNone",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, obj, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "obj": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Same as self.assertTrue(obj is None), with a nicer default message.",
      "source_code": "    def assertIsNone(self, obj, msg=None):\n        \"\"\"Same as self.assertTrue(obj is None), with a nicer default message.\"\"\"\n        if obj is not None:\n            standardMsg = '%s is not None' % (safe_repr(obj),)\n            self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ClassShortUUIDTest.assertIsNot",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, expr1, expr2, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "expr1": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "expr2": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Just like self.assertTrue(a is not b), but with a nicer default message.",
      "source_code": "    def assertIsNot(self, expr1, expr2, msg=None):\n        \"\"\"Just like self.assertTrue(a is not b), but with a nicer default message.\"\"\"\n        if expr1 is expr2:\n            standardMsg = 'unexpectedly identical: %s' % (safe_repr(expr1),)\n            self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ClassShortUUIDTest.assertIsNotNone",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, obj, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "obj": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Included for symmetry with assertIsNone.",
      "source_code": "    def assertIsNotNone(self, obj, msg=None):\n        \"\"\"Included for symmetry with assertIsNone.\"\"\"\n        if obj is None:\n            standardMsg = 'unexpectedly None'\n            self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ClassShortUUIDTest.assertLess",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, a, b, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "a": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "b": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Just like self.assertTrue(a < b), but with a nicer default message.",
      "source_code": "    def assertLess(self, a, b, msg=None):\n        \"\"\"Just like self.assertTrue(a < b), but with a nicer default message.\"\"\"\n        if not a < b:\n            standardMsg = '%s not less than %s' % (safe_repr(a), safe_repr(b))\n            self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ClassShortUUIDTest.assertLessEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, a, b, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "a": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "b": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Just like self.assertTrue(a <= b), but with a nicer default message.",
      "source_code": "    def assertLessEqual(self, a, b, msg=None):\n        \"\"\"Just like self.assertTrue(a <= b), but with a nicer default message.\"\"\"\n        if not a <= b:\n            standardMsg = '%s not less than or equal to %s' % (safe_repr(a), safe_repr(b))\n            self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ClassShortUUIDTest.assertListEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, list1, list2, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "list1": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "list2": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "A list-specific equality assertion.\n\nArgs:\n    list1: The first list to compare.\n    list2: The second list to compare.\n    msg: Optional message to use on failure instead of a list of\n            differences.",
      "source_code": "    def assertListEqual(self, list1, list2, msg=None):\n        \"\"\"A list-specific equality assertion.\n\n        Args:\n            list1: The first list to compare.\n            list2: The second list to compare.\n            msg: Optional message to use on failure instead of a list of\n                    differences.\n\n        \"\"\"\n        self.assertSequenceEqual(list1, list2, msg, seq_type=list)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ClassShortUUIDTest.assertLogs",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, logger=None, level=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "logger": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "level": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Fail unless a log message of level *level* or higher is emitted\non *logger_name* or its children.  If omitted, *level* defaults to\nINFO and *logger* defaults to the root logger.\n\nThis method must be used as a context manager, and will yield\na recording object with two attributes: `output` and `records`.\nAt the end of the context manager, the `output` attribute will\nbe a list of the matching formatted log messages and the\n`records` attribute will be a list of the corresponding LogRecord\nobjects.\n\nExample::\n\n    with self.assertLogs('foo', level='INFO') as cm:\n        logging.getLogger('foo').info('first message')\n        logging.getLogger('foo.bar').error('second message')\n    self.assertEqual(cm.output, ['INFO:foo:first message',\n                                 'ERROR:foo.bar:second message'])",
      "source_code": "    def assertLogs(self, logger=None, level=None):\n        \"\"\"Fail unless a log message of level *level* or higher is emitted\n        on *logger_name* or its children.  If omitted, *level* defaults to\n        INFO and *logger* defaults to the root logger.\n\n        This method must be used as a context manager, and will yield\n        a recording object with two attributes: `output` and `records`.\n        At the end of the context manager, the `output` attribute will\n        be a list of the matching formatted log messages and the\n        `records` attribute will be a list of the corresponding LogRecord\n        objects.\n\n        Example::\n\n            with self.assertLogs('foo', level='INFO') as cm:\n                logging.getLogger('foo').info('first message')\n                logging.getLogger('foo.bar').error('second message')\n            self.assertEqual(cm.output, ['INFO:foo:first message',\n                                         'ERROR:foo.bar:second message'])\n        \"\"\"\n        # Lazy import to avoid importing logging if it is not needed.\n        from ._log import _AssertLogsContext\n        return _AssertLogsContext(self, logger, level, no_logs=False)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ClassShortUUIDTest.assertMultiLineEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, first, second, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "first": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "second": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Assert that two multi-line strings are equal.",
      "source_code": "    def assertMultiLineEqual(self, first, second, msg=None):\n        \"\"\"Assert that two multi-line strings are equal.\"\"\"\n        self.assertIsInstance(first, str, 'First argument is not a string')\n        self.assertIsInstance(second, str, 'Second argument is not a string')\n\n        if first != second:\n            # don't use difflib if the strings are too long\n            if (len(first) > self._diffThreshold or\n                len(second) > self._diffThreshold):\n                self._baseAssertEqual(first, second, msg)\n            firstlines = first.splitlines(keepends=True)\n            secondlines = second.splitlines(keepends=True)\n            if len(firstlines) == 1 and first.strip('\\r\\n') == first:\n                firstlines = [first + '\\n']\n                secondlines = [second + '\\n']\n            standardMsg = '%s != %s' % _common_shorten_repr(first, second)\n            diff = '\\n' + ''.join(difflib.ndiff(firstlines, secondlines))\n            standardMsg = self._truncateMessage(standardMsg, diff)\n            self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ClassShortUUIDTest.assertNoLogs",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, logger=None, level=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "logger": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "level": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Fail unless no log messages of level *level* or higher are emitted\non *logger_name* or its children.\n\nThis method must be used as a context manager.",
      "source_code": "    def assertNoLogs(self, logger=None, level=None):\n        \"\"\" Fail unless no log messages of level *level* or higher are emitted\n        on *logger_name* or its children.\n\n        This method must be used as a context manager.\n        \"\"\"\n        from ._log import _AssertLogsContext\n        return _AssertLogsContext(self, logger, level, no_logs=True)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ClassShortUUIDTest.assertNotAlmostEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, first, second, places=None, msg=None, delta=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "first": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "second": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "places": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "delta": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Fail if the two objects are equal as determined by their\ndifference rounded to the given number of decimal places\n(default 7) and comparing to zero, or by comparing that the\ndifference between the two objects is less than the given delta.\n\nNote that decimal places (from zero) are usually not the same\nas significant digits (measured from the most significant digit).\n\nObjects that are equal automatically fail.",
      "source_code": "    def assertNotAlmostEqual(self, first, second, places=None, msg=None,\n                             delta=None):\n        \"\"\"Fail if the two objects are equal as determined by their\n           difference rounded to the given number of decimal places\n           (default 7) and comparing to zero, or by comparing that the\n           difference between the two objects is less than the given delta.\n\n           Note that decimal places (from zero) are usually not the same\n           as significant digits (measured from the most significant digit).\n\n           Objects that are equal automatically fail.\n        \"\"\"\n        if delta is not None and places is not None:\n            raise TypeError(\"specify delta or places not both\")\n        diff = abs(first - second)\n        if delta is not None:\n            if not (first == second) and diff > delta:\n                return\n            standardMsg = '%s == %s within %s delta (%s difference)' % (\n                safe_repr(first),\n                safe_repr(second),\n                safe_repr(delta),\n                safe_repr(diff))\n        else:\n            if places is None:\n                places = 7\n            if not (first == second) and round(diff, places) != 0:\n                return\n            standardMsg = '%s == %s within %r places' % (safe_repr(first),\n                                                         safe_repr(second),\n                                                         places)\n\n        msg = self._formatMessage(msg, standardMsg)\n        raise self.failureException(msg)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ClassShortUUIDTest.assertNotAlmostEquals",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ClassShortUUIDTest.assertNotEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, first, second, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "first": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "second": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Fail if the two objects are equal as determined by the '!='\noperator.",
      "source_code": "    def assertNotEqual(self, first, second, msg=None):\n        \"\"\"Fail if the two objects are equal as determined by the '!='\n           operator.\n        \"\"\"\n        if not first != second:\n            msg = self._formatMessage(msg, '%s == %s' % (safe_repr(first),\n                                                          safe_repr(second)))\n            raise self.failureException(msg)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ClassShortUUIDTest.assertNotEquals",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ClassShortUUIDTest.assertNotIn",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, member, container, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "member": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "container": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Just like self.assertTrue(a not in b), but with a nicer default message.",
      "source_code": "    def assertNotIn(self, member, container, msg=None):\n        \"\"\"Just like self.assertTrue(a not in b), but with a nicer default message.\"\"\"\n        if member in container:\n            standardMsg = '%s unexpectedly found in %s' % (safe_repr(member),\n                                                        safe_repr(container))\n            self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ClassShortUUIDTest.assertNotIsInstance",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, obj, cls, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "obj": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "cls": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Included for symmetry with assertIsInstance.",
      "source_code": "    def assertNotIsInstance(self, obj, cls, msg=None):\n        \"\"\"Included for symmetry with assertIsInstance.\"\"\"\n        if isinstance(obj, cls):\n            standardMsg = '%s is an instance of %r' % (safe_repr(obj), cls)\n            self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ClassShortUUIDTest.assertNotRegex",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, text, unexpected_regex, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "text": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "unexpected_regex": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Fail the test if the text matches the regular expression.",
      "source_code": "    def assertNotRegex(self, text, unexpected_regex, msg=None):\n        \"\"\"Fail the test if the text matches the regular expression.\"\"\"\n        if isinstance(unexpected_regex, (str, bytes)):\n            unexpected_regex = re.compile(unexpected_regex)\n        match = unexpected_regex.search(text)\n        if match:\n            standardMsg = 'Regex matched: %r matches %r in %r' % (\n                text[match.start() : match.end()],\n                unexpected_regex.pattern,\n                text)\n            # _formatMessage ensures the longMessage option is respected\n            msg = self._formatMessage(msg, standardMsg)\n            raise self.failureException(msg)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ClassShortUUIDTest.assertNotRegexpMatches",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ClassShortUUIDTest.assertRaises",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, expected_exception, *args, **kwargs)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "expected_exception": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Fail unless an exception of class expected_exception is raised\nby the callable when invoked with specified positional and\nkeyword arguments. If a different type of exception is\nraised, it will not be caught, and the test case will be\ndeemed to have suffered an error, exactly as for an\nunexpected exception.\n\nIf called with the callable and arguments omitted, will return a\ncontext object used like this::\n\n     with self.assertRaises(SomeException):\n         do_something()\n\nAn optional keyword argument 'msg' can be provided when assertRaises\nis used as a context object.\n\nThe context manager keeps a reference to the exception as\nthe 'exception' attribute. This allows you to inspect the\nexception after the assertion::\n\n    with self.assertRaises(SomeException) as cm:\n        do_something()\n    the_exception = cm.exception\n    self.assertEqual(the_exception.error_code, 3)",
      "source_code": "    def assertRaises(self, expected_exception, *args, **kwargs):\n        \"\"\"Fail unless an exception of class expected_exception is raised\n           by the callable when invoked with specified positional and\n           keyword arguments. If a different type of exception is\n           raised, it will not be caught, and the test case will be\n           deemed to have suffered an error, exactly as for an\n           unexpected exception.\n\n           If called with the callable and arguments omitted, will return a\n           context object used like this::\n\n                with self.assertRaises(SomeException):\n                    do_something()\n\n           An optional keyword argument 'msg' can be provided when assertRaises\n           is used as a context object.\n\n           The context manager keeps a reference to the exception as\n           the 'exception' attribute. This allows you to inspect the\n           exception after the assertion::\n\n               with self.assertRaises(SomeException) as cm:\n                   do_something()\n               the_exception = cm.exception\n               self.assertEqual(the_exception.error_code, 3)\n        \"\"\"\n        context = _AssertRaisesContext(expected_exception, self)\n        try:\n            return context.handle('assertRaises', args, kwargs)\n        finally:\n            # bpo-23890: manually break a reference cycle\n            context = None\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ClassShortUUIDTest.assertRaisesRegex",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, expected_exception, expected_regex, *args, **kwargs)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "expected_exception": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "expected_regex": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Asserts that the message in a raised exception matches a regex.\n\nArgs:\n    expected_exception: Exception class expected to be raised.\n    expected_regex: Regex (re.Pattern object or string) expected\n            to be found in error message.\n    args: Function to be called and extra positional args.\n    kwargs: Extra kwargs.\n    msg: Optional message used in case of failure. Can only be used\n            when assertRaisesRegex is used as a context manager.",
      "source_code": "    def assertRaisesRegex(self, expected_exception, expected_regex,\n                          *args, **kwargs):\n        \"\"\"Asserts that the message in a raised exception matches a regex.\n\n        Args:\n            expected_exception: Exception class expected to be raised.\n            expected_regex: Regex (re.Pattern object or string) expected\n                    to be found in error message.\n            args: Function to be called and extra positional args.\n            kwargs: Extra kwargs.\n            msg: Optional message used in case of failure. Can only be used\n                    when assertRaisesRegex is used as a context manager.\n        \"\"\"\n        context = _AssertRaisesContext(expected_exception, self, expected_regex)\n        return context.handle('assertRaisesRegex', args, kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ClassShortUUIDTest.assertRaisesRegexp",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ClassShortUUIDTest.assertRegex",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, text, expected_regex, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "text": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "expected_regex": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Fail the test unless the text matches the regular expression.",
      "source_code": "    def assertRegex(self, text, expected_regex, msg=None):\n        \"\"\"Fail the test unless the text matches the regular expression.\"\"\"\n        if isinstance(expected_regex, (str, bytes)):\n            assert expected_regex, \"expected_regex must not be empty.\"\n            expected_regex = re.compile(expected_regex)\n        if not expected_regex.search(text):\n            standardMsg = \"Regex didn't match: %r not found in %r\" % (\n                expected_regex.pattern, text)\n            # _formatMessage ensures the longMessage option is respected\n            msg = self._formatMessage(msg, standardMsg)\n            raise self.failureException(msg)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ClassShortUUIDTest.assertRegexpMatches",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ClassShortUUIDTest.assertSequenceEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, seq1, seq2, msg=None, seq_type=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "seq1": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "seq2": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "seq_type": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "An equality assertion for ordered sequences (like lists and tuples).\n\nFor the purposes of this function, a valid ordered sequence type is one\nwhich can be indexed, has a length, and has an equality operator.\n\nArgs:\n    seq1: The first sequence to compare.\n    seq2: The second sequence to compare.\n    seq_type: The expected datatype of the sequences, or None if no\n            datatype should be enforced.\n    msg: Optional message to use on failure instead of a list of\n            differences.",
      "source_code": "    def assertSequenceEqual(self, seq1, seq2, msg=None, seq_type=None):\n        \"\"\"An equality assertion for ordered sequences (like lists and tuples).\n\n        For the purposes of this function, a valid ordered sequence type is one\n        which can be indexed, has a length, and has an equality operator.\n\n        Args:\n            seq1: The first sequence to compare.\n            seq2: The second sequence to compare.\n            seq_type: The expected datatype of the sequences, or None if no\n                    datatype should be enforced.\n            msg: Optional message to use on failure instead of a list of\n                    differences.\n        \"\"\"\n        if seq_type is not None:\n            seq_type_name = seq_type.__name__\n            if not isinstance(seq1, seq_type):\n                raise self.failureException('First sequence is not a %s: %s'\n                                        % (seq_type_name, safe_repr(seq1)))\n            if not isinstance(seq2, seq_type):\n                raise self.failureException('Second sequence is not a %s: %s'\n                                        % (seq_type_name, safe_repr(seq2)))\n        else:\n            seq_type_name = \"sequence\"\n\n        differing = None\n        try:\n            len1 = len(seq1)\n        except (TypeError, NotImplementedError):\n            differing = 'First %s has no length.    Non-sequence?' % (\n                    seq_type_name)\n\n        if differing is None:\n            try:\n                len2 = len(seq2)\n            except (TypeError, NotImplementedError):\n                differing = 'Second %s has no length.    Non-sequence?' % (\n                        seq_type_name)\n\n        if differing is None:\n            if seq1 == seq2:\n                return\n\n            differing = '%ss differ: %s != %s\\n' % (\n                    (seq_type_name.capitalize(),) +\n                    _common_shorten_repr(seq1, seq2))\n\n            for i in range(min(len1, len2)):\n                try:\n                    item1 = seq1[i]\n                except (TypeError, IndexError, NotImplementedError):\n                    differing += ('\\nUnable to index element %d of first %s\\n' %\n                                 (i, seq_type_name))\n                    break\n\n                try:\n                    item2 = seq2[i]\n                except (TypeError, IndexError, NotImplementedError):\n                    differing += ('\\nUnable to index element %d of second %s\\n' %\n                                 (i, seq_type_name))\n                    break\n\n                if item1 != item2:\n                    differing += ('\\nFirst differing element %d:\\n%s\\n%s\\n' %\n                                 ((i,) + _common_shorten_repr(item1, item2)))\n                    break\n            else:\n                if (len1 == len2 and seq_type is None and\n                    type(seq1) != type(seq2)):\n                    # The sequences are the same, but have differing types.\n                    return\n\n            if len1 > len2:\n                differing += ('\\nFirst %s contains %d additional '\n                             'elements.\\n' % (seq_type_name, len1 - len2))\n                try:\n                    differing += ('First extra element %d:\\n%s\\n' %\n                                  (len2, safe_repr(seq1[len2])))\n                except (TypeError, IndexError, NotImplementedError):\n                    differing += ('Unable to index element %d '\n                                  'of first %s\\n' % (len2, seq_type_name))\n            elif len1 < len2:\n                differing += ('\\nSecond %s contains %d additional '\n                             'elements.\\n' % (seq_type_name, len2 - len1))\n                try:\n                    differing += ('First extra element %d:\\n%s\\n' %\n                                  (len1, safe_repr(seq2[len1])))\n                except (TypeError, IndexError, NotImplementedError):\n                    differing += ('Unable to index element %d '\n                                  'of second %s\\n' % (len1, seq_type_name))\n        standardMsg = differing\n        diffMsg = '\\n' + '\\n'.join(\n            difflib.ndiff(pprint.pformat(seq1).splitlines(),\n                          pprint.pformat(seq2).splitlines()))\n\n        standardMsg = self._truncateMessage(standardMsg, diffMsg)\n        msg = self._formatMessage(msg, standardMsg)\n        self.fail(msg)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ClassShortUUIDTest.assertSetEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, set1, set2, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "set1": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "set2": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "A set-specific equality assertion.\n\nArgs:\n    set1: The first set to compare.\n    set2: The second set to compare.\n    msg: Optional message to use on failure instead of a list of\n            differences.\n\nassertSetEqual uses ducktyping to support different types of sets, and\nis optimized for sets specifically (parameters must support a\ndifference method).",
      "source_code": "    def assertSetEqual(self, set1, set2, msg=None):\n        \"\"\"A set-specific equality assertion.\n\n        Args:\n            set1: The first set to compare.\n            set2: The second set to compare.\n            msg: Optional message to use on failure instead of a list of\n                    differences.\n\n        assertSetEqual uses ducktyping to support different types of sets, and\n        is optimized for sets specifically (parameters must support a\n        difference method).\n        \"\"\"\n        try:\n            difference1 = set1.difference(set2)\n        except TypeError as e:\n            self.fail('invalid type when attempting set difference: %s' % e)\n        except AttributeError as e:\n            self.fail('first argument does not support set difference: %s' % e)\n\n        try:\n            difference2 = set2.difference(set1)\n        except TypeError as e:\n            self.fail('invalid type when attempting set difference: %s' % e)\n        except AttributeError as e:\n            self.fail('second argument does not support set difference: %s' % e)\n\n        if not (difference1 or difference2):\n            return\n\n        lines = []\n        if difference1:\n            lines.append('Items in the first set but not the second:')\n            for item in difference1:\n                lines.append(repr(item))\n        if difference2:\n            lines.append('Items in the second set but not the first:')\n            for item in difference2:\n                lines.append(repr(item))\n\n        standardMsg = '\\n'.join(lines)\n        self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ClassShortUUIDTest.assertTrue",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, expr, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "expr": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Check that the expression is true.",
      "source_code": "    def assertTrue(self, expr, msg=None):\n        \"\"\"Check that the expression is true.\"\"\"\n        if not expr:\n            msg = self._formatMessage(msg, \"%s is not true\" % safe_repr(expr))\n            raise self.failureException(msg)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ClassShortUUIDTest.assertTupleEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, tuple1, tuple2, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "tuple1": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "tuple2": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "A tuple-specific equality assertion.\n\nArgs:\n    tuple1: The first tuple to compare.\n    tuple2: The second tuple to compare.\n    msg: Optional message to use on failure instead of a list of\n            differences.",
      "source_code": "    def assertTupleEqual(self, tuple1, tuple2, msg=None):\n        \"\"\"A tuple-specific equality assertion.\n\n        Args:\n            tuple1: The first tuple to compare.\n            tuple2: The second tuple to compare.\n            msg: Optional message to use on failure instead of a list of\n                    differences.\n        \"\"\"\n        self.assertSequenceEqual(tuple1, tuple2, msg, seq_type=tuple)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ClassShortUUIDTest.assertWarns",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, expected_warning, *args, **kwargs)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "expected_warning": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Fail unless a warning of class warnClass is triggered\nby the callable when invoked with specified positional and\nkeyword arguments.  If a different type of warning is\ntriggered, it will not be handled: depending on the other\nwarning filtering rules in effect, it might be silenced, printed\nout, or raised as an exception.\n\nIf called with the callable and arguments omitted, will return a\ncontext object used like this::\n\n     with self.assertWarns(SomeWarning):\n         do_something()\n\nAn optional keyword argument 'msg' can be provided when assertWarns\nis used as a context object.\n\nThe context manager keeps a reference to the first matching\nwarning as the 'warning' attribute; similarly, the 'filename'\nand 'lineno' attributes give you information about the line\nof Python code from which the warning was triggered.\nThis allows you to inspect the warning after the assertion::\n\n    with self.assertWarns(SomeWarning) as cm:\n        do_something()\n    the_warning = cm.warning\n    self.assertEqual(the_warning.some_attribute, 147)",
      "source_code": "    def assertWarns(self, expected_warning, *args, **kwargs):\n        \"\"\"Fail unless a warning of class warnClass is triggered\n           by the callable when invoked with specified positional and\n           keyword arguments.  If a different type of warning is\n           triggered, it will not be handled: depending on the other\n           warning filtering rules in effect, it might be silenced, printed\n           out, or raised as an exception.\n\n           If called with the callable and arguments omitted, will return a\n           context object used like this::\n\n                with self.assertWarns(SomeWarning):\n                    do_something()\n\n           An optional keyword argument 'msg' can be provided when assertWarns\n           is used as a context object.\n\n           The context manager keeps a reference to the first matching\n           warning as the 'warning' attribute; similarly, the 'filename'\n           and 'lineno' attributes give you information about the line\n           of Python code from which the warning was triggered.\n           This allows you to inspect the warning after the assertion::\n\n               with self.assertWarns(SomeWarning) as cm:\n                   do_something()\n               the_warning = cm.warning\n               self.assertEqual(the_warning.some_attribute, 147)\n        \"\"\"\n        context = _AssertWarnsContext(expected_warning, self)\n        return context.handle('assertWarns', args, kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ClassShortUUIDTest.assertWarnsRegex",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, expected_warning, expected_regex, *args, **kwargs)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "expected_warning": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "expected_regex": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Asserts that the message in a triggered warning matches a regexp.\nBasic functioning is similar to assertWarns() with the addition\nthat only warnings whose messages also match the regular expression\nare considered successful matches.\n\nArgs:\n    expected_warning: Warning class expected to be triggered.\n    expected_regex: Regex (re.Pattern object or string) expected\n            to be found in error message.\n    args: Function to be called and extra positional args.\n    kwargs: Extra kwargs.\n    msg: Optional message used in case of failure. Can only be used\n            when assertWarnsRegex is used as a context manager.",
      "source_code": "    def assertWarnsRegex(self, expected_warning, expected_regex,\n                         *args, **kwargs):\n        \"\"\"Asserts that the message in a triggered warning matches a regexp.\n        Basic functioning is similar to assertWarns() with the addition\n        that only warnings whose messages also match the regular expression\n        are considered successful matches.\n\n        Args:\n            expected_warning: Warning class expected to be triggered.\n            expected_regex: Regex (re.Pattern object or string) expected\n                    to be found in error message.\n            args: Function to be called and extra positional args.\n            kwargs: Extra kwargs.\n            msg: Optional message used in case of failure. Can only be used\n                    when assertWarnsRegex is used as a context manager.\n        \"\"\"\n        context = _AssertWarnsContext(expected_warning, self, expected_regex)\n        return context.handle('assertWarnsRegex', args, kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ClassShortUUIDTest.assert_",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ClassShortUUIDTest.countTestCases",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def countTestCases(self):\n        return 1\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ClassShortUUIDTest.debug",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Run the test without collecting errors in a TestResult",
      "source_code": "    def debug(self):\n        \"\"\"Run the test without collecting errors in a TestResult\"\"\"\n        testMethod = getattr(self, self._testMethodName)\n        if (getattr(self.__class__, \"__unittest_skip__\", False) or\n            getattr(testMethod, \"__unittest_skip__\", False)):\n            # If the class or method was skipped.\n            skip_why = (getattr(self.__class__, '__unittest_skip_why__', '')\n                        or getattr(testMethod, '__unittest_skip_why__', ''))\n            raise SkipTest(skip_why)\n\n        self._callSetUp()\n        self._callTestMethod(testMethod)\n        self._callTearDown()\n        while self._cleanups:\n            function, args, kwargs = self._cleanups.pop()\n            self._callCleanup(function, *args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ClassShortUUIDTest.defaultTestResult",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def defaultTestResult(self):\n        return result.TestResult()\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ClassShortUUIDTest.doCleanups",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Execute all cleanup functions. Normally called for you after\ntearDown.",
      "source_code": "    def doCleanups(self):\n        \"\"\"Execute all cleanup functions. Normally called for you after\n        tearDown.\"\"\"\n        outcome = self._outcome or _Outcome()\n        while self._cleanups:\n            function, args, kwargs = self._cleanups.pop()\n            with outcome.testPartExecutor(self):\n                self._callCleanup(function, *args, **kwargs)\n\n        # return this for backwards compatibility\n        # even though we no longer use it internally\n        return outcome.success\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ClassShortUUIDTest.fail",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Fail immediately, with the given message.",
      "source_code": "    def fail(self, msg=None):\n        \"\"\"Fail immediately, with the given message.\"\"\"\n        raise self.failureException(msg)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ClassShortUUIDTest.failIf",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ClassShortUUIDTest.failIfAlmostEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ClassShortUUIDTest.failIfEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ClassShortUUIDTest.failUnless",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ClassShortUUIDTest.failUnlessAlmostEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ClassShortUUIDTest.failUnlessEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ClassShortUUIDTest.failUnlessRaises",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ClassShortUUIDTest.id",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def id(self):\n        return \"%s.%s\" % (strclass(self.__class__), self._testMethodName)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ClassShortUUIDTest.run",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, result=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "result": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def run(self, result=None):\n        if result is None:\n            result = self.defaultTestResult()\n            startTestRun = getattr(result, 'startTestRun', None)\n            stopTestRun = getattr(result, 'stopTestRun', None)\n            if startTestRun is not None:\n                startTestRun()\n        else:\n            stopTestRun = None\n\n        result.startTest(self)\n        try:\n            testMethod = getattr(self, self._testMethodName)\n            if (getattr(self.__class__, \"__unittest_skip__\", False) or\n                getattr(testMethod, \"__unittest_skip__\", False)):\n                # If the class or method was skipped.\n                skip_why = (getattr(self.__class__, '__unittest_skip_why__', '')\n                            or getattr(testMethod, '__unittest_skip_why__', ''))\n                self._addSkip(result, self, skip_why)\n                return result\n\n            expecting_failure = (\n                getattr(self, \"__unittest_expecting_failure__\", False) or\n                getattr(testMethod, \"__unittest_expecting_failure__\", False)\n            )\n            outcome = _Outcome(result)\n            try:\n                self._outcome = outcome\n\n                with outcome.testPartExecutor(self):\n                    self._callSetUp()\n                if outcome.success:\n                    outcome.expecting_failure = expecting_failure\n                    with outcome.testPartExecutor(self, isTest=True):\n                        self._callTestMethod(testMethod)\n                    outcome.expecting_failure = False\n                    with outcome.testPartExecutor(self):\n                        self._callTearDown()\n\n                self.doCleanups()\n                for test, reason in outcome.skipped:\n                    self._addSkip(result, test, reason)\n                self._feedErrorsToResult(result, outcome.errors)\n                if outcome.success:\n                    if expecting_failure:\n                        if outcome.expectedFailure:\n                            self._addExpectedFailure(result, outcome.expectedFailure)\n                        else:\n                            self._addUnexpectedSuccess(result)\n                    else:\n                        result.addSuccess(self)\n                return result\n            finally:\n                # explicitly break reference cycles:\n                # outcome.errors -> frame -> outcome -> outcome.errors\n                # outcome.expectedFailure -> frame -> outcome -> outcome.expectedFailure\n                outcome.errors.clear()\n                outcome.expectedFailure = None\n\n                # clear the outcome, no more needed\n                self._outcome = None\n\n        finally:\n            result.stopTest(self)\n            if stopTestRun is not None:\n                stopTestRun()\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ClassShortUUIDTest.setUp",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Hook method for setting up the test fixture before exercising it.",
      "source_code": "    def setUp(self):\n        \"Hook method for setting up the test fixture before exercising it.\"\n        pass\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ClassShortUUIDTest.shortDescription",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Returns a one-line description of the test, or None if no\ndescription has been provided.\n\nThe default implementation of this method returns the first line of\nthe specified test method's docstring.",
      "source_code": "    def shortDescription(self):\n        \"\"\"Returns a one-line description of the test, or None if no\n        description has been provided.\n\n        The default implementation of this method returns the first line of\n        the specified test method's docstring.\n        \"\"\"\n        doc = self._testMethodDoc\n        return doc.strip().split(\"\\n\")[0].strip() if doc else None\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ClassShortUUIDTest.skipTest",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, reason)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "reason": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Skip this test.",
      "source_code": "    def skipTest(self, reason):\n        \"\"\"Skip this test.\"\"\"\n        raise SkipTest(reason)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ClassShortUUIDTest.subTest",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, msg=<object object at 0x7e3e03b88ce0>, **params)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "<object object at 0x7e3e03b88ce0>",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "params": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [
        "contextlib.contextmanager"
      ],
      "examples": [],
      "docstring": "Return a context manager that will return the enclosed block\nof code in a subtest identified by the optional message and\nkeyword parameters.  A failure in the subtest marks the test\ncase as failed but resumes execution at the end of the enclosed\nblock, allowing further test code to be executed.",
      "source_code": "    @contextlib.contextmanager\n    def subTest(self, msg=_subtest_msg_sentinel, **params):\n        \"\"\"Return a context manager that will return the enclosed block\n        of code in a subtest identified by the optional message and\n        keyword parameters.  A failure in the subtest marks the test\n        case as failed but resumes execution at the end of the enclosed\n        block, allowing further test code to be executed.\n        \"\"\"\n        if self._outcome is None or not self._outcome.result_supports_subtests:\n            yield\n            return\n        parent = self._subtest\n        if parent is None:\n            params_map = _OrderedChainMap(params)\n        else:\n            params_map = parent.params.new_child(params)\n        self._subtest = _SubTest(self, msg, params_map)\n        try:\n            with self._outcome.testPartExecutor(self._subtest, isTest=True):\n                yield\n            if not self._outcome.success:\n                result = self._outcome.result\n                if result is not None and result.failfast:\n                    raise _ShouldStop\n            elif self._outcome.expectedFailure:\n                # If the test is expecting a failure, we really want to\n                # stop now and register the expected failure.\n                raise _ShouldStop\n        finally:\n            self._subtest = parent\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ClassShortUUIDTest.tearDown",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Hook method for deconstructing the test fixture after testing it.",
      "source_code": "    def tearDown(self):\n        \"Hook method for deconstructing the test fixture after testing it.\"\n        pass\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ClassShortUUIDTest.test_alphabet",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def test_alphabet(self):\n        alphabet = \"01\"\n        su1 = ShortUUID(alphabet)\n        su2 = ShortUUID()\n\n        self.assertEqual(alphabet, su1.get_alphabet())\n\n        su1.set_alphabet(\"01010101010101\")\n        self.assertEqual(alphabet, su1.get_alphabet())\n\n        self.assertEqual(set(su1.uuid()), set(\"01\"))\n        self.assertTrue(116 < len(su1.uuid()) < 140)\n        self.assertTrue(20 < len(su2.uuid()) < 24)\n\n        u = uuid4()\n        self.assertEqual(u, su1.decode(su1.encode(u)))\n\n        u = su1.uuid()\n        self.assertEqual(u, su1.encode(su1.decode(u)))\n\n        self.assertRaises(ValueError, su1.set_alphabet, \"1\")\n        self.assertRaises(ValueError, su1.set_alphabet, \"1111111\")\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ClassShortUUIDTest.test_decoding",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def test_decoding(self):\n        su = ShortUUID()\n        u = UUID(\"{3b1f8b40-222c-4a6e-b77e-779d5a94e21c}\")\n        self.assertEqual(su.decode(\"CXc85b4rqinB7s5J52TRYb\"), u)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ClassShortUUIDTest.test_encoded_length",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def test_encoded_length(self):\n        su1 = ShortUUID()\n        self.assertEqual(su1.encoded_length(), 22)\n\n        base64_alphabet = (\n            string.ascii_uppercase + string.ascii_lowercase + string.digits + \"+/\"\n        )\n\n        su2 = ShortUUID(base64_alphabet)\n        self.assertEqual(su2.encoded_length(), 22)\n\n        binary_alphabet = \"01\"\n        su3 = ShortUUID(binary_alphabet)\n        self.assertEqual(su3.encoded_length(), 128)\n\n        su4 = ShortUUID()\n        self.assertEqual(su4.encoded_length(num_bytes=8), 11)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ClassShortUUIDTest.test_encoding",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def test_encoding(self):\n        su = ShortUUID()\n        u = UUID(\"{3b1f8b40-222c-4a6e-b77e-779d5a94e21c}\")\n        self.assertEqual(su.encode(u), \"CXc85b4rqinB7s5J52TRYb\")\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ClassShortUUIDTest.test_generation",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def test_generation(self):\n        su = ShortUUID()\n        self.assertTrue(20 < len(su.uuid()) < 24)\n        self.assertTrue(20 < len(su.uuid(\"http://www.example.com/\")) < 24)\n        self.assertTrue(20 < len(su.uuid(\"HTTP://www.example.com/\")) < 24)\n        self.assertTrue(20 < len(su.uuid(\"example.com/\")) < 24)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ClassShortUUIDTest.test_random",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def test_random(self):\n        su = ShortUUID()\n        for i in range(1000):\n            self.assertEqual(len(su.random()), 22)\n\n        for i in range(1, 100):\n            self.assertEqual(len(su.random(i)), i)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.CliTest.addCleanup",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, function, /, *args, **kwargs)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_ONLY",
          "description": null
        },
        "function": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_ONLY",
          "description": null
        },
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Add a function, with arguments, to be called when the test is\ncompleted. Functions added are called on a LIFO basis and are\ncalled after tearDown on test failure or success.\n\nCleanup items are called even if setUp fails (unlike tearDown).",
      "source_code": "    def addCleanup(self, function, /, *args, **kwargs):\n        \"\"\"Add a function, with arguments, to be called when the test is\n        completed. Functions added are called on a LIFO basis and are\n        called after tearDown on test failure or success.\n\n        Cleanup items are called even if setUp fails (unlike tearDown).\"\"\"\n        self._cleanups.append((function, args, kwargs))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.CliTest.addTypeEqualityFunc",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, typeobj, function)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "typeobj": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "function": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Add a type specific assertEqual style function to compare a type.\n\nThis method is for use by TestCase subclasses that need to register\ntheir own type equality functions to provide nicer error messages.\n\nArgs:\n    typeobj: The data type to call this function on when both values\n            are of the same type in assertEqual().\n    function: The callable taking two arguments and an optional\n            msg= argument that raises self.failureException with a\n            useful error message when the two arguments are not equal.",
      "source_code": "    def addTypeEqualityFunc(self, typeobj, function):\n        \"\"\"Add a type specific assertEqual style function to compare a type.\n\n        This method is for use by TestCase subclasses that need to register\n        their own type equality functions to provide nicer error messages.\n\n        Args:\n            typeobj: The data type to call this function on when both values\n                    are of the same type in assertEqual().\n            function: The callable taking two arguments and an optional\n                    msg= argument that raises self.failureException with a\n                    useful error message when the two arguments are not equal.\n        \"\"\"\n        self._type_equality_funcs[typeobj] = function\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.CliTest.assertAlmostEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, first, second, places=None, msg=None, delta=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "first": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "second": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "places": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "delta": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Fail if the two objects are unequal as determined by their\ndifference rounded to the given number of decimal places\n(default 7) and comparing to zero, or by comparing that the\ndifference between the two objects is more than the given\ndelta.\n\nNote that decimal places (from zero) are usually not the same\nas significant digits (measured from the most significant digit).\n\nIf the two objects compare equal then they will automatically\ncompare almost equal.",
      "source_code": "    def assertAlmostEqual(self, first, second, places=None, msg=None,\n                          delta=None):\n        \"\"\"Fail if the two objects are unequal as determined by their\n           difference rounded to the given number of decimal places\n           (default 7) and comparing to zero, or by comparing that the\n           difference between the two objects is more than the given\n           delta.\n\n           Note that decimal places (from zero) are usually not the same\n           as significant digits (measured from the most significant digit).\n\n           If the two objects compare equal then they will automatically\n           compare almost equal.\n        \"\"\"\n        if first == second:\n            # shortcut\n            return\n        if delta is not None and places is not None:\n            raise TypeError(\"specify delta or places not both\")\n\n        diff = abs(first - second)\n        if delta is not None:\n            if diff <= delta:\n                return\n\n            standardMsg = '%s != %s within %s delta (%s difference)' % (\n                safe_repr(first),\n                safe_repr(second),\n                safe_repr(delta),\n                safe_repr(diff))\n        else:\n            if places is None:\n                places = 7\n\n            if round(diff, places) == 0:\n                return\n\n            standardMsg = '%s != %s within %r places (%s difference)' % (\n                safe_repr(first),\n                safe_repr(second),\n                places,\n                safe_repr(diff))\n        msg = self._formatMessage(msg, standardMsg)\n        raise self.failureException(msg)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.CliTest.assertAlmostEquals",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.CliTest.assertCountEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, first, second, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "first": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "second": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Asserts that two iterables have the same elements, the same number of\ntimes, without regard to order.\n\n    self.assertEqual(Counter(list(first)),\n                     Counter(list(second)))\n\n Example:\n    - [0, 1, 1] and [1, 0, 1] compare equal.\n    - [0, 0, 1] and [0, 1] compare unequal.",
      "source_code": "    def assertCountEqual(self, first, second, msg=None):\n        \"\"\"Asserts that two iterables have the same elements, the same number of\n        times, without regard to order.\n\n            self.assertEqual(Counter(list(first)),\n                             Counter(list(second)))\n\n         Example:\n            - [0, 1, 1] and [1, 0, 1] compare equal.\n            - [0, 0, 1] and [0, 1] compare unequal.\n\n        \"\"\"\n        first_seq, second_seq = list(first), list(second)\n        try:\n            first = collections.Counter(first_seq)\n            second = collections.Counter(second_seq)\n        except TypeError:\n            # Handle case with unhashable elements\n            differences = _count_diff_all_purpose(first_seq, second_seq)\n        else:\n            if first == second:\n                return\n            differences = _count_diff_hashable(first_seq, second_seq)\n\n        if differences:\n            standardMsg = 'Element counts were not equal:\\n'\n            lines = ['First has %d, Second has %d:  %r' % diff for diff in differences]\n            diffMsg = '\\n'.join(lines)\n            standardMsg = self._truncateMessage(standardMsg, diffMsg)\n            msg = self._formatMessage(msg, standardMsg)\n            self.fail(msg)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.CliTest.assertDictContainsSubset",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, subset, dictionary, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "subset": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "dictionary": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Checks whether dictionary is a superset of subset.",
      "source_code": "    def assertDictContainsSubset(self, subset, dictionary, msg=None):\n        \"\"\"Checks whether dictionary is a superset of subset.\"\"\"\n        warnings.warn('assertDictContainsSubset is deprecated',\n                      DeprecationWarning,\n                      stacklevel=2)\n        missing = []\n        mismatched = []\n        for key, value in subset.items():\n            if key not in dictionary:\n                missing.append(key)\n            elif value != dictionary[key]:\n                mismatched.append('%s, expected: %s, actual: %s' %\n                                  (safe_repr(key), safe_repr(value),\n                                   safe_repr(dictionary[key])))\n\n        if not (missing or mismatched):\n            return\n\n        standardMsg = ''\n        if missing:\n            standardMsg = 'Missing: %s' % ','.join(safe_repr(m) for m in\n                                                    missing)\n        if mismatched:\n            if standardMsg:\n                standardMsg += '; '\n            standardMsg += 'Mismatched values: %s' % ','.join(mismatched)\n\n        self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.CliTest.assertDictEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, d1, d2, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "d1": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "d2": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def assertDictEqual(self, d1, d2, msg=None):\n        self.assertIsInstance(d1, dict, 'First argument is not a dictionary')\n        self.assertIsInstance(d2, dict, 'Second argument is not a dictionary')\n\n        if d1 != d2:\n            standardMsg = '%s != %s' % _common_shorten_repr(d1, d2)\n            diff = ('\\n' + '\\n'.join(difflib.ndiff(\n                           pprint.pformat(d1).splitlines(),\n                           pprint.pformat(d2).splitlines())))\n            standardMsg = self._truncateMessage(standardMsg, diff)\n            self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.CliTest.assertEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, first, second, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "first": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "second": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Fail if the two objects are unequal as determined by the '=='\noperator.",
      "source_code": "    def assertEqual(self, first, second, msg=None):\n        \"\"\"Fail if the two objects are unequal as determined by the '=='\n           operator.\n        \"\"\"\n        assertion_func = self._getAssertEqualityFunc(first, second)\n        assertion_func(first, second, msg=msg)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.CliTest.assertEquals",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.CliTest.assertFalse",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, expr, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "expr": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Check that the expression is false.",
      "source_code": "    def assertFalse(self, expr, msg=None):\n        \"\"\"Check that the expression is false.\"\"\"\n        if expr:\n            msg = self._formatMessage(msg, \"%s is not false\" % safe_repr(expr))\n            raise self.failureException(msg)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.CliTest.assertGreater",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, a, b, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "a": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "b": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Just like self.assertTrue(a > b), but with a nicer default message.",
      "source_code": "    def assertGreater(self, a, b, msg=None):\n        \"\"\"Just like self.assertTrue(a > b), but with a nicer default message.\"\"\"\n        if not a > b:\n            standardMsg = '%s not greater than %s' % (safe_repr(a), safe_repr(b))\n            self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.CliTest.assertGreaterEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, a, b, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "a": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "b": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Just like self.assertTrue(a >= b), but with a nicer default message.",
      "source_code": "    def assertGreaterEqual(self, a, b, msg=None):\n        \"\"\"Just like self.assertTrue(a >= b), but with a nicer default message.\"\"\"\n        if not a >= b:\n            standardMsg = '%s not greater than or equal to %s' % (safe_repr(a), safe_repr(b))\n            self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.CliTest.assertIn",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, member, container, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "member": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "container": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Just like self.assertTrue(a in b), but with a nicer default message.",
      "source_code": "    def assertIn(self, member, container, msg=None):\n        \"\"\"Just like self.assertTrue(a in b), but with a nicer default message.\"\"\"\n        if member not in container:\n            standardMsg = '%s not found in %s' % (safe_repr(member),\n                                                  safe_repr(container))\n            self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.CliTest.assertIs",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, expr1, expr2, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "expr1": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "expr2": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Just like self.assertTrue(a is b), but with a nicer default message.",
      "source_code": "    def assertIs(self, expr1, expr2, msg=None):\n        \"\"\"Just like self.assertTrue(a is b), but with a nicer default message.\"\"\"\n        if expr1 is not expr2:\n            standardMsg = '%s is not %s' % (safe_repr(expr1),\n                                             safe_repr(expr2))\n            self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.CliTest.assertIsInstance",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, obj, cls, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "obj": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "cls": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Same as self.assertTrue(isinstance(obj, cls)), with a nicer\ndefault message.",
      "source_code": "    def assertIsInstance(self, obj, cls, msg=None):\n        \"\"\"Same as self.assertTrue(isinstance(obj, cls)), with a nicer\n        default message.\"\"\"\n        if not isinstance(obj, cls):\n            standardMsg = '%s is not an instance of %r' % (safe_repr(obj), cls)\n            self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.CliTest.assertIsNone",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, obj, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "obj": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Same as self.assertTrue(obj is None), with a nicer default message.",
      "source_code": "    def assertIsNone(self, obj, msg=None):\n        \"\"\"Same as self.assertTrue(obj is None), with a nicer default message.\"\"\"\n        if obj is not None:\n            standardMsg = '%s is not None' % (safe_repr(obj),)\n            self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.CliTest.assertIsNot",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, expr1, expr2, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "expr1": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "expr2": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Just like self.assertTrue(a is not b), but with a nicer default message.",
      "source_code": "    def assertIsNot(self, expr1, expr2, msg=None):\n        \"\"\"Just like self.assertTrue(a is not b), but with a nicer default message.\"\"\"\n        if expr1 is expr2:\n            standardMsg = 'unexpectedly identical: %s' % (safe_repr(expr1),)\n            self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.CliTest.assertIsNotNone",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, obj, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "obj": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Included for symmetry with assertIsNone.",
      "source_code": "    def assertIsNotNone(self, obj, msg=None):\n        \"\"\"Included for symmetry with assertIsNone.\"\"\"\n        if obj is None:\n            standardMsg = 'unexpectedly None'\n            self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.CliTest.assertLess",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, a, b, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "a": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "b": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Just like self.assertTrue(a < b), but with a nicer default message.",
      "source_code": "    def assertLess(self, a, b, msg=None):\n        \"\"\"Just like self.assertTrue(a < b), but with a nicer default message.\"\"\"\n        if not a < b:\n            standardMsg = '%s not less than %s' % (safe_repr(a), safe_repr(b))\n            self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.CliTest.assertLessEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, a, b, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "a": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "b": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Just like self.assertTrue(a <= b), but with a nicer default message.",
      "source_code": "    def assertLessEqual(self, a, b, msg=None):\n        \"\"\"Just like self.assertTrue(a <= b), but with a nicer default message.\"\"\"\n        if not a <= b:\n            standardMsg = '%s not less than or equal to %s' % (safe_repr(a), safe_repr(b))\n            self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.CliTest.assertListEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, list1, list2, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "list1": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "list2": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "A list-specific equality assertion.\n\nArgs:\n    list1: The first list to compare.\n    list2: The second list to compare.\n    msg: Optional message to use on failure instead of a list of\n            differences.",
      "source_code": "    def assertListEqual(self, list1, list2, msg=None):\n        \"\"\"A list-specific equality assertion.\n\n        Args:\n            list1: The first list to compare.\n            list2: The second list to compare.\n            msg: Optional message to use on failure instead of a list of\n                    differences.\n\n        \"\"\"\n        self.assertSequenceEqual(list1, list2, msg, seq_type=list)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.CliTest.assertLogs",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, logger=None, level=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "logger": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "level": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Fail unless a log message of level *level* or higher is emitted\non *logger_name* or its children.  If omitted, *level* defaults to\nINFO and *logger* defaults to the root logger.\n\nThis method must be used as a context manager, and will yield\na recording object with two attributes: `output` and `records`.\nAt the end of the context manager, the `output` attribute will\nbe a list of the matching formatted log messages and the\n`records` attribute will be a list of the corresponding LogRecord\nobjects.\n\nExample::\n\n    with self.assertLogs('foo', level='INFO') as cm:\n        logging.getLogger('foo').info('first message')\n        logging.getLogger('foo.bar').error('second message')\n    self.assertEqual(cm.output, ['INFO:foo:first message',\n                                 'ERROR:foo.bar:second message'])",
      "source_code": "    def assertLogs(self, logger=None, level=None):\n        \"\"\"Fail unless a log message of level *level* or higher is emitted\n        on *logger_name* or its children.  If omitted, *level* defaults to\n        INFO and *logger* defaults to the root logger.\n\n        This method must be used as a context manager, and will yield\n        a recording object with two attributes: `output` and `records`.\n        At the end of the context manager, the `output` attribute will\n        be a list of the matching formatted log messages and the\n        `records` attribute will be a list of the corresponding LogRecord\n        objects.\n\n        Example::\n\n            with self.assertLogs('foo', level='INFO') as cm:\n                logging.getLogger('foo').info('first message')\n                logging.getLogger('foo.bar').error('second message')\n            self.assertEqual(cm.output, ['INFO:foo:first message',\n                                         'ERROR:foo.bar:second message'])\n        \"\"\"\n        # Lazy import to avoid importing logging if it is not needed.\n        from ._log import _AssertLogsContext\n        return _AssertLogsContext(self, logger, level, no_logs=False)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.CliTest.assertMultiLineEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, first, second, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "first": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "second": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Assert that two multi-line strings are equal.",
      "source_code": "    def assertMultiLineEqual(self, first, second, msg=None):\n        \"\"\"Assert that two multi-line strings are equal.\"\"\"\n        self.assertIsInstance(first, str, 'First argument is not a string')\n        self.assertIsInstance(second, str, 'Second argument is not a string')\n\n        if first != second:\n            # don't use difflib if the strings are too long\n            if (len(first) > self._diffThreshold or\n                len(second) > self._diffThreshold):\n                self._baseAssertEqual(first, second, msg)\n            firstlines = first.splitlines(keepends=True)\n            secondlines = second.splitlines(keepends=True)\n            if len(firstlines) == 1 and first.strip('\\r\\n') == first:\n                firstlines = [first + '\\n']\n                secondlines = [second + '\\n']\n            standardMsg = '%s != %s' % _common_shorten_repr(first, second)\n            diff = '\\n' + ''.join(difflib.ndiff(firstlines, secondlines))\n            standardMsg = self._truncateMessage(standardMsg, diff)\n            self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.CliTest.assertNoLogs",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, logger=None, level=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "logger": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "level": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Fail unless no log messages of level *level* or higher are emitted\non *logger_name* or its children.\n\nThis method must be used as a context manager.",
      "source_code": "    def assertNoLogs(self, logger=None, level=None):\n        \"\"\" Fail unless no log messages of level *level* or higher are emitted\n        on *logger_name* or its children.\n\n        This method must be used as a context manager.\n        \"\"\"\n        from ._log import _AssertLogsContext\n        return _AssertLogsContext(self, logger, level, no_logs=True)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.CliTest.assertNotAlmostEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, first, second, places=None, msg=None, delta=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "first": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "second": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "places": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "delta": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Fail if the two objects are equal as determined by their\ndifference rounded to the given number of decimal places\n(default 7) and comparing to zero, or by comparing that the\ndifference between the two objects is less than the given delta.\n\nNote that decimal places (from zero) are usually not the same\nas significant digits (measured from the most significant digit).\n\nObjects that are equal automatically fail.",
      "source_code": "    def assertNotAlmostEqual(self, first, second, places=None, msg=None,\n                             delta=None):\n        \"\"\"Fail if the two objects are equal as determined by their\n           difference rounded to the given number of decimal places\n           (default 7) and comparing to zero, or by comparing that the\n           difference between the two objects is less than the given delta.\n\n           Note that decimal places (from zero) are usually not the same\n           as significant digits (measured from the most significant digit).\n\n           Objects that are equal automatically fail.\n        \"\"\"\n        if delta is not None and places is not None:\n            raise TypeError(\"specify delta or places not both\")\n        diff = abs(first - second)\n        if delta is not None:\n            if not (first == second) and diff > delta:\n                return\n            standardMsg = '%s == %s within %s delta (%s difference)' % (\n                safe_repr(first),\n                safe_repr(second),\n                safe_repr(delta),\n                safe_repr(diff))\n        else:\n            if places is None:\n                places = 7\n            if not (first == second) and round(diff, places) != 0:\n                return\n            standardMsg = '%s == %s within %r places' % (safe_repr(first),\n                                                         safe_repr(second),\n                                                         places)\n\n        msg = self._formatMessage(msg, standardMsg)\n        raise self.failureException(msg)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.CliTest.assertNotAlmostEquals",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.CliTest.assertNotEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, first, second, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "first": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "second": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Fail if the two objects are equal as determined by the '!='\noperator.",
      "source_code": "    def assertNotEqual(self, first, second, msg=None):\n        \"\"\"Fail if the two objects are equal as determined by the '!='\n           operator.\n        \"\"\"\n        if not first != second:\n            msg = self._formatMessage(msg, '%s == %s' % (safe_repr(first),\n                                                          safe_repr(second)))\n            raise self.failureException(msg)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.CliTest.assertNotEquals",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.CliTest.assertNotIn",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, member, container, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "member": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "container": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Just like self.assertTrue(a not in b), but with a nicer default message.",
      "source_code": "    def assertNotIn(self, member, container, msg=None):\n        \"\"\"Just like self.assertTrue(a not in b), but with a nicer default message.\"\"\"\n        if member in container:\n            standardMsg = '%s unexpectedly found in %s' % (safe_repr(member),\n                                                        safe_repr(container))\n            self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.CliTest.assertNotIsInstance",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, obj, cls, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "obj": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "cls": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Included for symmetry with assertIsInstance.",
      "source_code": "    def assertNotIsInstance(self, obj, cls, msg=None):\n        \"\"\"Included for symmetry with assertIsInstance.\"\"\"\n        if isinstance(obj, cls):\n            standardMsg = '%s is an instance of %r' % (safe_repr(obj), cls)\n            self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.CliTest.assertNotRegex",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, text, unexpected_regex, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "text": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "unexpected_regex": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Fail the test if the text matches the regular expression.",
      "source_code": "    def assertNotRegex(self, text, unexpected_regex, msg=None):\n        \"\"\"Fail the test if the text matches the regular expression.\"\"\"\n        if isinstance(unexpected_regex, (str, bytes)):\n            unexpected_regex = re.compile(unexpected_regex)\n        match = unexpected_regex.search(text)\n        if match:\n            standardMsg = 'Regex matched: %r matches %r in %r' % (\n                text[match.start() : match.end()],\n                unexpected_regex.pattern,\n                text)\n            # _formatMessage ensures the longMessage option is respected\n            msg = self._formatMessage(msg, standardMsg)\n            raise self.failureException(msg)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.CliTest.assertNotRegexpMatches",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.CliTest.assertRaises",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, expected_exception, *args, **kwargs)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "expected_exception": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Fail unless an exception of class expected_exception is raised\nby the callable when invoked with specified positional and\nkeyword arguments. If a different type of exception is\nraised, it will not be caught, and the test case will be\ndeemed to have suffered an error, exactly as for an\nunexpected exception.\n\nIf called with the callable and arguments omitted, will return a\ncontext object used like this::\n\n     with self.assertRaises(SomeException):\n         do_something()\n\nAn optional keyword argument 'msg' can be provided when assertRaises\nis used as a context object.\n\nThe context manager keeps a reference to the exception as\nthe 'exception' attribute. This allows you to inspect the\nexception after the assertion::\n\n    with self.assertRaises(SomeException) as cm:\n        do_something()\n    the_exception = cm.exception\n    self.assertEqual(the_exception.error_code, 3)",
      "source_code": "    def assertRaises(self, expected_exception, *args, **kwargs):\n        \"\"\"Fail unless an exception of class expected_exception is raised\n           by the callable when invoked with specified positional and\n           keyword arguments. If a different type of exception is\n           raised, it will not be caught, and the test case will be\n           deemed to have suffered an error, exactly as for an\n           unexpected exception.\n\n           If called with the callable and arguments omitted, will return a\n           context object used like this::\n\n                with self.assertRaises(SomeException):\n                    do_something()\n\n           An optional keyword argument 'msg' can be provided when assertRaises\n           is used as a context object.\n\n           The context manager keeps a reference to the exception as\n           the 'exception' attribute. This allows you to inspect the\n           exception after the assertion::\n\n               with self.assertRaises(SomeException) as cm:\n                   do_something()\n               the_exception = cm.exception\n               self.assertEqual(the_exception.error_code, 3)\n        \"\"\"\n        context = _AssertRaisesContext(expected_exception, self)\n        try:\n            return context.handle('assertRaises', args, kwargs)\n        finally:\n            # bpo-23890: manually break a reference cycle\n            context = None\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.CliTest.assertRaisesRegex",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, expected_exception, expected_regex, *args, **kwargs)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "expected_exception": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "expected_regex": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Asserts that the message in a raised exception matches a regex.\n\nArgs:\n    expected_exception: Exception class expected to be raised.\n    expected_regex: Regex (re.Pattern object or string) expected\n            to be found in error message.\n    args: Function to be called and extra positional args.\n    kwargs: Extra kwargs.\n    msg: Optional message used in case of failure. Can only be used\n            when assertRaisesRegex is used as a context manager.",
      "source_code": "    def assertRaisesRegex(self, expected_exception, expected_regex,\n                          *args, **kwargs):\n        \"\"\"Asserts that the message in a raised exception matches a regex.\n\n        Args:\n            expected_exception: Exception class expected to be raised.\n            expected_regex: Regex (re.Pattern object or string) expected\n                    to be found in error message.\n            args: Function to be called and extra positional args.\n            kwargs: Extra kwargs.\n            msg: Optional message used in case of failure. Can only be used\n                    when assertRaisesRegex is used as a context manager.\n        \"\"\"\n        context = _AssertRaisesContext(expected_exception, self, expected_regex)\n        return context.handle('assertRaisesRegex', args, kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.CliTest.assertRaisesRegexp",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.CliTest.assertRegex",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, text, expected_regex, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "text": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "expected_regex": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Fail the test unless the text matches the regular expression.",
      "source_code": "    def assertRegex(self, text, expected_regex, msg=None):\n        \"\"\"Fail the test unless the text matches the regular expression.\"\"\"\n        if isinstance(expected_regex, (str, bytes)):\n            assert expected_regex, \"expected_regex must not be empty.\"\n            expected_regex = re.compile(expected_regex)\n        if not expected_regex.search(text):\n            standardMsg = \"Regex didn't match: %r not found in %r\" % (\n                expected_regex.pattern, text)\n            # _formatMessage ensures the longMessage option is respected\n            msg = self._formatMessage(msg, standardMsg)\n            raise self.failureException(msg)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.CliTest.assertRegexpMatches",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.CliTest.assertSequenceEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, seq1, seq2, msg=None, seq_type=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "seq1": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "seq2": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "seq_type": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "An equality assertion for ordered sequences (like lists and tuples).\n\nFor the purposes of this function, a valid ordered sequence type is one\nwhich can be indexed, has a length, and has an equality operator.\n\nArgs:\n    seq1: The first sequence to compare.\n    seq2: The second sequence to compare.\n    seq_type: The expected datatype of the sequences, or None if no\n            datatype should be enforced.\n    msg: Optional message to use on failure instead of a list of\n            differences.",
      "source_code": "    def assertSequenceEqual(self, seq1, seq2, msg=None, seq_type=None):\n        \"\"\"An equality assertion for ordered sequences (like lists and tuples).\n\n        For the purposes of this function, a valid ordered sequence type is one\n        which can be indexed, has a length, and has an equality operator.\n\n        Args:\n            seq1: The first sequence to compare.\n            seq2: The second sequence to compare.\n            seq_type: The expected datatype of the sequences, or None if no\n                    datatype should be enforced.\n            msg: Optional message to use on failure instead of a list of\n                    differences.\n        \"\"\"\n        if seq_type is not None:\n            seq_type_name = seq_type.__name__\n            if not isinstance(seq1, seq_type):\n                raise self.failureException('First sequence is not a %s: %s'\n                                        % (seq_type_name, safe_repr(seq1)))\n            if not isinstance(seq2, seq_type):\n                raise self.failureException('Second sequence is not a %s: %s'\n                                        % (seq_type_name, safe_repr(seq2)))\n        else:\n            seq_type_name = \"sequence\"\n\n        differing = None\n        try:\n            len1 = len(seq1)\n        except (TypeError, NotImplementedError):\n            differing = 'First %s has no length.    Non-sequence?' % (\n                    seq_type_name)\n\n        if differing is None:\n            try:\n                len2 = len(seq2)\n            except (TypeError, NotImplementedError):\n                differing = 'Second %s has no length.    Non-sequence?' % (\n                        seq_type_name)\n\n        if differing is None:\n            if seq1 == seq2:\n                return\n\n            differing = '%ss differ: %s != %s\\n' % (\n                    (seq_type_name.capitalize(),) +\n                    _common_shorten_repr(seq1, seq2))\n\n            for i in range(min(len1, len2)):\n                try:\n                    item1 = seq1[i]\n                except (TypeError, IndexError, NotImplementedError):\n                    differing += ('\\nUnable to index element %d of first %s\\n' %\n                                 (i, seq_type_name))\n                    break\n\n                try:\n                    item2 = seq2[i]\n                except (TypeError, IndexError, NotImplementedError):\n                    differing += ('\\nUnable to index element %d of second %s\\n' %\n                                 (i, seq_type_name))\n                    break\n\n                if item1 != item2:\n                    differing += ('\\nFirst differing element %d:\\n%s\\n%s\\n' %\n                                 ((i,) + _common_shorten_repr(item1, item2)))\n                    break\n            else:\n                if (len1 == len2 and seq_type is None and\n                    type(seq1) != type(seq2)):\n                    # The sequences are the same, but have differing types.\n                    return\n\n            if len1 > len2:\n                differing += ('\\nFirst %s contains %d additional '\n                             'elements.\\n' % (seq_type_name, len1 - len2))\n                try:\n                    differing += ('First extra element %d:\\n%s\\n' %\n                                  (len2, safe_repr(seq1[len2])))\n                except (TypeError, IndexError, NotImplementedError):\n                    differing += ('Unable to index element %d '\n                                  'of first %s\\n' % (len2, seq_type_name))\n            elif len1 < len2:\n                differing += ('\\nSecond %s contains %d additional '\n                             'elements.\\n' % (seq_type_name, len2 - len1))\n                try:\n                    differing += ('First extra element %d:\\n%s\\n' %\n                                  (len1, safe_repr(seq2[len1])))\n                except (TypeError, IndexError, NotImplementedError):\n                    differing += ('Unable to index element %d '\n                                  'of second %s\\n' % (len1, seq_type_name))\n        standardMsg = differing\n        diffMsg = '\\n' + '\\n'.join(\n            difflib.ndiff(pprint.pformat(seq1).splitlines(),\n                          pprint.pformat(seq2).splitlines()))\n\n        standardMsg = self._truncateMessage(standardMsg, diffMsg)\n        msg = self._formatMessage(msg, standardMsg)\n        self.fail(msg)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.CliTest.assertSetEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, set1, set2, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "set1": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "set2": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "A set-specific equality assertion.\n\nArgs:\n    set1: The first set to compare.\n    set2: The second set to compare.\n    msg: Optional message to use on failure instead of a list of\n            differences.\n\nassertSetEqual uses ducktyping to support different types of sets, and\nis optimized for sets specifically (parameters must support a\ndifference method).",
      "source_code": "    def assertSetEqual(self, set1, set2, msg=None):\n        \"\"\"A set-specific equality assertion.\n\n        Args:\n            set1: The first set to compare.\n            set2: The second set to compare.\n            msg: Optional message to use on failure instead of a list of\n                    differences.\n\n        assertSetEqual uses ducktyping to support different types of sets, and\n        is optimized for sets specifically (parameters must support a\n        difference method).\n        \"\"\"\n        try:\n            difference1 = set1.difference(set2)\n        except TypeError as e:\n            self.fail('invalid type when attempting set difference: %s' % e)\n        except AttributeError as e:\n            self.fail('first argument does not support set difference: %s' % e)\n\n        try:\n            difference2 = set2.difference(set1)\n        except TypeError as e:\n            self.fail('invalid type when attempting set difference: %s' % e)\n        except AttributeError as e:\n            self.fail('second argument does not support set difference: %s' % e)\n\n        if not (difference1 or difference2):\n            return\n\n        lines = []\n        if difference1:\n            lines.append('Items in the first set but not the second:')\n            for item in difference1:\n                lines.append(repr(item))\n        if difference2:\n            lines.append('Items in the second set but not the first:')\n            for item in difference2:\n                lines.append(repr(item))\n\n        standardMsg = '\\n'.join(lines)\n        self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.CliTest.assertTrue",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, expr, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "expr": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Check that the expression is true.",
      "source_code": "    def assertTrue(self, expr, msg=None):\n        \"\"\"Check that the expression is true.\"\"\"\n        if not expr:\n            msg = self._formatMessage(msg, \"%s is not true\" % safe_repr(expr))\n            raise self.failureException(msg)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.CliTest.assertTupleEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, tuple1, tuple2, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "tuple1": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "tuple2": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "A tuple-specific equality assertion.\n\nArgs:\n    tuple1: The first tuple to compare.\n    tuple2: The second tuple to compare.\n    msg: Optional message to use on failure instead of a list of\n            differences.",
      "source_code": "    def assertTupleEqual(self, tuple1, tuple2, msg=None):\n        \"\"\"A tuple-specific equality assertion.\n\n        Args:\n            tuple1: The first tuple to compare.\n            tuple2: The second tuple to compare.\n            msg: Optional message to use on failure instead of a list of\n                    differences.\n        \"\"\"\n        self.assertSequenceEqual(tuple1, tuple2, msg, seq_type=tuple)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.CliTest.assertWarns",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, expected_warning, *args, **kwargs)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "expected_warning": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Fail unless a warning of class warnClass is triggered\nby the callable when invoked with specified positional and\nkeyword arguments.  If a different type of warning is\ntriggered, it will not be handled: depending on the other\nwarning filtering rules in effect, it might be silenced, printed\nout, or raised as an exception.\n\nIf called with the callable and arguments omitted, will return a\ncontext object used like this::\n\n     with self.assertWarns(SomeWarning):\n         do_something()\n\nAn optional keyword argument 'msg' can be provided when assertWarns\nis used as a context object.\n\nThe context manager keeps a reference to the first matching\nwarning as the 'warning' attribute; similarly, the 'filename'\nand 'lineno' attributes give you information about the line\nof Python code from which the warning was triggered.\nThis allows you to inspect the warning after the assertion::\n\n    with self.assertWarns(SomeWarning) as cm:\n        do_something()\n    the_warning = cm.warning\n    self.assertEqual(the_warning.some_attribute, 147)",
      "source_code": "    def assertWarns(self, expected_warning, *args, **kwargs):\n        \"\"\"Fail unless a warning of class warnClass is triggered\n           by the callable when invoked with specified positional and\n           keyword arguments.  If a different type of warning is\n           triggered, it will not be handled: depending on the other\n           warning filtering rules in effect, it might be silenced, printed\n           out, or raised as an exception.\n\n           If called with the callable and arguments omitted, will return a\n           context object used like this::\n\n                with self.assertWarns(SomeWarning):\n                    do_something()\n\n           An optional keyword argument 'msg' can be provided when assertWarns\n           is used as a context object.\n\n           The context manager keeps a reference to the first matching\n           warning as the 'warning' attribute; similarly, the 'filename'\n           and 'lineno' attributes give you information about the line\n           of Python code from which the warning was triggered.\n           This allows you to inspect the warning after the assertion::\n\n               with self.assertWarns(SomeWarning) as cm:\n                   do_something()\n               the_warning = cm.warning\n               self.assertEqual(the_warning.some_attribute, 147)\n        \"\"\"\n        context = _AssertWarnsContext(expected_warning, self)\n        return context.handle('assertWarns', args, kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.CliTest.assertWarnsRegex",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, expected_warning, expected_regex, *args, **kwargs)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "expected_warning": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "expected_regex": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Asserts that the message in a triggered warning matches a regexp.\nBasic functioning is similar to assertWarns() with the addition\nthat only warnings whose messages also match the regular expression\nare considered successful matches.\n\nArgs:\n    expected_warning: Warning class expected to be triggered.\n    expected_regex: Regex (re.Pattern object or string) expected\n            to be found in error message.\n    args: Function to be called and extra positional args.\n    kwargs: Extra kwargs.\n    msg: Optional message used in case of failure. Can only be used\n            when assertWarnsRegex is used as a context manager.",
      "source_code": "    def assertWarnsRegex(self, expected_warning, expected_regex,\n                         *args, **kwargs):\n        \"\"\"Asserts that the message in a triggered warning matches a regexp.\n        Basic functioning is similar to assertWarns() with the addition\n        that only warnings whose messages also match the regular expression\n        are considered successful matches.\n\n        Args:\n            expected_warning: Warning class expected to be triggered.\n            expected_regex: Regex (re.Pattern object or string) expected\n                    to be found in error message.\n            args: Function to be called and extra positional args.\n            kwargs: Extra kwargs.\n            msg: Optional message used in case of failure. Can only be used\n                    when assertWarnsRegex is used as a context manager.\n        \"\"\"\n        context = _AssertWarnsContext(expected_warning, self, expected_regex)\n        return context.handle('assertWarnsRegex', args, kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.CliTest.assert_",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.CliTest.countTestCases",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def countTestCases(self):\n        return 1\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.CliTest.debug",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Run the test without collecting errors in a TestResult",
      "source_code": "    def debug(self):\n        \"\"\"Run the test without collecting errors in a TestResult\"\"\"\n        testMethod = getattr(self, self._testMethodName)\n        if (getattr(self.__class__, \"__unittest_skip__\", False) or\n            getattr(testMethod, \"__unittest_skip__\", False)):\n            # If the class or method was skipped.\n            skip_why = (getattr(self.__class__, '__unittest_skip_why__', '')\n                        or getattr(testMethod, '__unittest_skip_why__', ''))\n            raise SkipTest(skip_why)\n\n        self._callSetUp()\n        self._callTestMethod(testMethod)\n        self._callTearDown()\n        while self._cleanups:\n            function, args, kwargs = self._cleanups.pop()\n            self._callCleanup(function, *args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.CliTest.defaultTestResult",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def defaultTestResult(self):\n        return result.TestResult()\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.CliTest.doCleanups",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Execute all cleanup functions. Normally called for you after\ntearDown.",
      "source_code": "    def doCleanups(self):\n        \"\"\"Execute all cleanup functions. Normally called for you after\n        tearDown.\"\"\"\n        outcome = self._outcome or _Outcome()\n        while self._cleanups:\n            function, args, kwargs = self._cleanups.pop()\n            with outcome.testPartExecutor(self):\n                self._callCleanup(function, *args, **kwargs)\n\n        # return this for backwards compatibility\n        # even though we no longer use it internally\n        return outcome.success\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.CliTest.fail",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Fail immediately, with the given message.",
      "source_code": "    def fail(self, msg=None):\n        \"\"\"Fail immediately, with the given message.\"\"\"\n        raise self.failureException(msg)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.CliTest.failIf",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.CliTest.failIfAlmostEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.CliTest.failIfEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.CliTest.failUnless",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.CliTest.failUnlessAlmostEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.CliTest.failUnlessEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.CliTest.failUnlessRaises",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.CliTest.id",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def id(self):\n        return \"%s.%s\" % (strclass(self.__class__), self._testMethodName)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.CliTest.run",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, result=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "result": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def run(self, result=None):\n        if result is None:\n            result = self.defaultTestResult()\n            startTestRun = getattr(result, 'startTestRun', None)\n            stopTestRun = getattr(result, 'stopTestRun', None)\n            if startTestRun is not None:\n                startTestRun()\n        else:\n            stopTestRun = None\n\n        result.startTest(self)\n        try:\n            testMethod = getattr(self, self._testMethodName)\n            if (getattr(self.__class__, \"__unittest_skip__\", False) or\n                getattr(testMethod, \"__unittest_skip__\", False)):\n                # If the class or method was skipped.\n                skip_why = (getattr(self.__class__, '__unittest_skip_why__', '')\n                            or getattr(testMethod, '__unittest_skip_why__', ''))\n                self._addSkip(result, self, skip_why)\n                return result\n\n            expecting_failure = (\n                getattr(self, \"__unittest_expecting_failure__\", False) or\n                getattr(testMethod, \"__unittest_expecting_failure__\", False)\n            )\n            outcome = _Outcome(result)\n            try:\n                self._outcome = outcome\n\n                with outcome.testPartExecutor(self):\n                    self._callSetUp()\n                if outcome.success:\n                    outcome.expecting_failure = expecting_failure\n                    with outcome.testPartExecutor(self, isTest=True):\n                        self._callTestMethod(testMethod)\n                    outcome.expecting_failure = False\n                    with outcome.testPartExecutor(self):\n                        self._callTearDown()\n\n                self.doCleanups()\n                for test, reason in outcome.skipped:\n                    self._addSkip(result, test, reason)\n                self._feedErrorsToResult(result, outcome.errors)\n                if outcome.success:\n                    if expecting_failure:\n                        if outcome.expectedFailure:\n                            self._addExpectedFailure(result, outcome.expectedFailure)\n                        else:\n                            self._addUnexpectedSuccess(result)\n                    else:\n                        result.addSuccess(self)\n                return result\n            finally:\n                # explicitly break reference cycles:\n                # outcome.errors -> frame -> outcome -> outcome.errors\n                # outcome.expectedFailure -> frame -> outcome -> outcome.expectedFailure\n                outcome.errors.clear()\n                outcome.expectedFailure = None\n\n                # clear the outcome, no more needed\n                self._outcome = None\n\n        finally:\n            result.stopTest(self)\n            if stopTestRun is not None:\n                stopTestRun()\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.CliTest.setUp",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Hook method for setting up the test fixture before exercising it.",
      "source_code": "    def setUp(self):\n        \"Hook method for setting up the test fixture before exercising it.\"\n        pass\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.CliTest.shortDescription",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Returns a one-line description of the test, or None if no\ndescription has been provided.\n\nThe default implementation of this method returns the first line of\nthe specified test method's docstring.",
      "source_code": "    def shortDescription(self):\n        \"\"\"Returns a one-line description of the test, or None if no\n        description has been provided.\n\n        The default implementation of this method returns the first line of\n        the specified test method's docstring.\n        \"\"\"\n        doc = self._testMethodDoc\n        return doc.strip().split(\"\\n\")[0].strip() if doc else None\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.CliTest.skipTest",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, reason)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "reason": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Skip this test.",
      "source_code": "    def skipTest(self, reason):\n        \"\"\"Skip this test.\"\"\"\n        raise SkipTest(reason)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.CliTest.subTest",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, msg=<object object at 0x7e3e03b88ce0>, **params)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "<object object at 0x7e3e03b88ce0>",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "params": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [
        "contextlib.contextmanager"
      ],
      "examples": [],
      "docstring": "Return a context manager that will return the enclosed block\nof code in a subtest identified by the optional message and\nkeyword parameters.  A failure in the subtest marks the test\ncase as failed but resumes execution at the end of the enclosed\nblock, allowing further test code to be executed.",
      "source_code": "    @contextlib.contextmanager\n    def subTest(self, msg=_subtest_msg_sentinel, **params):\n        \"\"\"Return a context manager that will return the enclosed block\n        of code in a subtest identified by the optional message and\n        keyword parameters.  A failure in the subtest marks the test\n        case as failed but resumes execution at the end of the enclosed\n        block, allowing further test code to be executed.\n        \"\"\"\n        if self._outcome is None or not self._outcome.result_supports_subtests:\n            yield\n            return\n        parent = self._subtest\n        if parent is None:\n            params_map = _OrderedChainMap(params)\n        else:\n            params_map = parent.params.new_child(params)\n        self._subtest = _SubTest(self, msg, params_map)\n        try:\n            with self._outcome.testPartExecutor(self._subtest, isTest=True):\n                yield\n            if not self._outcome.success:\n                result = self._outcome.result\n                if result is not None and result.failfast:\n                    raise _ShouldStop\n            elif self._outcome.expectedFailure:\n                # If the test is expecting a failure, we really want to\n                # stop now and register the expected failure.\n                raise _ShouldStop\n        finally:\n            self._subtest = parent\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.CliTest.tearDown",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Hook method for deconstructing the test fixture after testing it.",
      "source_code": "    def tearDown(self):\n        \"Hook method for deconstructing the test fixture after testing it.\"\n        pass\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.CliTest.test_decode_command",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, mock_print)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "mock_print": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [
        "patch(\"shortuuid.cli.print\")"
      ],
      "examples": [],
      "docstring": "",
      "source_code": "    @patch(\"shortuuid.cli.print\")\n    def test_decode_command(self, mock_print):\n        cli([\"decode\", \"CXc85b4rqinB7s5J52TRYb\"])\n\n        terminal_output = mock_print.call_args[0][0]\n        self.assertEqual(terminal_output, \"3b1f8b40-222c-4a6e-b77e-779d5a94e21c\")\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.CliTest.test_encode_command",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, mock_print)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "mock_print": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [
        "patch(\"shortuuid.cli.print\")"
      ],
      "examples": [],
      "docstring": "",
      "source_code": "    @patch(\"shortuuid.cli.print\")\n    def test_encode_command(self, mock_print):\n        cli([\"encode\", \"3b1f8b40-222c-4a6e-b77e-779d5a94e21c\"])\n\n        terminal_output = mock_print.call_args[0][0]\n        self.assertEqual(terminal_output, \"CXc85b4rqinB7s5J52TRYb\")\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.CliTest.test_shortuuid_command_produces_uuid",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, mock_print)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "mock_print": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [
        "patch(\"shortuuid.cli.print\")"
      ],
      "examples": [],
      "docstring": "",
      "source_code": "    @patch(\"shortuuid.cli.print\")\n    def test_shortuuid_command_produces_uuid(self, mock_print):\n        # When we call the main cli function\n        cli([])\n        # Then a shortuuid is printed out\n        mock_print.assert_called()\n        terminal_output = mock_print.call_args[0][0]\n        self.assertEqual(len(terminal_output), 22)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.DecodingEdgeCasesTest.addCleanup",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, function, /, *args, **kwargs)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_ONLY",
          "description": null
        },
        "function": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_ONLY",
          "description": null
        },
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Add a function, with arguments, to be called when the test is\ncompleted. Functions added are called on a LIFO basis and are\ncalled after tearDown on test failure or success.\n\nCleanup items are called even if setUp fails (unlike tearDown).",
      "source_code": "    def addCleanup(self, function, /, *args, **kwargs):\n        \"\"\"Add a function, with arguments, to be called when the test is\n        completed. Functions added are called on a LIFO basis and are\n        called after tearDown on test failure or success.\n\n        Cleanup items are called even if setUp fails (unlike tearDown).\"\"\"\n        self._cleanups.append((function, args, kwargs))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.DecodingEdgeCasesTest.addTypeEqualityFunc",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, typeobj, function)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "typeobj": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "function": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Add a type specific assertEqual style function to compare a type.\n\nThis method is for use by TestCase subclasses that need to register\ntheir own type equality functions to provide nicer error messages.\n\nArgs:\n    typeobj: The data type to call this function on when both values\n            are of the same type in assertEqual().\n    function: The callable taking two arguments and an optional\n            msg= argument that raises self.failureException with a\n            useful error message when the two arguments are not equal.",
      "source_code": "    def addTypeEqualityFunc(self, typeobj, function):\n        \"\"\"Add a type specific assertEqual style function to compare a type.\n\n        This method is for use by TestCase subclasses that need to register\n        their own type equality functions to provide nicer error messages.\n\n        Args:\n            typeobj: The data type to call this function on when both values\n                    are of the same type in assertEqual().\n            function: The callable taking two arguments and an optional\n                    msg= argument that raises self.failureException with a\n                    useful error message when the two arguments are not equal.\n        \"\"\"\n        self._type_equality_funcs[typeobj] = function\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.DecodingEdgeCasesTest.assertAlmostEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, first, second, places=None, msg=None, delta=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "first": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "second": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "places": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "delta": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Fail if the two objects are unequal as determined by their\ndifference rounded to the given number of decimal places\n(default 7) and comparing to zero, or by comparing that the\ndifference between the two objects is more than the given\ndelta.\n\nNote that decimal places (from zero) are usually not the same\nas significant digits (measured from the most significant digit).\n\nIf the two objects compare equal then they will automatically\ncompare almost equal.",
      "source_code": "    def assertAlmostEqual(self, first, second, places=None, msg=None,\n                          delta=None):\n        \"\"\"Fail if the two objects are unequal as determined by their\n           difference rounded to the given number of decimal places\n           (default 7) and comparing to zero, or by comparing that the\n           difference between the two objects is more than the given\n           delta.\n\n           Note that decimal places (from zero) are usually not the same\n           as significant digits (measured from the most significant digit).\n\n           If the two objects compare equal then they will automatically\n           compare almost equal.\n        \"\"\"\n        if first == second:\n            # shortcut\n            return\n        if delta is not None and places is not None:\n            raise TypeError(\"specify delta or places not both\")\n\n        diff = abs(first - second)\n        if delta is not None:\n            if diff <= delta:\n                return\n\n            standardMsg = '%s != %s within %s delta (%s difference)' % (\n                safe_repr(first),\n                safe_repr(second),\n                safe_repr(delta),\n                safe_repr(diff))\n        else:\n            if places is None:\n                places = 7\n\n            if round(diff, places) == 0:\n                return\n\n            standardMsg = '%s != %s within %r places (%s difference)' % (\n                safe_repr(first),\n                safe_repr(second),\n                places,\n                safe_repr(diff))\n        msg = self._formatMessage(msg, standardMsg)\n        raise self.failureException(msg)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.DecodingEdgeCasesTest.assertAlmostEquals",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.DecodingEdgeCasesTest.assertCountEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, first, second, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "first": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "second": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Asserts that two iterables have the same elements, the same number of\ntimes, without regard to order.\n\n    self.assertEqual(Counter(list(first)),\n                     Counter(list(second)))\n\n Example:\n    - [0, 1, 1] and [1, 0, 1] compare equal.\n    - [0, 0, 1] and [0, 1] compare unequal.",
      "source_code": "    def assertCountEqual(self, first, second, msg=None):\n        \"\"\"Asserts that two iterables have the same elements, the same number of\n        times, without regard to order.\n\n            self.assertEqual(Counter(list(first)),\n                             Counter(list(second)))\n\n         Example:\n            - [0, 1, 1] and [1, 0, 1] compare equal.\n            - [0, 0, 1] and [0, 1] compare unequal.\n\n        \"\"\"\n        first_seq, second_seq = list(first), list(second)\n        try:\n            first = collections.Counter(first_seq)\n            second = collections.Counter(second_seq)\n        except TypeError:\n            # Handle case with unhashable elements\n            differences = _count_diff_all_purpose(first_seq, second_seq)\n        else:\n            if first == second:\n                return\n            differences = _count_diff_hashable(first_seq, second_seq)\n\n        if differences:\n            standardMsg = 'Element counts were not equal:\\n'\n            lines = ['First has %d, Second has %d:  %r' % diff for diff in differences]\n            diffMsg = '\\n'.join(lines)\n            standardMsg = self._truncateMessage(standardMsg, diffMsg)\n            msg = self._formatMessage(msg, standardMsg)\n            self.fail(msg)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.DecodingEdgeCasesTest.assertDictContainsSubset",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, subset, dictionary, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "subset": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "dictionary": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Checks whether dictionary is a superset of subset.",
      "source_code": "    def assertDictContainsSubset(self, subset, dictionary, msg=None):\n        \"\"\"Checks whether dictionary is a superset of subset.\"\"\"\n        warnings.warn('assertDictContainsSubset is deprecated',\n                      DeprecationWarning,\n                      stacklevel=2)\n        missing = []\n        mismatched = []\n        for key, value in subset.items():\n            if key not in dictionary:\n                missing.append(key)\n            elif value != dictionary[key]:\n                mismatched.append('%s, expected: %s, actual: %s' %\n                                  (safe_repr(key), safe_repr(value),\n                                   safe_repr(dictionary[key])))\n\n        if not (missing or mismatched):\n            return\n\n        standardMsg = ''\n        if missing:\n            standardMsg = 'Missing: %s' % ','.join(safe_repr(m) for m in\n                                                    missing)\n        if mismatched:\n            if standardMsg:\n                standardMsg += '; '\n            standardMsg += 'Mismatched values: %s' % ','.join(mismatched)\n\n        self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.DecodingEdgeCasesTest.assertDictEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, d1, d2, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "d1": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "d2": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def assertDictEqual(self, d1, d2, msg=None):\n        self.assertIsInstance(d1, dict, 'First argument is not a dictionary')\n        self.assertIsInstance(d2, dict, 'Second argument is not a dictionary')\n\n        if d1 != d2:\n            standardMsg = '%s != %s' % _common_shorten_repr(d1, d2)\n            diff = ('\\n' + '\\n'.join(difflib.ndiff(\n                           pprint.pformat(d1).splitlines(),\n                           pprint.pformat(d2).splitlines())))\n            standardMsg = self._truncateMessage(standardMsg, diff)\n            self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.DecodingEdgeCasesTest.assertEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, first, second, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "first": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "second": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Fail if the two objects are unequal as determined by the '=='\noperator.",
      "source_code": "    def assertEqual(self, first, second, msg=None):\n        \"\"\"Fail if the two objects are unequal as determined by the '=='\n           operator.\n        \"\"\"\n        assertion_func = self._getAssertEqualityFunc(first, second)\n        assertion_func(first, second, msg=msg)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.DecodingEdgeCasesTest.assertEquals",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.DecodingEdgeCasesTest.assertFalse",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, expr, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "expr": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Check that the expression is false.",
      "source_code": "    def assertFalse(self, expr, msg=None):\n        \"\"\"Check that the expression is false.\"\"\"\n        if expr:\n            msg = self._formatMessage(msg, \"%s is not false\" % safe_repr(expr))\n            raise self.failureException(msg)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.DecodingEdgeCasesTest.assertGreater",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, a, b, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "a": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "b": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Just like self.assertTrue(a > b), but with a nicer default message.",
      "source_code": "    def assertGreater(self, a, b, msg=None):\n        \"\"\"Just like self.assertTrue(a > b), but with a nicer default message.\"\"\"\n        if not a > b:\n            standardMsg = '%s not greater than %s' % (safe_repr(a), safe_repr(b))\n            self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.DecodingEdgeCasesTest.assertGreaterEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, a, b, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "a": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "b": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Just like self.assertTrue(a >= b), but with a nicer default message.",
      "source_code": "    def assertGreaterEqual(self, a, b, msg=None):\n        \"\"\"Just like self.assertTrue(a >= b), but with a nicer default message.\"\"\"\n        if not a >= b:\n            standardMsg = '%s not greater than or equal to %s' % (safe_repr(a), safe_repr(b))\n            self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.DecodingEdgeCasesTest.assertIn",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, member, container, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "member": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "container": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Just like self.assertTrue(a in b), but with a nicer default message.",
      "source_code": "    def assertIn(self, member, container, msg=None):\n        \"\"\"Just like self.assertTrue(a in b), but with a nicer default message.\"\"\"\n        if member not in container:\n            standardMsg = '%s not found in %s' % (safe_repr(member),\n                                                  safe_repr(container))\n            self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.DecodingEdgeCasesTest.assertIs",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, expr1, expr2, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "expr1": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "expr2": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Just like self.assertTrue(a is b), but with a nicer default message.",
      "source_code": "    def assertIs(self, expr1, expr2, msg=None):\n        \"\"\"Just like self.assertTrue(a is b), but with a nicer default message.\"\"\"\n        if expr1 is not expr2:\n            standardMsg = '%s is not %s' % (safe_repr(expr1),\n                                             safe_repr(expr2))\n            self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.DecodingEdgeCasesTest.assertIsInstance",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, obj, cls, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "obj": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "cls": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Same as self.assertTrue(isinstance(obj, cls)), with a nicer\ndefault message.",
      "source_code": "    def assertIsInstance(self, obj, cls, msg=None):\n        \"\"\"Same as self.assertTrue(isinstance(obj, cls)), with a nicer\n        default message.\"\"\"\n        if not isinstance(obj, cls):\n            standardMsg = '%s is not an instance of %r' % (safe_repr(obj), cls)\n            self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.DecodingEdgeCasesTest.assertIsNone",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, obj, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "obj": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Same as self.assertTrue(obj is None), with a nicer default message.",
      "source_code": "    def assertIsNone(self, obj, msg=None):\n        \"\"\"Same as self.assertTrue(obj is None), with a nicer default message.\"\"\"\n        if obj is not None:\n            standardMsg = '%s is not None' % (safe_repr(obj),)\n            self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.DecodingEdgeCasesTest.assertIsNot",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, expr1, expr2, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "expr1": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "expr2": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Just like self.assertTrue(a is not b), but with a nicer default message.",
      "source_code": "    def assertIsNot(self, expr1, expr2, msg=None):\n        \"\"\"Just like self.assertTrue(a is not b), but with a nicer default message.\"\"\"\n        if expr1 is expr2:\n            standardMsg = 'unexpectedly identical: %s' % (safe_repr(expr1),)\n            self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.DecodingEdgeCasesTest.assertIsNotNone",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, obj, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "obj": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Included for symmetry with assertIsNone.",
      "source_code": "    def assertIsNotNone(self, obj, msg=None):\n        \"\"\"Included for symmetry with assertIsNone.\"\"\"\n        if obj is None:\n            standardMsg = 'unexpectedly None'\n            self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.DecodingEdgeCasesTest.assertLess",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, a, b, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "a": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "b": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Just like self.assertTrue(a < b), but with a nicer default message.",
      "source_code": "    def assertLess(self, a, b, msg=None):\n        \"\"\"Just like self.assertTrue(a < b), but with a nicer default message.\"\"\"\n        if not a < b:\n            standardMsg = '%s not less than %s' % (safe_repr(a), safe_repr(b))\n            self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.DecodingEdgeCasesTest.assertLessEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, a, b, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "a": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "b": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Just like self.assertTrue(a <= b), but with a nicer default message.",
      "source_code": "    def assertLessEqual(self, a, b, msg=None):\n        \"\"\"Just like self.assertTrue(a <= b), but with a nicer default message.\"\"\"\n        if not a <= b:\n            standardMsg = '%s not less than or equal to %s' % (safe_repr(a), safe_repr(b))\n            self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.DecodingEdgeCasesTest.assertListEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, list1, list2, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "list1": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "list2": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "A list-specific equality assertion.\n\nArgs:\n    list1: The first list to compare.\n    list2: The second list to compare.\n    msg: Optional message to use on failure instead of a list of\n            differences.",
      "source_code": "    def assertListEqual(self, list1, list2, msg=None):\n        \"\"\"A list-specific equality assertion.\n\n        Args:\n            list1: The first list to compare.\n            list2: The second list to compare.\n            msg: Optional message to use on failure instead of a list of\n                    differences.\n\n        \"\"\"\n        self.assertSequenceEqual(list1, list2, msg, seq_type=list)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.DecodingEdgeCasesTest.assertLogs",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, logger=None, level=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "logger": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "level": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Fail unless a log message of level *level* or higher is emitted\non *logger_name* or its children.  If omitted, *level* defaults to\nINFO and *logger* defaults to the root logger.\n\nThis method must be used as a context manager, and will yield\na recording object with two attributes: `output` and `records`.\nAt the end of the context manager, the `output` attribute will\nbe a list of the matching formatted log messages and the\n`records` attribute will be a list of the corresponding LogRecord\nobjects.\n\nExample::\n\n    with self.assertLogs('foo', level='INFO') as cm:\n        logging.getLogger('foo').info('first message')\n        logging.getLogger('foo.bar').error('second message')\n    self.assertEqual(cm.output, ['INFO:foo:first message',\n                                 'ERROR:foo.bar:second message'])",
      "source_code": "    def assertLogs(self, logger=None, level=None):\n        \"\"\"Fail unless a log message of level *level* or higher is emitted\n        on *logger_name* or its children.  If omitted, *level* defaults to\n        INFO and *logger* defaults to the root logger.\n\n        This method must be used as a context manager, and will yield\n        a recording object with two attributes: `output` and `records`.\n        At the end of the context manager, the `output` attribute will\n        be a list of the matching formatted log messages and the\n        `records` attribute will be a list of the corresponding LogRecord\n        objects.\n\n        Example::\n\n            with self.assertLogs('foo', level='INFO') as cm:\n                logging.getLogger('foo').info('first message')\n                logging.getLogger('foo.bar').error('second message')\n            self.assertEqual(cm.output, ['INFO:foo:first message',\n                                         'ERROR:foo.bar:second message'])\n        \"\"\"\n        # Lazy import to avoid importing logging if it is not needed.\n        from ._log import _AssertLogsContext\n        return _AssertLogsContext(self, logger, level, no_logs=False)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.DecodingEdgeCasesTest.assertMultiLineEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, first, second, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "first": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "second": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Assert that two multi-line strings are equal.",
      "source_code": "    def assertMultiLineEqual(self, first, second, msg=None):\n        \"\"\"Assert that two multi-line strings are equal.\"\"\"\n        self.assertIsInstance(first, str, 'First argument is not a string')\n        self.assertIsInstance(second, str, 'Second argument is not a string')\n\n        if first != second:\n            # don't use difflib if the strings are too long\n            if (len(first) > self._diffThreshold or\n                len(second) > self._diffThreshold):\n                self._baseAssertEqual(first, second, msg)\n            firstlines = first.splitlines(keepends=True)\n            secondlines = second.splitlines(keepends=True)\n            if len(firstlines) == 1 and first.strip('\\r\\n') == first:\n                firstlines = [first + '\\n']\n                secondlines = [second + '\\n']\n            standardMsg = '%s != %s' % _common_shorten_repr(first, second)\n            diff = '\\n' + ''.join(difflib.ndiff(firstlines, secondlines))\n            standardMsg = self._truncateMessage(standardMsg, diff)\n            self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.DecodingEdgeCasesTest.assertNoLogs",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, logger=None, level=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "logger": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "level": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Fail unless no log messages of level *level* or higher are emitted\non *logger_name* or its children.\n\nThis method must be used as a context manager.",
      "source_code": "    def assertNoLogs(self, logger=None, level=None):\n        \"\"\" Fail unless no log messages of level *level* or higher are emitted\n        on *logger_name* or its children.\n\n        This method must be used as a context manager.\n        \"\"\"\n        from ._log import _AssertLogsContext\n        return _AssertLogsContext(self, logger, level, no_logs=True)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.DecodingEdgeCasesTest.assertNotAlmostEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, first, second, places=None, msg=None, delta=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "first": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "second": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "places": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "delta": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Fail if the two objects are equal as determined by their\ndifference rounded to the given number of decimal places\n(default 7) and comparing to zero, or by comparing that the\ndifference between the two objects is less than the given delta.\n\nNote that decimal places (from zero) are usually not the same\nas significant digits (measured from the most significant digit).\n\nObjects that are equal automatically fail.",
      "source_code": "    def assertNotAlmostEqual(self, first, second, places=None, msg=None,\n                             delta=None):\n        \"\"\"Fail if the two objects are equal as determined by their\n           difference rounded to the given number of decimal places\n           (default 7) and comparing to zero, or by comparing that the\n           difference between the two objects is less than the given delta.\n\n           Note that decimal places (from zero) are usually not the same\n           as significant digits (measured from the most significant digit).\n\n           Objects that are equal automatically fail.\n        \"\"\"\n        if delta is not None and places is not None:\n            raise TypeError(\"specify delta or places not both\")\n        diff = abs(first - second)\n        if delta is not None:\n            if not (first == second) and diff > delta:\n                return\n            standardMsg = '%s == %s within %s delta (%s difference)' % (\n                safe_repr(first),\n                safe_repr(second),\n                safe_repr(delta),\n                safe_repr(diff))\n        else:\n            if places is None:\n                places = 7\n            if not (first == second) and round(diff, places) != 0:\n                return\n            standardMsg = '%s == %s within %r places' % (safe_repr(first),\n                                                         safe_repr(second),\n                                                         places)\n\n        msg = self._formatMessage(msg, standardMsg)\n        raise self.failureException(msg)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.DecodingEdgeCasesTest.assertNotAlmostEquals",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.DecodingEdgeCasesTest.assertNotEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, first, second, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "first": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "second": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Fail if the two objects are equal as determined by the '!='\noperator.",
      "source_code": "    def assertNotEqual(self, first, second, msg=None):\n        \"\"\"Fail if the two objects are equal as determined by the '!='\n           operator.\n        \"\"\"\n        if not first != second:\n            msg = self._formatMessage(msg, '%s == %s' % (safe_repr(first),\n                                                          safe_repr(second)))\n            raise self.failureException(msg)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.DecodingEdgeCasesTest.assertNotEquals",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.DecodingEdgeCasesTest.assertNotIn",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, member, container, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "member": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "container": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Just like self.assertTrue(a not in b), but with a nicer default message.",
      "source_code": "    def assertNotIn(self, member, container, msg=None):\n        \"\"\"Just like self.assertTrue(a not in b), but with a nicer default message.\"\"\"\n        if member in container:\n            standardMsg = '%s unexpectedly found in %s' % (safe_repr(member),\n                                                        safe_repr(container))\n            self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.DecodingEdgeCasesTest.assertNotIsInstance",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, obj, cls, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "obj": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "cls": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Included for symmetry with assertIsInstance.",
      "source_code": "    def assertNotIsInstance(self, obj, cls, msg=None):\n        \"\"\"Included for symmetry with assertIsInstance.\"\"\"\n        if isinstance(obj, cls):\n            standardMsg = '%s is an instance of %r' % (safe_repr(obj), cls)\n            self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.DecodingEdgeCasesTest.assertNotRegex",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, text, unexpected_regex, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "text": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "unexpected_regex": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Fail the test if the text matches the regular expression.",
      "source_code": "    def assertNotRegex(self, text, unexpected_regex, msg=None):\n        \"\"\"Fail the test if the text matches the regular expression.\"\"\"\n        if isinstance(unexpected_regex, (str, bytes)):\n            unexpected_regex = re.compile(unexpected_regex)\n        match = unexpected_regex.search(text)\n        if match:\n            standardMsg = 'Regex matched: %r matches %r in %r' % (\n                text[match.start() : match.end()],\n                unexpected_regex.pattern,\n                text)\n            # _formatMessage ensures the longMessage option is respected\n            msg = self._formatMessage(msg, standardMsg)\n            raise self.failureException(msg)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.DecodingEdgeCasesTest.assertNotRegexpMatches",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.DecodingEdgeCasesTest.assertRaises",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, expected_exception, *args, **kwargs)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "expected_exception": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Fail unless an exception of class expected_exception is raised\nby the callable when invoked with specified positional and\nkeyword arguments. If a different type of exception is\nraised, it will not be caught, and the test case will be\ndeemed to have suffered an error, exactly as for an\nunexpected exception.\n\nIf called with the callable and arguments omitted, will return a\ncontext object used like this::\n\n     with self.assertRaises(SomeException):\n         do_something()\n\nAn optional keyword argument 'msg' can be provided when assertRaises\nis used as a context object.\n\nThe context manager keeps a reference to the exception as\nthe 'exception' attribute. This allows you to inspect the\nexception after the assertion::\n\n    with self.assertRaises(SomeException) as cm:\n        do_something()\n    the_exception = cm.exception\n    self.assertEqual(the_exception.error_code, 3)",
      "source_code": "    def assertRaises(self, expected_exception, *args, **kwargs):\n        \"\"\"Fail unless an exception of class expected_exception is raised\n           by the callable when invoked with specified positional and\n           keyword arguments. If a different type of exception is\n           raised, it will not be caught, and the test case will be\n           deemed to have suffered an error, exactly as for an\n           unexpected exception.\n\n           If called with the callable and arguments omitted, will return a\n           context object used like this::\n\n                with self.assertRaises(SomeException):\n                    do_something()\n\n           An optional keyword argument 'msg' can be provided when assertRaises\n           is used as a context object.\n\n           The context manager keeps a reference to the exception as\n           the 'exception' attribute. This allows you to inspect the\n           exception after the assertion::\n\n               with self.assertRaises(SomeException) as cm:\n                   do_something()\n               the_exception = cm.exception\n               self.assertEqual(the_exception.error_code, 3)\n        \"\"\"\n        context = _AssertRaisesContext(expected_exception, self)\n        try:\n            return context.handle('assertRaises', args, kwargs)\n        finally:\n            # bpo-23890: manually break a reference cycle\n            context = None\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.DecodingEdgeCasesTest.assertRaisesRegex",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, expected_exception, expected_regex, *args, **kwargs)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "expected_exception": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "expected_regex": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Asserts that the message in a raised exception matches a regex.\n\nArgs:\n    expected_exception: Exception class expected to be raised.\n    expected_regex: Regex (re.Pattern object or string) expected\n            to be found in error message.\n    args: Function to be called and extra positional args.\n    kwargs: Extra kwargs.\n    msg: Optional message used in case of failure. Can only be used\n            when assertRaisesRegex is used as a context manager.",
      "source_code": "    def assertRaisesRegex(self, expected_exception, expected_regex,\n                          *args, **kwargs):\n        \"\"\"Asserts that the message in a raised exception matches a regex.\n\n        Args:\n            expected_exception: Exception class expected to be raised.\n            expected_regex: Regex (re.Pattern object or string) expected\n                    to be found in error message.\n            args: Function to be called and extra positional args.\n            kwargs: Extra kwargs.\n            msg: Optional message used in case of failure. Can only be used\n                    when assertRaisesRegex is used as a context manager.\n        \"\"\"\n        context = _AssertRaisesContext(expected_exception, self, expected_regex)\n        return context.handle('assertRaisesRegex', args, kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.DecodingEdgeCasesTest.assertRaisesRegexp",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.DecodingEdgeCasesTest.assertRegex",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, text, expected_regex, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "text": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "expected_regex": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Fail the test unless the text matches the regular expression.",
      "source_code": "    def assertRegex(self, text, expected_regex, msg=None):\n        \"\"\"Fail the test unless the text matches the regular expression.\"\"\"\n        if isinstance(expected_regex, (str, bytes)):\n            assert expected_regex, \"expected_regex must not be empty.\"\n            expected_regex = re.compile(expected_regex)\n        if not expected_regex.search(text):\n            standardMsg = \"Regex didn't match: %r not found in %r\" % (\n                expected_regex.pattern, text)\n            # _formatMessage ensures the longMessage option is respected\n            msg = self._formatMessage(msg, standardMsg)\n            raise self.failureException(msg)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.DecodingEdgeCasesTest.assertRegexpMatches",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.DecodingEdgeCasesTest.assertSequenceEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, seq1, seq2, msg=None, seq_type=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "seq1": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "seq2": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "seq_type": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "An equality assertion for ordered sequences (like lists and tuples).\n\nFor the purposes of this function, a valid ordered sequence type is one\nwhich can be indexed, has a length, and has an equality operator.\n\nArgs:\n    seq1: The first sequence to compare.\n    seq2: The second sequence to compare.\n    seq_type: The expected datatype of the sequences, or None if no\n            datatype should be enforced.\n    msg: Optional message to use on failure instead of a list of\n            differences.",
      "source_code": "    def assertSequenceEqual(self, seq1, seq2, msg=None, seq_type=None):\n        \"\"\"An equality assertion for ordered sequences (like lists and tuples).\n\n        For the purposes of this function, a valid ordered sequence type is one\n        which can be indexed, has a length, and has an equality operator.\n\n        Args:\n            seq1: The first sequence to compare.\n            seq2: The second sequence to compare.\n            seq_type: The expected datatype of the sequences, or None if no\n                    datatype should be enforced.\n            msg: Optional message to use on failure instead of a list of\n                    differences.\n        \"\"\"\n        if seq_type is not None:\n            seq_type_name = seq_type.__name__\n            if not isinstance(seq1, seq_type):\n                raise self.failureException('First sequence is not a %s: %s'\n                                        % (seq_type_name, safe_repr(seq1)))\n            if not isinstance(seq2, seq_type):\n                raise self.failureException('Second sequence is not a %s: %s'\n                                        % (seq_type_name, safe_repr(seq2)))\n        else:\n            seq_type_name = \"sequence\"\n\n        differing = None\n        try:\n            len1 = len(seq1)\n        except (TypeError, NotImplementedError):\n            differing = 'First %s has no length.    Non-sequence?' % (\n                    seq_type_name)\n\n        if differing is None:\n            try:\n                len2 = len(seq2)\n            except (TypeError, NotImplementedError):\n                differing = 'Second %s has no length.    Non-sequence?' % (\n                        seq_type_name)\n\n        if differing is None:\n            if seq1 == seq2:\n                return\n\n            differing = '%ss differ: %s != %s\\n' % (\n                    (seq_type_name.capitalize(),) +\n                    _common_shorten_repr(seq1, seq2))\n\n            for i in range(min(len1, len2)):\n                try:\n                    item1 = seq1[i]\n                except (TypeError, IndexError, NotImplementedError):\n                    differing += ('\\nUnable to index element %d of first %s\\n' %\n                                 (i, seq_type_name))\n                    break\n\n                try:\n                    item2 = seq2[i]\n                except (TypeError, IndexError, NotImplementedError):\n                    differing += ('\\nUnable to index element %d of second %s\\n' %\n                                 (i, seq_type_name))\n                    break\n\n                if item1 != item2:\n                    differing += ('\\nFirst differing element %d:\\n%s\\n%s\\n' %\n                                 ((i,) + _common_shorten_repr(item1, item2)))\n                    break\n            else:\n                if (len1 == len2 and seq_type is None and\n                    type(seq1) != type(seq2)):\n                    # The sequences are the same, but have differing types.\n                    return\n\n            if len1 > len2:\n                differing += ('\\nFirst %s contains %d additional '\n                             'elements.\\n' % (seq_type_name, len1 - len2))\n                try:\n                    differing += ('First extra element %d:\\n%s\\n' %\n                                  (len2, safe_repr(seq1[len2])))\n                except (TypeError, IndexError, NotImplementedError):\n                    differing += ('Unable to index element %d '\n                                  'of first %s\\n' % (len2, seq_type_name))\n            elif len1 < len2:\n                differing += ('\\nSecond %s contains %d additional '\n                             'elements.\\n' % (seq_type_name, len2 - len1))\n                try:\n                    differing += ('First extra element %d:\\n%s\\n' %\n                                  (len1, safe_repr(seq2[len1])))\n                except (TypeError, IndexError, NotImplementedError):\n                    differing += ('Unable to index element %d '\n                                  'of second %s\\n' % (len1, seq_type_name))\n        standardMsg = differing\n        diffMsg = '\\n' + '\\n'.join(\n            difflib.ndiff(pprint.pformat(seq1).splitlines(),\n                          pprint.pformat(seq2).splitlines()))\n\n        standardMsg = self._truncateMessage(standardMsg, diffMsg)\n        msg = self._formatMessage(msg, standardMsg)\n        self.fail(msg)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.DecodingEdgeCasesTest.assertSetEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, set1, set2, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "set1": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "set2": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "A set-specific equality assertion.\n\nArgs:\n    set1: The first set to compare.\n    set2: The second set to compare.\n    msg: Optional message to use on failure instead of a list of\n            differences.\n\nassertSetEqual uses ducktyping to support different types of sets, and\nis optimized for sets specifically (parameters must support a\ndifference method).",
      "source_code": "    def assertSetEqual(self, set1, set2, msg=None):\n        \"\"\"A set-specific equality assertion.\n\n        Args:\n            set1: The first set to compare.\n            set2: The second set to compare.\n            msg: Optional message to use on failure instead of a list of\n                    differences.\n\n        assertSetEqual uses ducktyping to support different types of sets, and\n        is optimized for sets specifically (parameters must support a\n        difference method).\n        \"\"\"\n        try:\n            difference1 = set1.difference(set2)\n        except TypeError as e:\n            self.fail('invalid type when attempting set difference: %s' % e)\n        except AttributeError as e:\n            self.fail('first argument does not support set difference: %s' % e)\n\n        try:\n            difference2 = set2.difference(set1)\n        except TypeError as e:\n            self.fail('invalid type when attempting set difference: %s' % e)\n        except AttributeError as e:\n            self.fail('second argument does not support set difference: %s' % e)\n\n        if not (difference1 or difference2):\n            return\n\n        lines = []\n        if difference1:\n            lines.append('Items in the first set but not the second:')\n            for item in difference1:\n                lines.append(repr(item))\n        if difference2:\n            lines.append('Items in the second set but not the first:')\n            for item in difference2:\n                lines.append(repr(item))\n\n        standardMsg = '\\n'.join(lines)\n        self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.DecodingEdgeCasesTest.assertTrue",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, expr, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "expr": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Check that the expression is true.",
      "source_code": "    def assertTrue(self, expr, msg=None):\n        \"\"\"Check that the expression is true.\"\"\"\n        if not expr:\n            msg = self._formatMessage(msg, \"%s is not true\" % safe_repr(expr))\n            raise self.failureException(msg)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.DecodingEdgeCasesTest.assertTupleEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, tuple1, tuple2, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "tuple1": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "tuple2": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "A tuple-specific equality assertion.\n\nArgs:\n    tuple1: The first tuple to compare.\n    tuple2: The second tuple to compare.\n    msg: Optional message to use on failure instead of a list of\n            differences.",
      "source_code": "    def assertTupleEqual(self, tuple1, tuple2, msg=None):\n        \"\"\"A tuple-specific equality assertion.\n\n        Args:\n            tuple1: The first tuple to compare.\n            tuple2: The second tuple to compare.\n            msg: Optional message to use on failure instead of a list of\n                    differences.\n        \"\"\"\n        self.assertSequenceEqual(tuple1, tuple2, msg, seq_type=tuple)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.DecodingEdgeCasesTest.assertWarns",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, expected_warning, *args, **kwargs)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "expected_warning": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Fail unless a warning of class warnClass is triggered\nby the callable when invoked with specified positional and\nkeyword arguments.  If a different type of warning is\ntriggered, it will not be handled: depending on the other\nwarning filtering rules in effect, it might be silenced, printed\nout, or raised as an exception.\n\nIf called with the callable and arguments omitted, will return a\ncontext object used like this::\n\n     with self.assertWarns(SomeWarning):\n         do_something()\n\nAn optional keyword argument 'msg' can be provided when assertWarns\nis used as a context object.\n\nThe context manager keeps a reference to the first matching\nwarning as the 'warning' attribute; similarly, the 'filename'\nand 'lineno' attributes give you information about the line\nof Python code from which the warning was triggered.\nThis allows you to inspect the warning after the assertion::\n\n    with self.assertWarns(SomeWarning) as cm:\n        do_something()\n    the_warning = cm.warning\n    self.assertEqual(the_warning.some_attribute, 147)",
      "source_code": "    def assertWarns(self, expected_warning, *args, **kwargs):\n        \"\"\"Fail unless a warning of class warnClass is triggered\n           by the callable when invoked with specified positional and\n           keyword arguments.  If a different type of warning is\n           triggered, it will not be handled: depending on the other\n           warning filtering rules in effect, it might be silenced, printed\n           out, or raised as an exception.\n\n           If called with the callable and arguments omitted, will return a\n           context object used like this::\n\n                with self.assertWarns(SomeWarning):\n                    do_something()\n\n           An optional keyword argument 'msg' can be provided when assertWarns\n           is used as a context object.\n\n           The context manager keeps a reference to the first matching\n           warning as the 'warning' attribute; similarly, the 'filename'\n           and 'lineno' attributes give you information about the line\n           of Python code from which the warning was triggered.\n           This allows you to inspect the warning after the assertion::\n\n               with self.assertWarns(SomeWarning) as cm:\n                   do_something()\n               the_warning = cm.warning\n               self.assertEqual(the_warning.some_attribute, 147)\n        \"\"\"\n        context = _AssertWarnsContext(expected_warning, self)\n        return context.handle('assertWarns', args, kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.DecodingEdgeCasesTest.assertWarnsRegex",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, expected_warning, expected_regex, *args, **kwargs)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "expected_warning": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "expected_regex": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Asserts that the message in a triggered warning matches a regexp.\nBasic functioning is similar to assertWarns() with the addition\nthat only warnings whose messages also match the regular expression\nare considered successful matches.\n\nArgs:\n    expected_warning: Warning class expected to be triggered.\n    expected_regex: Regex (re.Pattern object or string) expected\n            to be found in error message.\n    args: Function to be called and extra positional args.\n    kwargs: Extra kwargs.\n    msg: Optional message used in case of failure. Can only be used\n            when assertWarnsRegex is used as a context manager.",
      "source_code": "    def assertWarnsRegex(self, expected_warning, expected_regex,\n                         *args, **kwargs):\n        \"\"\"Asserts that the message in a triggered warning matches a regexp.\n        Basic functioning is similar to assertWarns() with the addition\n        that only warnings whose messages also match the regular expression\n        are considered successful matches.\n\n        Args:\n            expected_warning: Warning class expected to be triggered.\n            expected_regex: Regex (re.Pattern object or string) expected\n                    to be found in error message.\n            args: Function to be called and extra positional args.\n            kwargs: Extra kwargs.\n            msg: Optional message used in case of failure. Can only be used\n                    when assertWarnsRegex is used as a context manager.\n        \"\"\"\n        context = _AssertWarnsContext(expected_warning, self, expected_regex)\n        return context.handle('assertWarnsRegex', args, kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.DecodingEdgeCasesTest.assert_",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.DecodingEdgeCasesTest.countTestCases",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def countTestCases(self):\n        return 1\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.DecodingEdgeCasesTest.debug",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Run the test without collecting errors in a TestResult",
      "source_code": "    def debug(self):\n        \"\"\"Run the test without collecting errors in a TestResult\"\"\"\n        testMethod = getattr(self, self._testMethodName)\n        if (getattr(self.__class__, \"__unittest_skip__\", False) or\n            getattr(testMethod, \"__unittest_skip__\", False)):\n            # If the class or method was skipped.\n            skip_why = (getattr(self.__class__, '__unittest_skip_why__', '')\n                        or getattr(testMethod, '__unittest_skip_why__', ''))\n            raise SkipTest(skip_why)\n\n        self._callSetUp()\n        self._callTestMethod(testMethod)\n        self._callTearDown()\n        while self._cleanups:\n            function, args, kwargs = self._cleanups.pop()\n            self._callCleanup(function, *args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.DecodingEdgeCasesTest.defaultTestResult",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def defaultTestResult(self):\n        return result.TestResult()\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.DecodingEdgeCasesTest.doCleanups",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Execute all cleanup functions. Normally called for you after\ntearDown.",
      "source_code": "    def doCleanups(self):\n        \"\"\"Execute all cleanup functions. Normally called for you after\n        tearDown.\"\"\"\n        outcome = self._outcome or _Outcome()\n        while self._cleanups:\n            function, args, kwargs = self._cleanups.pop()\n            with outcome.testPartExecutor(self):\n                self._callCleanup(function, *args, **kwargs)\n\n        # return this for backwards compatibility\n        # even though we no longer use it internally\n        return outcome.success\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.DecodingEdgeCasesTest.fail",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Fail immediately, with the given message.",
      "source_code": "    def fail(self, msg=None):\n        \"\"\"Fail immediately, with the given message.\"\"\"\n        raise self.failureException(msg)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.DecodingEdgeCasesTest.failIf",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.DecodingEdgeCasesTest.failIfAlmostEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.DecodingEdgeCasesTest.failIfEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.DecodingEdgeCasesTest.failUnless",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.DecodingEdgeCasesTest.failUnlessAlmostEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.DecodingEdgeCasesTest.failUnlessEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.DecodingEdgeCasesTest.failUnlessRaises",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.DecodingEdgeCasesTest.id",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def id(self):\n        return \"%s.%s\" % (strclass(self.__class__), self._testMethodName)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.DecodingEdgeCasesTest.run",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, result=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "result": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def run(self, result=None):\n        if result is None:\n            result = self.defaultTestResult()\n            startTestRun = getattr(result, 'startTestRun', None)\n            stopTestRun = getattr(result, 'stopTestRun', None)\n            if startTestRun is not None:\n                startTestRun()\n        else:\n            stopTestRun = None\n\n        result.startTest(self)\n        try:\n            testMethod = getattr(self, self._testMethodName)\n            if (getattr(self.__class__, \"__unittest_skip__\", False) or\n                getattr(testMethod, \"__unittest_skip__\", False)):\n                # If the class or method was skipped.\n                skip_why = (getattr(self.__class__, '__unittest_skip_why__', '')\n                            or getattr(testMethod, '__unittest_skip_why__', ''))\n                self._addSkip(result, self, skip_why)\n                return result\n\n            expecting_failure = (\n                getattr(self, \"__unittest_expecting_failure__\", False) or\n                getattr(testMethod, \"__unittest_expecting_failure__\", False)\n            )\n            outcome = _Outcome(result)\n            try:\n                self._outcome = outcome\n\n                with outcome.testPartExecutor(self):\n                    self._callSetUp()\n                if outcome.success:\n                    outcome.expecting_failure = expecting_failure\n                    with outcome.testPartExecutor(self, isTest=True):\n                        self._callTestMethod(testMethod)\n                    outcome.expecting_failure = False\n                    with outcome.testPartExecutor(self):\n                        self._callTearDown()\n\n                self.doCleanups()\n                for test, reason in outcome.skipped:\n                    self._addSkip(result, test, reason)\n                self._feedErrorsToResult(result, outcome.errors)\n                if outcome.success:\n                    if expecting_failure:\n                        if outcome.expectedFailure:\n                            self._addExpectedFailure(result, outcome.expectedFailure)\n                        else:\n                            self._addUnexpectedSuccess(result)\n                    else:\n                        result.addSuccess(self)\n                return result\n            finally:\n                # explicitly break reference cycles:\n                # outcome.errors -> frame -> outcome -> outcome.errors\n                # outcome.expectedFailure -> frame -> outcome -> outcome.expectedFailure\n                outcome.errors.clear()\n                outcome.expectedFailure = None\n\n                # clear the outcome, no more needed\n                self._outcome = None\n\n        finally:\n            result.stopTest(self)\n            if stopTestRun is not None:\n                stopTestRun()\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.DecodingEdgeCasesTest.setUp",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Hook method for setting up the test fixture before exercising it.",
      "source_code": "    def setUp(self):\n        \"Hook method for setting up the test fixture before exercising it.\"\n        pass\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.DecodingEdgeCasesTest.shortDescription",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Returns a one-line description of the test, or None if no\ndescription has been provided.\n\nThe default implementation of this method returns the first line of\nthe specified test method's docstring.",
      "source_code": "    def shortDescription(self):\n        \"\"\"Returns a one-line description of the test, or None if no\n        description has been provided.\n\n        The default implementation of this method returns the first line of\n        the specified test method's docstring.\n        \"\"\"\n        doc = self._testMethodDoc\n        return doc.strip().split(\"\\n\")[0].strip() if doc else None\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.DecodingEdgeCasesTest.skipTest",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, reason)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "reason": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Skip this test.",
      "source_code": "    def skipTest(self, reason):\n        \"\"\"Skip this test.\"\"\"\n        raise SkipTest(reason)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.DecodingEdgeCasesTest.subTest",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, msg=<object object at 0x7e3e03b88ce0>, **params)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "<object object at 0x7e3e03b88ce0>",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "params": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [
        "contextlib.contextmanager"
      ],
      "examples": [],
      "docstring": "Return a context manager that will return the enclosed block\nof code in a subtest identified by the optional message and\nkeyword parameters.  A failure in the subtest marks the test\ncase as failed but resumes execution at the end of the enclosed\nblock, allowing further test code to be executed.",
      "source_code": "    @contextlib.contextmanager\n    def subTest(self, msg=_subtest_msg_sentinel, **params):\n        \"\"\"Return a context manager that will return the enclosed block\n        of code in a subtest identified by the optional message and\n        keyword parameters.  A failure in the subtest marks the test\n        case as failed but resumes execution at the end of the enclosed\n        block, allowing further test code to be executed.\n        \"\"\"\n        if self._outcome is None or not self._outcome.result_supports_subtests:\n            yield\n            return\n        parent = self._subtest\n        if parent is None:\n            params_map = _OrderedChainMap(params)\n        else:\n            params_map = parent.params.new_child(params)\n        self._subtest = _SubTest(self, msg, params_map)\n        try:\n            with self._outcome.testPartExecutor(self._subtest, isTest=True):\n                yield\n            if not self._outcome.success:\n                result = self._outcome.result\n                if result is not None and result.failfast:\n                    raise _ShouldStop\n            elif self._outcome.expectedFailure:\n                # If the test is expecting a failure, we really want to\n                # stop now and register the expected failure.\n                raise _ShouldStop\n        finally:\n            self._subtest = parent\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.DecodingEdgeCasesTest.tearDown",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Hook method for deconstructing the test fixture after testing it.",
      "source_code": "    def tearDown(self):\n        \"Hook method for deconstructing the test fixture after testing it.\"\n        pass\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.DecodingEdgeCasesTest.test_decode_dict",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def test_decode_dict(self):\n        su = ShortUUID()\n        self.assertRaises(ValueError, su.decode, [])\n        self.assertRaises(ValueError, su.decode, {})\n        self.assertRaises(ValueError, su.decode, (2,))\n        self.assertRaises(ValueError, su.decode, 42)\n        self.assertRaises(ValueError, su.decode, 42.0)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.EncodingEdgeCasesTest.addCleanup",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, function, /, *args, **kwargs)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_ONLY",
          "description": null
        },
        "function": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_ONLY",
          "description": null
        },
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Add a function, with arguments, to be called when the test is\ncompleted. Functions added are called on a LIFO basis and are\ncalled after tearDown on test failure or success.\n\nCleanup items are called even if setUp fails (unlike tearDown).",
      "source_code": "    def addCleanup(self, function, /, *args, **kwargs):\n        \"\"\"Add a function, with arguments, to be called when the test is\n        completed. Functions added are called on a LIFO basis and are\n        called after tearDown on test failure or success.\n\n        Cleanup items are called even if setUp fails (unlike tearDown).\"\"\"\n        self._cleanups.append((function, args, kwargs))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.EncodingEdgeCasesTest.addTypeEqualityFunc",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, typeobj, function)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "typeobj": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "function": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Add a type specific assertEqual style function to compare a type.\n\nThis method is for use by TestCase subclasses that need to register\ntheir own type equality functions to provide nicer error messages.\n\nArgs:\n    typeobj: The data type to call this function on when both values\n            are of the same type in assertEqual().\n    function: The callable taking two arguments and an optional\n            msg= argument that raises self.failureException with a\n            useful error message when the two arguments are not equal.",
      "source_code": "    def addTypeEqualityFunc(self, typeobj, function):\n        \"\"\"Add a type specific assertEqual style function to compare a type.\n\n        This method is for use by TestCase subclasses that need to register\n        their own type equality functions to provide nicer error messages.\n\n        Args:\n            typeobj: The data type to call this function on when both values\n                    are of the same type in assertEqual().\n            function: The callable taking two arguments and an optional\n                    msg= argument that raises self.failureException with a\n                    useful error message when the two arguments are not equal.\n        \"\"\"\n        self._type_equality_funcs[typeobj] = function\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.EncodingEdgeCasesTest.assertAlmostEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, first, second, places=None, msg=None, delta=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "first": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "second": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "places": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "delta": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Fail if the two objects are unequal as determined by their\ndifference rounded to the given number of decimal places\n(default 7) and comparing to zero, or by comparing that the\ndifference between the two objects is more than the given\ndelta.\n\nNote that decimal places (from zero) are usually not the same\nas significant digits (measured from the most significant digit).\n\nIf the two objects compare equal then they will automatically\ncompare almost equal.",
      "source_code": "    def assertAlmostEqual(self, first, second, places=None, msg=None,\n                          delta=None):\n        \"\"\"Fail if the two objects are unequal as determined by their\n           difference rounded to the given number of decimal places\n           (default 7) and comparing to zero, or by comparing that the\n           difference between the two objects is more than the given\n           delta.\n\n           Note that decimal places (from zero) are usually not the same\n           as significant digits (measured from the most significant digit).\n\n           If the two objects compare equal then they will automatically\n           compare almost equal.\n        \"\"\"\n        if first == second:\n            # shortcut\n            return\n        if delta is not None and places is not None:\n            raise TypeError(\"specify delta or places not both\")\n\n        diff = abs(first - second)\n        if delta is not None:\n            if diff <= delta:\n                return\n\n            standardMsg = '%s != %s within %s delta (%s difference)' % (\n                safe_repr(first),\n                safe_repr(second),\n                safe_repr(delta),\n                safe_repr(diff))\n        else:\n            if places is None:\n                places = 7\n\n            if round(diff, places) == 0:\n                return\n\n            standardMsg = '%s != %s within %r places (%s difference)' % (\n                safe_repr(first),\n                safe_repr(second),\n                places,\n                safe_repr(diff))\n        msg = self._formatMessage(msg, standardMsg)\n        raise self.failureException(msg)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.EncodingEdgeCasesTest.assertAlmostEquals",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.EncodingEdgeCasesTest.assertCountEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, first, second, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "first": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "second": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Asserts that two iterables have the same elements, the same number of\ntimes, without regard to order.\n\n    self.assertEqual(Counter(list(first)),\n                     Counter(list(second)))\n\n Example:\n    - [0, 1, 1] and [1, 0, 1] compare equal.\n    - [0, 0, 1] and [0, 1] compare unequal.",
      "source_code": "    def assertCountEqual(self, first, second, msg=None):\n        \"\"\"Asserts that two iterables have the same elements, the same number of\n        times, without regard to order.\n\n            self.assertEqual(Counter(list(first)),\n                             Counter(list(second)))\n\n         Example:\n            - [0, 1, 1] and [1, 0, 1] compare equal.\n            - [0, 0, 1] and [0, 1] compare unequal.\n\n        \"\"\"\n        first_seq, second_seq = list(first), list(second)\n        try:\n            first = collections.Counter(first_seq)\n            second = collections.Counter(second_seq)\n        except TypeError:\n            # Handle case with unhashable elements\n            differences = _count_diff_all_purpose(first_seq, second_seq)\n        else:\n            if first == second:\n                return\n            differences = _count_diff_hashable(first_seq, second_seq)\n\n        if differences:\n            standardMsg = 'Element counts were not equal:\\n'\n            lines = ['First has %d, Second has %d:  %r' % diff for diff in differences]\n            diffMsg = '\\n'.join(lines)\n            standardMsg = self._truncateMessage(standardMsg, diffMsg)\n            msg = self._formatMessage(msg, standardMsg)\n            self.fail(msg)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.EncodingEdgeCasesTest.assertDictContainsSubset",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, subset, dictionary, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "subset": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "dictionary": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Checks whether dictionary is a superset of subset.",
      "source_code": "    def assertDictContainsSubset(self, subset, dictionary, msg=None):\n        \"\"\"Checks whether dictionary is a superset of subset.\"\"\"\n        warnings.warn('assertDictContainsSubset is deprecated',\n                      DeprecationWarning,\n                      stacklevel=2)\n        missing = []\n        mismatched = []\n        for key, value in subset.items():\n            if key not in dictionary:\n                missing.append(key)\n            elif value != dictionary[key]:\n                mismatched.append('%s, expected: %s, actual: %s' %\n                                  (safe_repr(key), safe_repr(value),\n                                   safe_repr(dictionary[key])))\n\n        if not (missing or mismatched):\n            return\n\n        standardMsg = ''\n        if missing:\n            standardMsg = 'Missing: %s' % ','.join(safe_repr(m) for m in\n                                                    missing)\n        if mismatched:\n            if standardMsg:\n                standardMsg += '; '\n            standardMsg += 'Mismatched values: %s' % ','.join(mismatched)\n\n        self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.EncodingEdgeCasesTest.assertDictEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, d1, d2, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "d1": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "d2": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def assertDictEqual(self, d1, d2, msg=None):\n        self.assertIsInstance(d1, dict, 'First argument is not a dictionary')\n        self.assertIsInstance(d2, dict, 'Second argument is not a dictionary')\n\n        if d1 != d2:\n            standardMsg = '%s != %s' % _common_shorten_repr(d1, d2)\n            diff = ('\\n' + '\\n'.join(difflib.ndiff(\n                           pprint.pformat(d1).splitlines(),\n                           pprint.pformat(d2).splitlines())))\n            standardMsg = self._truncateMessage(standardMsg, diff)\n            self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.EncodingEdgeCasesTest.assertEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, first, second, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "first": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "second": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Fail if the two objects are unequal as determined by the '=='\noperator.",
      "source_code": "    def assertEqual(self, first, second, msg=None):\n        \"\"\"Fail if the two objects are unequal as determined by the '=='\n           operator.\n        \"\"\"\n        assertion_func = self._getAssertEqualityFunc(first, second)\n        assertion_func(first, second, msg=msg)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.EncodingEdgeCasesTest.assertEquals",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.EncodingEdgeCasesTest.assertFalse",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, expr, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "expr": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Check that the expression is false.",
      "source_code": "    def assertFalse(self, expr, msg=None):\n        \"\"\"Check that the expression is false.\"\"\"\n        if expr:\n            msg = self._formatMessage(msg, \"%s is not false\" % safe_repr(expr))\n            raise self.failureException(msg)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.EncodingEdgeCasesTest.assertGreater",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, a, b, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "a": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "b": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Just like self.assertTrue(a > b), but with a nicer default message.",
      "source_code": "    def assertGreater(self, a, b, msg=None):\n        \"\"\"Just like self.assertTrue(a > b), but with a nicer default message.\"\"\"\n        if not a > b:\n            standardMsg = '%s not greater than %s' % (safe_repr(a), safe_repr(b))\n            self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.EncodingEdgeCasesTest.assertGreaterEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, a, b, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "a": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "b": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Just like self.assertTrue(a >= b), but with a nicer default message.",
      "source_code": "    def assertGreaterEqual(self, a, b, msg=None):\n        \"\"\"Just like self.assertTrue(a >= b), but with a nicer default message.\"\"\"\n        if not a >= b:\n            standardMsg = '%s not greater than or equal to %s' % (safe_repr(a), safe_repr(b))\n            self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.EncodingEdgeCasesTest.assertIn",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, member, container, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "member": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "container": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Just like self.assertTrue(a in b), but with a nicer default message.",
      "source_code": "    def assertIn(self, member, container, msg=None):\n        \"\"\"Just like self.assertTrue(a in b), but with a nicer default message.\"\"\"\n        if member not in container:\n            standardMsg = '%s not found in %s' % (safe_repr(member),\n                                                  safe_repr(container))\n            self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.EncodingEdgeCasesTest.assertIs",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, expr1, expr2, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "expr1": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "expr2": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Just like self.assertTrue(a is b), but with a nicer default message.",
      "source_code": "    def assertIs(self, expr1, expr2, msg=None):\n        \"\"\"Just like self.assertTrue(a is b), but with a nicer default message.\"\"\"\n        if expr1 is not expr2:\n            standardMsg = '%s is not %s' % (safe_repr(expr1),\n                                             safe_repr(expr2))\n            self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.EncodingEdgeCasesTest.assertIsInstance",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, obj, cls, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "obj": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "cls": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Same as self.assertTrue(isinstance(obj, cls)), with a nicer\ndefault message.",
      "source_code": "    def assertIsInstance(self, obj, cls, msg=None):\n        \"\"\"Same as self.assertTrue(isinstance(obj, cls)), with a nicer\n        default message.\"\"\"\n        if not isinstance(obj, cls):\n            standardMsg = '%s is not an instance of %r' % (safe_repr(obj), cls)\n            self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.EncodingEdgeCasesTest.assertIsNone",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, obj, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "obj": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Same as self.assertTrue(obj is None), with a nicer default message.",
      "source_code": "    def assertIsNone(self, obj, msg=None):\n        \"\"\"Same as self.assertTrue(obj is None), with a nicer default message.\"\"\"\n        if obj is not None:\n            standardMsg = '%s is not None' % (safe_repr(obj),)\n            self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.EncodingEdgeCasesTest.assertIsNot",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, expr1, expr2, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "expr1": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "expr2": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Just like self.assertTrue(a is not b), but with a nicer default message.",
      "source_code": "    def assertIsNot(self, expr1, expr2, msg=None):\n        \"\"\"Just like self.assertTrue(a is not b), but with a nicer default message.\"\"\"\n        if expr1 is expr2:\n            standardMsg = 'unexpectedly identical: %s' % (safe_repr(expr1),)\n            self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.EncodingEdgeCasesTest.assertIsNotNone",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, obj, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "obj": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Included for symmetry with assertIsNone.",
      "source_code": "    def assertIsNotNone(self, obj, msg=None):\n        \"\"\"Included for symmetry with assertIsNone.\"\"\"\n        if obj is None:\n            standardMsg = 'unexpectedly None'\n            self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.EncodingEdgeCasesTest.assertLess",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, a, b, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "a": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "b": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Just like self.assertTrue(a < b), but with a nicer default message.",
      "source_code": "    def assertLess(self, a, b, msg=None):\n        \"\"\"Just like self.assertTrue(a < b), but with a nicer default message.\"\"\"\n        if not a < b:\n            standardMsg = '%s not less than %s' % (safe_repr(a), safe_repr(b))\n            self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.EncodingEdgeCasesTest.assertLessEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, a, b, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "a": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "b": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Just like self.assertTrue(a <= b), but with a nicer default message.",
      "source_code": "    def assertLessEqual(self, a, b, msg=None):\n        \"\"\"Just like self.assertTrue(a <= b), but with a nicer default message.\"\"\"\n        if not a <= b:\n            standardMsg = '%s not less than or equal to %s' % (safe_repr(a), safe_repr(b))\n            self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.EncodingEdgeCasesTest.assertListEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, list1, list2, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "list1": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "list2": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "A list-specific equality assertion.\n\nArgs:\n    list1: The first list to compare.\n    list2: The second list to compare.\n    msg: Optional message to use on failure instead of a list of\n            differences.",
      "source_code": "    def assertListEqual(self, list1, list2, msg=None):\n        \"\"\"A list-specific equality assertion.\n\n        Args:\n            list1: The first list to compare.\n            list2: The second list to compare.\n            msg: Optional message to use on failure instead of a list of\n                    differences.\n\n        \"\"\"\n        self.assertSequenceEqual(list1, list2, msg, seq_type=list)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.EncodingEdgeCasesTest.assertLogs",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, logger=None, level=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "logger": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "level": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Fail unless a log message of level *level* or higher is emitted\non *logger_name* or its children.  If omitted, *level* defaults to\nINFO and *logger* defaults to the root logger.\n\nThis method must be used as a context manager, and will yield\na recording object with two attributes: `output` and `records`.\nAt the end of the context manager, the `output` attribute will\nbe a list of the matching formatted log messages and the\n`records` attribute will be a list of the corresponding LogRecord\nobjects.\n\nExample::\n\n    with self.assertLogs('foo', level='INFO') as cm:\n        logging.getLogger('foo').info('first message')\n        logging.getLogger('foo.bar').error('second message')\n    self.assertEqual(cm.output, ['INFO:foo:first message',\n                                 'ERROR:foo.bar:second message'])",
      "source_code": "    def assertLogs(self, logger=None, level=None):\n        \"\"\"Fail unless a log message of level *level* or higher is emitted\n        on *logger_name* or its children.  If omitted, *level* defaults to\n        INFO and *logger* defaults to the root logger.\n\n        This method must be used as a context manager, and will yield\n        a recording object with two attributes: `output` and `records`.\n        At the end of the context manager, the `output` attribute will\n        be a list of the matching formatted log messages and the\n        `records` attribute will be a list of the corresponding LogRecord\n        objects.\n\n        Example::\n\n            with self.assertLogs('foo', level='INFO') as cm:\n                logging.getLogger('foo').info('first message')\n                logging.getLogger('foo.bar').error('second message')\n            self.assertEqual(cm.output, ['INFO:foo:first message',\n                                         'ERROR:foo.bar:second message'])\n        \"\"\"\n        # Lazy import to avoid importing logging if it is not needed.\n        from ._log import _AssertLogsContext\n        return _AssertLogsContext(self, logger, level, no_logs=False)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.EncodingEdgeCasesTest.assertMultiLineEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, first, second, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "first": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "second": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Assert that two multi-line strings are equal.",
      "source_code": "    def assertMultiLineEqual(self, first, second, msg=None):\n        \"\"\"Assert that two multi-line strings are equal.\"\"\"\n        self.assertIsInstance(first, str, 'First argument is not a string')\n        self.assertIsInstance(second, str, 'Second argument is not a string')\n\n        if first != second:\n            # don't use difflib if the strings are too long\n            if (len(first) > self._diffThreshold or\n                len(second) > self._diffThreshold):\n                self._baseAssertEqual(first, second, msg)\n            firstlines = first.splitlines(keepends=True)\n            secondlines = second.splitlines(keepends=True)\n            if len(firstlines) == 1 and first.strip('\\r\\n') == first:\n                firstlines = [first + '\\n']\n                secondlines = [second + '\\n']\n            standardMsg = '%s != %s' % _common_shorten_repr(first, second)\n            diff = '\\n' + ''.join(difflib.ndiff(firstlines, secondlines))\n            standardMsg = self._truncateMessage(standardMsg, diff)\n            self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.EncodingEdgeCasesTest.assertNoLogs",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, logger=None, level=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "logger": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "level": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Fail unless no log messages of level *level* or higher are emitted\non *logger_name* or its children.\n\nThis method must be used as a context manager.",
      "source_code": "    def assertNoLogs(self, logger=None, level=None):\n        \"\"\" Fail unless no log messages of level *level* or higher are emitted\n        on *logger_name* or its children.\n\n        This method must be used as a context manager.\n        \"\"\"\n        from ._log import _AssertLogsContext\n        return _AssertLogsContext(self, logger, level, no_logs=True)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.EncodingEdgeCasesTest.assertNotAlmostEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, first, second, places=None, msg=None, delta=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "first": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "second": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "places": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "delta": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Fail if the two objects are equal as determined by their\ndifference rounded to the given number of decimal places\n(default 7) and comparing to zero, or by comparing that the\ndifference between the two objects is less than the given delta.\n\nNote that decimal places (from zero) are usually not the same\nas significant digits (measured from the most significant digit).\n\nObjects that are equal automatically fail.",
      "source_code": "    def assertNotAlmostEqual(self, first, second, places=None, msg=None,\n                             delta=None):\n        \"\"\"Fail if the two objects are equal as determined by their\n           difference rounded to the given number of decimal places\n           (default 7) and comparing to zero, or by comparing that the\n           difference between the two objects is less than the given delta.\n\n           Note that decimal places (from zero) are usually not the same\n           as significant digits (measured from the most significant digit).\n\n           Objects that are equal automatically fail.\n        \"\"\"\n        if delta is not None and places is not None:\n            raise TypeError(\"specify delta or places not both\")\n        diff = abs(first - second)\n        if delta is not None:\n            if not (first == second) and diff > delta:\n                return\n            standardMsg = '%s == %s within %s delta (%s difference)' % (\n                safe_repr(first),\n                safe_repr(second),\n                safe_repr(delta),\n                safe_repr(diff))\n        else:\n            if places is None:\n                places = 7\n            if not (first == second) and round(diff, places) != 0:\n                return\n            standardMsg = '%s == %s within %r places' % (safe_repr(first),\n                                                         safe_repr(second),\n                                                         places)\n\n        msg = self._formatMessage(msg, standardMsg)\n        raise self.failureException(msg)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.EncodingEdgeCasesTest.assertNotAlmostEquals",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.EncodingEdgeCasesTest.assertNotEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, first, second, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "first": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "second": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Fail if the two objects are equal as determined by the '!='\noperator.",
      "source_code": "    def assertNotEqual(self, first, second, msg=None):\n        \"\"\"Fail if the two objects are equal as determined by the '!='\n           operator.\n        \"\"\"\n        if not first != second:\n            msg = self._formatMessage(msg, '%s == %s' % (safe_repr(first),\n                                                          safe_repr(second)))\n            raise self.failureException(msg)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.EncodingEdgeCasesTest.assertNotEquals",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.EncodingEdgeCasesTest.assertNotIn",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, member, container, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "member": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "container": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Just like self.assertTrue(a not in b), but with a nicer default message.",
      "source_code": "    def assertNotIn(self, member, container, msg=None):\n        \"\"\"Just like self.assertTrue(a not in b), but with a nicer default message.\"\"\"\n        if member in container:\n            standardMsg = '%s unexpectedly found in %s' % (safe_repr(member),\n                                                        safe_repr(container))\n            self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.EncodingEdgeCasesTest.assertNotIsInstance",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, obj, cls, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "obj": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "cls": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Included for symmetry with assertIsInstance.",
      "source_code": "    def assertNotIsInstance(self, obj, cls, msg=None):\n        \"\"\"Included for symmetry with assertIsInstance.\"\"\"\n        if isinstance(obj, cls):\n            standardMsg = '%s is an instance of %r' % (safe_repr(obj), cls)\n            self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.EncodingEdgeCasesTest.assertNotRegex",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, text, unexpected_regex, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "text": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "unexpected_regex": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Fail the test if the text matches the regular expression.",
      "source_code": "    def assertNotRegex(self, text, unexpected_regex, msg=None):\n        \"\"\"Fail the test if the text matches the regular expression.\"\"\"\n        if isinstance(unexpected_regex, (str, bytes)):\n            unexpected_regex = re.compile(unexpected_regex)\n        match = unexpected_regex.search(text)\n        if match:\n            standardMsg = 'Regex matched: %r matches %r in %r' % (\n                text[match.start() : match.end()],\n                unexpected_regex.pattern,\n                text)\n            # _formatMessage ensures the longMessage option is respected\n            msg = self._formatMessage(msg, standardMsg)\n            raise self.failureException(msg)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.EncodingEdgeCasesTest.assertNotRegexpMatches",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.EncodingEdgeCasesTest.assertRaises",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, expected_exception, *args, **kwargs)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "expected_exception": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Fail unless an exception of class expected_exception is raised\nby the callable when invoked with specified positional and\nkeyword arguments. If a different type of exception is\nraised, it will not be caught, and the test case will be\ndeemed to have suffered an error, exactly as for an\nunexpected exception.\n\nIf called with the callable and arguments omitted, will return a\ncontext object used like this::\n\n     with self.assertRaises(SomeException):\n         do_something()\n\nAn optional keyword argument 'msg' can be provided when assertRaises\nis used as a context object.\n\nThe context manager keeps a reference to the exception as\nthe 'exception' attribute. This allows you to inspect the\nexception after the assertion::\n\n    with self.assertRaises(SomeException) as cm:\n        do_something()\n    the_exception = cm.exception\n    self.assertEqual(the_exception.error_code, 3)",
      "source_code": "    def assertRaises(self, expected_exception, *args, **kwargs):\n        \"\"\"Fail unless an exception of class expected_exception is raised\n           by the callable when invoked with specified positional and\n           keyword arguments. If a different type of exception is\n           raised, it will not be caught, and the test case will be\n           deemed to have suffered an error, exactly as for an\n           unexpected exception.\n\n           If called with the callable and arguments omitted, will return a\n           context object used like this::\n\n                with self.assertRaises(SomeException):\n                    do_something()\n\n           An optional keyword argument 'msg' can be provided when assertRaises\n           is used as a context object.\n\n           The context manager keeps a reference to the exception as\n           the 'exception' attribute. This allows you to inspect the\n           exception after the assertion::\n\n               with self.assertRaises(SomeException) as cm:\n                   do_something()\n               the_exception = cm.exception\n               self.assertEqual(the_exception.error_code, 3)\n        \"\"\"\n        context = _AssertRaisesContext(expected_exception, self)\n        try:\n            return context.handle('assertRaises', args, kwargs)\n        finally:\n            # bpo-23890: manually break a reference cycle\n            context = None\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.EncodingEdgeCasesTest.assertRaisesRegex",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, expected_exception, expected_regex, *args, **kwargs)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "expected_exception": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "expected_regex": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Asserts that the message in a raised exception matches a regex.\n\nArgs:\n    expected_exception: Exception class expected to be raised.\n    expected_regex: Regex (re.Pattern object or string) expected\n            to be found in error message.\n    args: Function to be called and extra positional args.\n    kwargs: Extra kwargs.\n    msg: Optional message used in case of failure. Can only be used\n            when assertRaisesRegex is used as a context manager.",
      "source_code": "    def assertRaisesRegex(self, expected_exception, expected_regex,\n                          *args, **kwargs):\n        \"\"\"Asserts that the message in a raised exception matches a regex.\n\n        Args:\n            expected_exception: Exception class expected to be raised.\n            expected_regex: Regex (re.Pattern object or string) expected\n                    to be found in error message.\n            args: Function to be called and extra positional args.\n            kwargs: Extra kwargs.\n            msg: Optional message used in case of failure. Can only be used\n                    when assertRaisesRegex is used as a context manager.\n        \"\"\"\n        context = _AssertRaisesContext(expected_exception, self, expected_regex)\n        return context.handle('assertRaisesRegex', args, kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.EncodingEdgeCasesTest.assertRaisesRegexp",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.EncodingEdgeCasesTest.assertRegex",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, text, expected_regex, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "text": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "expected_regex": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Fail the test unless the text matches the regular expression.",
      "source_code": "    def assertRegex(self, text, expected_regex, msg=None):\n        \"\"\"Fail the test unless the text matches the regular expression.\"\"\"\n        if isinstance(expected_regex, (str, bytes)):\n            assert expected_regex, \"expected_regex must not be empty.\"\n            expected_regex = re.compile(expected_regex)\n        if not expected_regex.search(text):\n            standardMsg = \"Regex didn't match: %r not found in %r\" % (\n                expected_regex.pattern, text)\n            # _formatMessage ensures the longMessage option is respected\n            msg = self._formatMessage(msg, standardMsg)\n            raise self.failureException(msg)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.EncodingEdgeCasesTest.assertRegexpMatches",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.EncodingEdgeCasesTest.assertSequenceEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, seq1, seq2, msg=None, seq_type=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "seq1": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "seq2": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "seq_type": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "An equality assertion for ordered sequences (like lists and tuples).\n\nFor the purposes of this function, a valid ordered sequence type is one\nwhich can be indexed, has a length, and has an equality operator.\n\nArgs:\n    seq1: The first sequence to compare.\n    seq2: The second sequence to compare.\n    seq_type: The expected datatype of the sequences, or None if no\n            datatype should be enforced.\n    msg: Optional message to use on failure instead of a list of\n            differences.",
      "source_code": "    def assertSequenceEqual(self, seq1, seq2, msg=None, seq_type=None):\n        \"\"\"An equality assertion for ordered sequences (like lists and tuples).\n\n        For the purposes of this function, a valid ordered sequence type is one\n        which can be indexed, has a length, and has an equality operator.\n\n        Args:\n            seq1: The first sequence to compare.\n            seq2: The second sequence to compare.\n            seq_type: The expected datatype of the sequences, or None if no\n                    datatype should be enforced.\n            msg: Optional message to use on failure instead of a list of\n                    differences.\n        \"\"\"\n        if seq_type is not None:\n            seq_type_name = seq_type.__name__\n            if not isinstance(seq1, seq_type):\n                raise self.failureException('First sequence is not a %s: %s'\n                                        % (seq_type_name, safe_repr(seq1)))\n            if not isinstance(seq2, seq_type):\n                raise self.failureException('Second sequence is not a %s: %s'\n                                        % (seq_type_name, safe_repr(seq2)))\n        else:\n            seq_type_name = \"sequence\"\n\n        differing = None\n        try:\n            len1 = len(seq1)\n        except (TypeError, NotImplementedError):\n            differing = 'First %s has no length.    Non-sequence?' % (\n                    seq_type_name)\n\n        if differing is None:\n            try:\n                len2 = len(seq2)\n            except (TypeError, NotImplementedError):\n                differing = 'Second %s has no length.    Non-sequence?' % (\n                        seq_type_name)\n\n        if differing is None:\n            if seq1 == seq2:\n                return\n\n            differing = '%ss differ: %s != %s\\n' % (\n                    (seq_type_name.capitalize(),) +\n                    _common_shorten_repr(seq1, seq2))\n\n            for i in range(min(len1, len2)):\n                try:\n                    item1 = seq1[i]\n                except (TypeError, IndexError, NotImplementedError):\n                    differing += ('\\nUnable to index element %d of first %s\\n' %\n                                 (i, seq_type_name))\n                    break\n\n                try:\n                    item2 = seq2[i]\n                except (TypeError, IndexError, NotImplementedError):\n                    differing += ('\\nUnable to index element %d of second %s\\n' %\n                                 (i, seq_type_name))\n                    break\n\n                if item1 != item2:\n                    differing += ('\\nFirst differing element %d:\\n%s\\n%s\\n' %\n                                 ((i,) + _common_shorten_repr(item1, item2)))\n                    break\n            else:\n                if (len1 == len2 and seq_type is None and\n                    type(seq1) != type(seq2)):\n                    # The sequences are the same, but have differing types.\n                    return\n\n            if len1 > len2:\n                differing += ('\\nFirst %s contains %d additional '\n                             'elements.\\n' % (seq_type_name, len1 - len2))\n                try:\n                    differing += ('First extra element %d:\\n%s\\n' %\n                                  (len2, safe_repr(seq1[len2])))\n                except (TypeError, IndexError, NotImplementedError):\n                    differing += ('Unable to index element %d '\n                                  'of first %s\\n' % (len2, seq_type_name))\n            elif len1 < len2:\n                differing += ('\\nSecond %s contains %d additional '\n                             'elements.\\n' % (seq_type_name, len2 - len1))\n                try:\n                    differing += ('First extra element %d:\\n%s\\n' %\n                                  (len1, safe_repr(seq2[len1])))\n                except (TypeError, IndexError, NotImplementedError):\n                    differing += ('Unable to index element %d '\n                                  'of second %s\\n' % (len1, seq_type_name))\n        standardMsg = differing\n        diffMsg = '\\n' + '\\n'.join(\n            difflib.ndiff(pprint.pformat(seq1).splitlines(),\n                          pprint.pformat(seq2).splitlines()))\n\n        standardMsg = self._truncateMessage(standardMsg, diffMsg)\n        msg = self._formatMessage(msg, standardMsg)\n        self.fail(msg)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.EncodingEdgeCasesTest.assertSetEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, set1, set2, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "set1": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "set2": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "A set-specific equality assertion.\n\nArgs:\n    set1: The first set to compare.\n    set2: The second set to compare.\n    msg: Optional message to use on failure instead of a list of\n            differences.\n\nassertSetEqual uses ducktyping to support different types of sets, and\nis optimized for sets specifically (parameters must support a\ndifference method).",
      "source_code": "    def assertSetEqual(self, set1, set2, msg=None):\n        \"\"\"A set-specific equality assertion.\n\n        Args:\n            set1: The first set to compare.\n            set2: The second set to compare.\n            msg: Optional message to use on failure instead of a list of\n                    differences.\n\n        assertSetEqual uses ducktyping to support different types of sets, and\n        is optimized for sets specifically (parameters must support a\n        difference method).\n        \"\"\"\n        try:\n            difference1 = set1.difference(set2)\n        except TypeError as e:\n            self.fail('invalid type when attempting set difference: %s' % e)\n        except AttributeError as e:\n            self.fail('first argument does not support set difference: %s' % e)\n\n        try:\n            difference2 = set2.difference(set1)\n        except TypeError as e:\n            self.fail('invalid type when attempting set difference: %s' % e)\n        except AttributeError as e:\n            self.fail('second argument does not support set difference: %s' % e)\n\n        if not (difference1 or difference2):\n            return\n\n        lines = []\n        if difference1:\n            lines.append('Items in the first set but not the second:')\n            for item in difference1:\n                lines.append(repr(item))\n        if difference2:\n            lines.append('Items in the second set but not the first:')\n            for item in difference2:\n                lines.append(repr(item))\n\n        standardMsg = '\\n'.join(lines)\n        self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.EncodingEdgeCasesTest.assertTrue",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, expr, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "expr": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Check that the expression is true.",
      "source_code": "    def assertTrue(self, expr, msg=None):\n        \"\"\"Check that the expression is true.\"\"\"\n        if not expr:\n            msg = self._formatMessage(msg, \"%s is not true\" % safe_repr(expr))\n            raise self.failureException(msg)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.EncodingEdgeCasesTest.assertTupleEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, tuple1, tuple2, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "tuple1": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "tuple2": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "A tuple-specific equality assertion.\n\nArgs:\n    tuple1: The first tuple to compare.\n    tuple2: The second tuple to compare.\n    msg: Optional message to use on failure instead of a list of\n            differences.",
      "source_code": "    def assertTupleEqual(self, tuple1, tuple2, msg=None):\n        \"\"\"A tuple-specific equality assertion.\n\n        Args:\n            tuple1: The first tuple to compare.\n            tuple2: The second tuple to compare.\n            msg: Optional message to use on failure instead of a list of\n                    differences.\n        \"\"\"\n        self.assertSequenceEqual(tuple1, tuple2, msg, seq_type=tuple)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.EncodingEdgeCasesTest.assertWarns",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, expected_warning, *args, **kwargs)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "expected_warning": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Fail unless a warning of class warnClass is triggered\nby the callable when invoked with specified positional and\nkeyword arguments.  If a different type of warning is\ntriggered, it will not be handled: depending on the other\nwarning filtering rules in effect, it might be silenced, printed\nout, or raised as an exception.\n\nIf called with the callable and arguments omitted, will return a\ncontext object used like this::\n\n     with self.assertWarns(SomeWarning):\n         do_something()\n\nAn optional keyword argument 'msg' can be provided when assertWarns\nis used as a context object.\n\nThe context manager keeps a reference to the first matching\nwarning as the 'warning' attribute; similarly, the 'filename'\nand 'lineno' attributes give you information about the line\nof Python code from which the warning was triggered.\nThis allows you to inspect the warning after the assertion::\n\n    with self.assertWarns(SomeWarning) as cm:\n        do_something()\n    the_warning = cm.warning\n    self.assertEqual(the_warning.some_attribute, 147)",
      "source_code": "    def assertWarns(self, expected_warning, *args, **kwargs):\n        \"\"\"Fail unless a warning of class warnClass is triggered\n           by the callable when invoked with specified positional and\n           keyword arguments.  If a different type of warning is\n           triggered, it will not be handled: depending on the other\n           warning filtering rules in effect, it might be silenced, printed\n           out, or raised as an exception.\n\n           If called with the callable and arguments omitted, will return a\n           context object used like this::\n\n                with self.assertWarns(SomeWarning):\n                    do_something()\n\n           An optional keyword argument 'msg' can be provided when assertWarns\n           is used as a context object.\n\n           The context manager keeps a reference to the first matching\n           warning as the 'warning' attribute; similarly, the 'filename'\n           and 'lineno' attributes give you information about the line\n           of Python code from which the warning was triggered.\n           This allows you to inspect the warning after the assertion::\n\n               with self.assertWarns(SomeWarning) as cm:\n                   do_something()\n               the_warning = cm.warning\n               self.assertEqual(the_warning.some_attribute, 147)\n        \"\"\"\n        context = _AssertWarnsContext(expected_warning, self)\n        return context.handle('assertWarns', args, kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.EncodingEdgeCasesTest.assertWarnsRegex",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, expected_warning, expected_regex, *args, **kwargs)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "expected_warning": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "expected_regex": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Asserts that the message in a triggered warning matches a regexp.\nBasic functioning is similar to assertWarns() with the addition\nthat only warnings whose messages also match the regular expression\nare considered successful matches.\n\nArgs:\n    expected_warning: Warning class expected to be triggered.\n    expected_regex: Regex (re.Pattern object or string) expected\n            to be found in error message.\n    args: Function to be called and extra positional args.\n    kwargs: Extra kwargs.\n    msg: Optional message used in case of failure. Can only be used\n            when assertWarnsRegex is used as a context manager.",
      "source_code": "    def assertWarnsRegex(self, expected_warning, expected_regex,\n                         *args, **kwargs):\n        \"\"\"Asserts that the message in a triggered warning matches a regexp.\n        Basic functioning is similar to assertWarns() with the addition\n        that only warnings whose messages also match the regular expression\n        are considered successful matches.\n\n        Args:\n            expected_warning: Warning class expected to be triggered.\n            expected_regex: Regex (re.Pattern object or string) expected\n                    to be found in error message.\n            args: Function to be called and extra positional args.\n            kwargs: Extra kwargs.\n            msg: Optional message used in case of failure. Can only be used\n                    when assertWarnsRegex is used as a context manager.\n        \"\"\"\n        context = _AssertWarnsContext(expected_warning, self, expected_regex)\n        return context.handle('assertWarnsRegex', args, kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.EncodingEdgeCasesTest.assert_",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.EncodingEdgeCasesTest.countTestCases",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def countTestCases(self):\n        return 1\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.EncodingEdgeCasesTest.debug",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Run the test without collecting errors in a TestResult",
      "source_code": "    def debug(self):\n        \"\"\"Run the test without collecting errors in a TestResult\"\"\"\n        testMethod = getattr(self, self._testMethodName)\n        if (getattr(self.__class__, \"__unittest_skip__\", False) or\n            getattr(testMethod, \"__unittest_skip__\", False)):\n            # If the class or method was skipped.\n            skip_why = (getattr(self.__class__, '__unittest_skip_why__', '')\n                        or getattr(testMethod, '__unittest_skip_why__', ''))\n            raise SkipTest(skip_why)\n\n        self._callSetUp()\n        self._callTestMethod(testMethod)\n        self._callTearDown()\n        while self._cleanups:\n            function, args, kwargs = self._cleanups.pop()\n            self._callCleanup(function, *args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.EncodingEdgeCasesTest.defaultTestResult",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def defaultTestResult(self):\n        return result.TestResult()\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.EncodingEdgeCasesTest.doCleanups",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Execute all cleanup functions. Normally called for you after\ntearDown.",
      "source_code": "    def doCleanups(self):\n        \"\"\"Execute all cleanup functions. Normally called for you after\n        tearDown.\"\"\"\n        outcome = self._outcome or _Outcome()\n        while self._cleanups:\n            function, args, kwargs = self._cleanups.pop()\n            with outcome.testPartExecutor(self):\n                self._callCleanup(function, *args, **kwargs)\n\n        # return this for backwards compatibility\n        # even though we no longer use it internally\n        return outcome.success\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.EncodingEdgeCasesTest.fail",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Fail immediately, with the given message.",
      "source_code": "    def fail(self, msg=None):\n        \"\"\"Fail immediately, with the given message.\"\"\"\n        raise self.failureException(msg)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.EncodingEdgeCasesTest.failIf",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.EncodingEdgeCasesTest.failIfAlmostEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.EncodingEdgeCasesTest.failIfEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.EncodingEdgeCasesTest.failUnless",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.EncodingEdgeCasesTest.failUnlessAlmostEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.EncodingEdgeCasesTest.failUnlessEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.EncodingEdgeCasesTest.failUnlessRaises",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.EncodingEdgeCasesTest.id",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def id(self):\n        return \"%s.%s\" % (strclass(self.__class__), self._testMethodName)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.EncodingEdgeCasesTest.run",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, result=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "result": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def run(self, result=None):\n        if result is None:\n            result = self.defaultTestResult()\n            startTestRun = getattr(result, 'startTestRun', None)\n            stopTestRun = getattr(result, 'stopTestRun', None)\n            if startTestRun is not None:\n                startTestRun()\n        else:\n            stopTestRun = None\n\n        result.startTest(self)\n        try:\n            testMethod = getattr(self, self._testMethodName)\n            if (getattr(self.__class__, \"__unittest_skip__\", False) or\n                getattr(testMethod, \"__unittest_skip__\", False)):\n                # If the class or method was skipped.\n                skip_why = (getattr(self.__class__, '__unittest_skip_why__', '')\n                            or getattr(testMethod, '__unittest_skip_why__', ''))\n                self._addSkip(result, self, skip_why)\n                return result\n\n            expecting_failure = (\n                getattr(self, \"__unittest_expecting_failure__\", False) or\n                getattr(testMethod, \"__unittest_expecting_failure__\", False)\n            )\n            outcome = _Outcome(result)\n            try:\n                self._outcome = outcome\n\n                with outcome.testPartExecutor(self):\n                    self._callSetUp()\n                if outcome.success:\n                    outcome.expecting_failure = expecting_failure\n                    with outcome.testPartExecutor(self, isTest=True):\n                        self._callTestMethod(testMethod)\n                    outcome.expecting_failure = False\n                    with outcome.testPartExecutor(self):\n                        self._callTearDown()\n\n                self.doCleanups()\n                for test, reason in outcome.skipped:\n                    self._addSkip(result, test, reason)\n                self._feedErrorsToResult(result, outcome.errors)\n                if outcome.success:\n                    if expecting_failure:\n                        if outcome.expectedFailure:\n                            self._addExpectedFailure(result, outcome.expectedFailure)\n                        else:\n                            self._addUnexpectedSuccess(result)\n                    else:\n                        result.addSuccess(self)\n                return result\n            finally:\n                # explicitly break reference cycles:\n                # outcome.errors -> frame -> outcome -> outcome.errors\n                # outcome.expectedFailure -> frame -> outcome -> outcome.expectedFailure\n                outcome.errors.clear()\n                outcome.expectedFailure = None\n\n                # clear the outcome, no more needed\n                self._outcome = None\n\n        finally:\n            result.stopTest(self)\n            if stopTestRun is not None:\n                stopTestRun()\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.EncodingEdgeCasesTest.setUp",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Hook method for setting up the test fixture before exercising it.",
      "source_code": "    def setUp(self):\n        \"Hook method for setting up the test fixture before exercising it.\"\n        pass\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.EncodingEdgeCasesTest.shortDescription",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Returns a one-line description of the test, or None if no\ndescription has been provided.\n\nThe default implementation of this method returns the first line of\nthe specified test method's docstring.",
      "source_code": "    def shortDescription(self):\n        \"\"\"Returns a one-line description of the test, or None if no\n        description has been provided.\n\n        The default implementation of this method returns the first line of\n        the specified test method's docstring.\n        \"\"\"\n        doc = self._testMethodDoc\n        return doc.strip().split(\"\\n\")[0].strip() if doc else None\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.EncodingEdgeCasesTest.skipTest",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, reason)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "reason": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Skip this test.",
      "source_code": "    def skipTest(self, reason):\n        \"\"\"Skip this test.\"\"\"\n        raise SkipTest(reason)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.EncodingEdgeCasesTest.subTest",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, msg=<object object at 0x7e3e03b88ce0>, **params)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "<object object at 0x7e3e03b88ce0>",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "params": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [
        "contextlib.contextmanager"
      ],
      "examples": [],
      "docstring": "Return a context manager that will return the enclosed block\nof code in a subtest identified by the optional message and\nkeyword parameters.  A failure in the subtest marks the test\ncase as failed but resumes execution at the end of the enclosed\nblock, allowing further test code to be executed.",
      "source_code": "    @contextlib.contextmanager\n    def subTest(self, msg=_subtest_msg_sentinel, **params):\n        \"\"\"Return a context manager that will return the enclosed block\n        of code in a subtest identified by the optional message and\n        keyword parameters.  A failure in the subtest marks the test\n        case as failed but resumes execution at the end of the enclosed\n        block, allowing further test code to be executed.\n        \"\"\"\n        if self._outcome is None or not self._outcome.result_supports_subtests:\n            yield\n            return\n        parent = self._subtest\n        if parent is None:\n            params_map = _OrderedChainMap(params)\n        else:\n            params_map = parent.params.new_child(params)\n        self._subtest = _SubTest(self, msg, params_map)\n        try:\n            with self._outcome.testPartExecutor(self._subtest, isTest=True):\n                yield\n            if not self._outcome.success:\n                result = self._outcome.result\n                if result is not None and result.failfast:\n                    raise _ShouldStop\n            elif self._outcome.expectedFailure:\n                # If the test is expecting a failure, we really want to\n                # stop now and register the expected failure.\n                raise _ShouldStop\n        finally:\n            self._subtest = parent\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.EncodingEdgeCasesTest.tearDown",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Hook method for deconstructing the test fixture after testing it.",
      "source_code": "    def tearDown(self):\n        \"Hook method for deconstructing the test fixture after testing it.\"\n        pass\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.EncodingEdgeCasesTest.test_decode_dict",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def test_decode_dict(self):\n        su = ShortUUID()\n        self.assertRaises(ValueError, su.encode, [])\n        self.assertRaises(ValueError, su.encode, {})\n        self.assertRaises(ValueError, su.decode, (2,))\n        self.assertRaises(ValueError, su.encode, 42)\n        self.assertRaises(ValueError, su.encode, 42.0)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.LegacyShortUUIDTest.addCleanup",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, function, /, *args, **kwargs)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_ONLY",
          "description": null
        },
        "function": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_ONLY",
          "description": null
        },
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Add a function, with arguments, to be called when the test is\ncompleted. Functions added are called on a LIFO basis and are\ncalled after tearDown on test failure or success.\n\nCleanup items are called even if setUp fails (unlike tearDown).",
      "source_code": "    def addCleanup(self, function, /, *args, **kwargs):\n        \"\"\"Add a function, with arguments, to be called when the test is\n        completed. Functions added are called on a LIFO basis and are\n        called after tearDown on test failure or success.\n\n        Cleanup items are called even if setUp fails (unlike tearDown).\"\"\"\n        self._cleanups.append((function, args, kwargs))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.LegacyShortUUIDTest.addTypeEqualityFunc",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, typeobj, function)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "typeobj": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "function": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Add a type specific assertEqual style function to compare a type.\n\nThis method is for use by TestCase subclasses that need to register\ntheir own type equality functions to provide nicer error messages.\n\nArgs:\n    typeobj: The data type to call this function on when both values\n            are of the same type in assertEqual().\n    function: The callable taking two arguments and an optional\n            msg= argument that raises self.failureException with a\n            useful error message when the two arguments are not equal.",
      "source_code": "    def addTypeEqualityFunc(self, typeobj, function):\n        \"\"\"Add a type specific assertEqual style function to compare a type.\n\n        This method is for use by TestCase subclasses that need to register\n        their own type equality functions to provide nicer error messages.\n\n        Args:\n            typeobj: The data type to call this function on when both values\n                    are of the same type in assertEqual().\n            function: The callable taking two arguments and an optional\n                    msg= argument that raises self.failureException with a\n                    useful error message when the two arguments are not equal.\n        \"\"\"\n        self._type_equality_funcs[typeobj] = function\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.LegacyShortUUIDTest.assertAlmostEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, first, second, places=None, msg=None, delta=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "first": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "second": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "places": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "delta": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Fail if the two objects are unequal as determined by their\ndifference rounded to the given number of decimal places\n(default 7) and comparing to zero, or by comparing that the\ndifference between the two objects is more than the given\ndelta.\n\nNote that decimal places (from zero) are usually not the same\nas significant digits (measured from the most significant digit).\n\nIf the two objects compare equal then they will automatically\ncompare almost equal.",
      "source_code": "    def assertAlmostEqual(self, first, second, places=None, msg=None,\n                          delta=None):\n        \"\"\"Fail if the two objects are unequal as determined by their\n           difference rounded to the given number of decimal places\n           (default 7) and comparing to zero, or by comparing that the\n           difference between the two objects is more than the given\n           delta.\n\n           Note that decimal places (from zero) are usually not the same\n           as significant digits (measured from the most significant digit).\n\n           If the two objects compare equal then they will automatically\n           compare almost equal.\n        \"\"\"\n        if first == second:\n            # shortcut\n            return\n        if delta is not None and places is not None:\n            raise TypeError(\"specify delta or places not both\")\n\n        diff = abs(first - second)\n        if delta is not None:\n            if diff <= delta:\n                return\n\n            standardMsg = '%s != %s within %s delta (%s difference)' % (\n                safe_repr(first),\n                safe_repr(second),\n                safe_repr(delta),\n                safe_repr(diff))\n        else:\n            if places is None:\n                places = 7\n\n            if round(diff, places) == 0:\n                return\n\n            standardMsg = '%s != %s within %r places (%s difference)' % (\n                safe_repr(first),\n                safe_repr(second),\n                places,\n                safe_repr(diff))\n        msg = self._formatMessage(msg, standardMsg)\n        raise self.failureException(msg)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.LegacyShortUUIDTest.assertAlmostEquals",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.LegacyShortUUIDTest.assertCountEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, first, second, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "first": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "second": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Asserts that two iterables have the same elements, the same number of\ntimes, without regard to order.\n\n    self.assertEqual(Counter(list(first)),\n                     Counter(list(second)))\n\n Example:\n    - [0, 1, 1] and [1, 0, 1] compare equal.\n    - [0, 0, 1] and [0, 1] compare unequal.",
      "source_code": "    def assertCountEqual(self, first, second, msg=None):\n        \"\"\"Asserts that two iterables have the same elements, the same number of\n        times, without regard to order.\n\n            self.assertEqual(Counter(list(first)),\n                             Counter(list(second)))\n\n         Example:\n            - [0, 1, 1] and [1, 0, 1] compare equal.\n            - [0, 0, 1] and [0, 1] compare unequal.\n\n        \"\"\"\n        first_seq, second_seq = list(first), list(second)\n        try:\n            first = collections.Counter(first_seq)\n            second = collections.Counter(second_seq)\n        except TypeError:\n            # Handle case with unhashable elements\n            differences = _count_diff_all_purpose(first_seq, second_seq)\n        else:\n            if first == second:\n                return\n            differences = _count_diff_hashable(first_seq, second_seq)\n\n        if differences:\n            standardMsg = 'Element counts were not equal:\\n'\n            lines = ['First has %d, Second has %d:  %r' % diff for diff in differences]\n            diffMsg = '\\n'.join(lines)\n            standardMsg = self._truncateMessage(standardMsg, diffMsg)\n            msg = self._formatMessage(msg, standardMsg)\n            self.fail(msg)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.LegacyShortUUIDTest.assertDictContainsSubset",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, subset, dictionary, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "subset": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "dictionary": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Checks whether dictionary is a superset of subset.",
      "source_code": "    def assertDictContainsSubset(self, subset, dictionary, msg=None):\n        \"\"\"Checks whether dictionary is a superset of subset.\"\"\"\n        warnings.warn('assertDictContainsSubset is deprecated',\n                      DeprecationWarning,\n                      stacklevel=2)\n        missing = []\n        mismatched = []\n        for key, value in subset.items():\n            if key not in dictionary:\n                missing.append(key)\n            elif value != dictionary[key]:\n                mismatched.append('%s, expected: %s, actual: %s' %\n                                  (safe_repr(key), safe_repr(value),\n                                   safe_repr(dictionary[key])))\n\n        if not (missing or mismatched):\n            return\n\n        standardMsg = ''\n        if missing:\n            standardMsg = 'Missing: %s' % ','.join(safe_repr(m) for m in\n                                                    missing)\n        if mismatched:\n            if standardMsg:\n                standardMsg += '; '\n            standardMsg += 'Mismatched values: %s' % ','.join(mismatched)\n\n        self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.LegacyShortUUIDTest.assertDictEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, d1, d2, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "d1": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "d2": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def assertDictEqual(self, d1, d2, msg=None):\n        self.assertIsInstance(d1, dict, 'First argument is not a dictionary')\n        self.assertIsInstance(d2, dict, 'Second argument is not a dictionary')\n\n        if d1 != d2:\n            standardMsg = '%s != %s' % _common_shorten_repr(d1, d2)\n            diff = ('\\n' + '\\n'.join(difflib.ndiff(\n                           pprint.pformat(d1).splitlines(),\n                           pprint.pformat(d2).splitlines())))\n            standardMsg = self._truncateMessage(standardMsg, diff)\n            self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.LegacyShortUUIDTest.assertEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, first, second, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "first": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "second": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Fail if the two objects are unequal as determined by the '=='\noperator.",
      "source_code": "    def assertEqual(self, first, second, msg=None):\n        \"\"\"Fail if the two objects are unequal as determined by the '=='\n           operator.\n        \"\"\"\n        assertion_func = self._getAssertEqualityFunc(first, second)\n        assertion_func(first, second, msg=msg)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.LegacyShortUUIDTest.assertEquals",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.LegacyShortUUIDTest.assertFalse",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, expr, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "expr": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Check that the expression is false.",
      "source_code": "    def assertFalse(self, expr, msg=None):\n        \"\"\"Check that the expression is false.\"\"\"\n        if expr:\n            msg = self._formatMessage(msg, \"%s is not false\" % safe_repr(expr))\n            raise self.failureException(msg)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.LegacyShortUUIDTest.assertGreater",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, a, b, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "a": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "b": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Just like self.assertTrue(a > b), but with a nicer default message.",
      "source_code": "    def assertGreater(self, a, b, msg=None):\n        \"\"\"Just like self.assertTrue(a > b), but with a nicer default message.\"\"\"\n        if not a > b:\n            standardMsg = '%s not greater than %s' % (safe_repr(a), safe_repr(b))\n            self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.LegacyShortUUIDTest.assertGreaterEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, a, b, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "a": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "b": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Just like self.assertTrue(a >= b), but with a nicer default message.",
      "source_code": "    def assertGreaterEqual(self, a, b, msg=None):\n        \"\"\"Just like self.assertTrue(a >= b), but with a nicer default message.\"\"\"\n        if not a >= b:\n            standardMsg = '%s not greater than or equal to %s' % (safe_repr(a), safe_repr(b))\n            self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.LegacyShortUUIDTest.assertIn",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, member, container, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "member": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "container": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Just like self.assertTrue(a in b), but with a nicer default message.",
      "source_code": "    def assertIn(self, member, container, msg=None):\n        \"\"\"Just like self.assertTrue(a in b), but with a nicer default message.\"\"\"\n        if member not in container:\n            standardMsg = '%s not found in %s' % (safe_repr(member),\n                                                  safe_repr(container))\n            self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.LegacyShortUUIDTest.assertIs",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, expr1, expr2, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "expr1": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "expr2": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Just like self.assertTrue(a is b), but with a nicer default message.",
      "source_code": "    def assertIs(self, expr1, expr2, msg=None):\n        \"\"\"Just like self.assertTrue(a is b), but with a nicer default message.\"\"\"\n        if expr1 is not expr2:\n            standardMsg = '%s is not %s' % (safe_repr(expr1),\n                                             safe_repr(expr2))\n            self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.LegacyShortUUIDTest.assertIsInstance",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, obj, cls, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "obj": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "cls": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Same as self.assertTrue(isinstance(obj, cls)), with a nicer\ndefault message.",
      "source_code": "    def assertIsInstance(self, obj, cls, msg=None):\n        \"\"\"Same as self.assertTrue(isinstance(obj, cls)), with a nicer\n        default message.\"\"\"\n        if not isinstance(obj, cls):\n            standardMsg = '%s is not an instance of %r' % (safe_repr(obj), cls)\n            self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.LegacyShortUUIDTest.assertIsNone",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, obj, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "obj": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Same as self.assertTrue(obj is None), with a nicer default message.",
      "source_code": "    def assertIsNone(self, obj, msg=None):\n        \"\"\"Same as self.assertTrue(obj is None), with a nicer default message.\"\"\"\n        if obj is not None:\n            standardMsg = '%s is not None' % (safe_repr(obj),)\n            self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.LegacyShortUUIDTest.assertIsNot",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, expr1, expr2, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "expr1": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "expr2": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Just like self.assertTrue(a is not b), but with a nicer default message.",
      "source_code": "    def assertIsNot(self, expr1, expr2, msg=None):\n        \"\"\"Just like self.assertTrue(a is not b), but with a nicer default message.\"\"\"\n        if expr1 is expr2:\n            standardMsg = 'unexpectedly identical: %s' % (safe_repr(expr1),)\n            self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.LegacyShortUUIDTest.assertIsNotNone",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, obj, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "obj": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Included for symmetry with assertIsNone.",
      "source_code": "    def assertIsNotNone(self, obj, msg=None):\n        \"\"\"Included for symmetry with assertIsNone.\"\"\"\n        if obj is None:\n            standardMsg = 'unexpectedly None'\n            self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.LegacyShortUUIDTest.assertLess",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, a, b, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "a": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "b": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Just like self.assertTrue(a < b), but with a nicer default message.",
      "source_code": "    def assertLess(self, a, b, msg=None):\n        \"\"\"Just like self.assertTrue(a < b), but with a nicer default message.\"\"\"\n        if not a < b:\n            standardMsg = '%s not less than %s' % (safe_repr(a), safe_repr(b))\n            self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.LegacyShortUUIDTest.assertLessEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, a, b, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "a": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "b": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Just like self.assertTrue(a <= b), but with a nicer default message.",
      "source_code": "    def assertLessEqual(self, a, b, msg=None):\n        \"\"\"Just like self.assertTrue(a <= b), but with a nicer default message.\"\"\"\n        if not a <= b:\n            standardMsg = '%s not less than or equal to %s' % (safe_repr(a), safe_repr(b))\n            self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.LegacyShortUUIDTest.assertListEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, list1, list2, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "list1": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "list2": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "A list-specific equality assertion.\n\nArgs:\n    list1: The first list to compare.\n    list2: The second list to compare.\n    msg: Optional message to use on failure instead of a list of\n            differences.",
      "source_code": "    def assertListEqual(self, list1, list2, msg=None):\n        \"\"\"A list-specific equality assertion.\n\n        Args:\n            list1: The first list to compare.\n            list2: The second list to compare.\n            msg: Optional message to use on failure instead of a list of\n                    differences.\n\n        \"\"\"\n        self.assertSequenceEqual(list1, list2, msg, seq_type=list)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.LegacyShortUUIDTest.assertLogs",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, logger=None, level=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "logger": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "level": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Fail unless a log message of level *level* or higher is emitted\non *logger_name* or its children.  If omitted, *level* defaults to\nINFO and *logger* defaults to the root logger.\n\nThis method must be used as a context manager, and will yield\na recording object with two attributes: `output` and `records`.\nAt the end of the context manager, the `output` attribute will\nbe a list of the matching formatted log messages and the\n`records` attribute will be a list of the corresponding LogRecord\nobjects.\n\nExample::\n\n    with self.assertLogs('foo', level='INFO') as cm:\n        logging.getLogger('foo').info('first message')\n        logging.getLogger('foo.bar').error('second message')\n    self.assertEqual(cm.output, ['INFO:foo:first message',\n                                 'ERROR:foo.bar:second message'])",
      "source_code": "    def assertLogs(self, logger=None, level=None):\n        \"\"\"Fail unless a log message of level *level* or higher is emitted\n        on *logger_name* or its children.  If omitted, *level* defaults to\n        INFO and *logger* defaults to the root logger.\n\n        This method must be used as a context manager, and will yield\n        a recording object with two attributes: `output` and `records`.\n        At the end of the context manager, the `output` attribute will\n        be a list of the matching formatted log messages and the\n        `records` attribute will be a list of the corresponding LogRecord\n        objects.\n\n        Example::\n\n            with self.assertLogs('foo', level='INFO') as cm:\n                logging.getLogger('foo').info('first message')\n                logging.getLogger('foo.bar').error('second message')\n            self.assertEqual(cm.output, ['INFO:foo:first message',\n                                         'ERROR:foo.bar:second message'])\n        \"\"\"\n        # Lazy import to avoid importing logging if it is not needed.\n        from ._log import _AssertLogsContext\n        return _AssertLogsContext(self, logger, level, no_logs=False)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.LegacyShortUUIDTest.assertMultiLineEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, first, second, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "first": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "second": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Assert that two multi-line strings are equal.",
      "source_code": "    def assertMultiLineEqual(self, first, second, msg=None):\n        \"\"\"Assert that two multi-line strings are equal.\"\"\"\n        self.assertIsInstance(first, str, 'First argument is not a string')\n        self.assertIsInstance(second, str, 'Second argument is not a string')\n\n        if first != second:\n            # don't use difflib if the strings are too long\n            if (len(first) > self._diffThreshold or\n                len(second) > self._diffThreshold):\n                self._baseAssertEqual(first, second, msg)\n            firstlines = first.splitlines(keepends=True)\n            secondlines = second.splitlines(keepends=True)\n            if len(firstlines) == 1 and first.strip('\\r\\n') == first:\n                firstlines = [first + '\\n']\n                secondlines = [second + '\\n']\n            standardMsg = '%s != %s' % _common_shorten_repr(first, second)\n            diff = '\\n' + ''.join(difflib.ndiff(firstlines, secondlines))\n            standardMsg = self._truncateMessage(standardMsg, diff)\n            self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.LegacyShortUUIDTest.assertNoLogs",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, logger=None, level=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "logger": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "level": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Fail unless no log messages of level *level* or higher are emitted\non *logger_name* or its children.\n\nThis method must be used as a context manager.",
      "source_code": "    def assertNoLogs(self, logger=None, level=None):\n        \"\"\" Fail unless no log messages of level *level* or higher are emitted\n        on *logger_name* or its children.\n\n        This method must be used as a context manager.\n        \"\"\"\n        from ._log import _AssertLogsContext\n        return _AssertLogsContext(self, logger, level, no_logs=True)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.LegacyShortUUIDTest.assertNotAlmostEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, first, second, places=None, msg=None, delta=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "first": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "second": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "places": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "delta": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Fail if the two objects are equal as determined by their\ndifference rounded to the given number of decimal places\n(default 7) and comparing to zero, or by comparing that the\ndifference between the two objects is less than the given delta.\n\nNote that decimal places (from zero) are usually not the same\nas significant digits (measured from the most significant digit).\n\nObjects that are equal automatically fail.",
      "source_code": "    def assertNotAlmostEqual(self, first, second, places=None, msg=None,\n                             delta=None):\n        \"\"\"Fail if the two objects are equal as determined by their\n           difference rounded to the given number of decimal places\n           (default 7) and comparing to zero, or by comparing that the\n           difference between the two objects is less than the given delta.\n\n           Note that decimal places (from zero) are usually not the same\n           as significant digits (measured from the most significant digit).\n\n           Objects that are equal automatically fail.\n        \"\"\"\n        if delta is not None and places is not None:\n            raise TypeError(\"specify delta or places not both\")\n        diff = abs(first - second)\n        if delta is not None:\n            if not (first == second) and diff > delta:\n                return\n            standardMsg = '%s == %s within %s delta (%s difference)' % (\n                safe_repr(first),\n                safe_repr(second),\n                safe_repr(delta),\n                safe_repr(diff))\n        else:\n            if places is None:\n                places = 7\n            if not (first == second) and round(diff, places) != 0:\n                return\n            standardMsg = '%s == %s within %r places' % (safe_repr(first),\n                                                         safe_repr(second),\n                                                         places)\n\n        msg = self._formatMessage(msg, standardMsg)\n        raise self.failureException(msg)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.LegacyShortUUIDTest.assertNotAlmostEquals",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.LegacyShortUUIDTest.assertNotEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, first, second, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "first": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "second": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Fail if the two objects are equal as determined by the '!='\noperator.",
      "source_code": "    def assertNotEqual(self, first, second, msg=None):\n        \"\"\"Fail if the two objects are equal as determined by the '!='\n           operator.\n        \"\"\"\n        if not first != second:\n            msg = self._formatMessage(msg, '%s == %s' % (safe_repr(first),\n                                                          safe_repr(second)))\n            raise self.failureException(msg)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.LegacyShortUUIDTest.assertNotEquals",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.LegacyShortUUIDTest.assertNotIn",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, member, container, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "member": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "container": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Just like self.assertTrue(a not in b), but with a nicer default message.",
      "source_code": "    def assertNotIn(self, member, container, msg=None):\n        \"\"\"Just like self.assertTrue(a not in b), but with a nicer default message.\"\"\"\n        if member in container:\n            standardMsg = '%s unexpectedly found in %s' % (safe_repr(member),\n                                                        safe_repr(container))\n            self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.LegacyShortUUIDTest.assertNotIsInstance",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, obj, cls, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "obj": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "cls": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Included for symmetry with assertIsInstance.",
      "source_code": "    def assertNotIsInstance(self, obj, cls, msg=None):\n        \"\"\"Included for symmetry with assertIsInstance.\"\"\"\n        if isinstance(obj, cls):\n            standardMsg = '%s is an instance of %r' % (safe_repr(obj), cls)\n            self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.LegacyShortUUIDTest.assertNotRegex",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, text, unexpected_regex, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "text": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "unexpected_regex": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Fail the test if the text matches the regular expression.",
      "source_code": "    def assertNotRegex(self, text, unexpected_regex, msg=None):\n        \"\"\"Fail the test if the text matches the regular expression.\"\"\"\n        if isinstance(unexpected_regex, (str, bytes)):\n            unexpected_regex = re.compile(unexpected_regex)\n        match = unexpected_regex.search(text)\n        if match:\n            standardMsg = 'Regex matched: %r matches %r in %r' % (\n                text[match.start() : match.end()],\n                unexpected_regex.pattern,\n                text)\n            # _formatMessage ensures the longMessage option is respected\n            msg = self._formatMessage(msg, standardMsg)\n            raise self.failureException(msg)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.LegacyShortUUIDTest.assertNotRegexpMatches",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.LegacyShortUUIDTest.assertRaises",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, expected_exception, *args, **kwargs)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "expected_exception": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Fail unless an exception of class expected_exception is raised\nby the callable when invoked with specified positional and\nkeyword arguments. If a different type of exception is\nraised, it will not be caught, and the test case will be\ndeemed to have suffered an error, exactly as for an\nunexpected exception.\n\nIf called with the callable and arguments omitted, will return a\ncontext object used like this::\n\n     with self.assertRaises(SomeException):\n         do_something()\n\nAn optional keyword argument 'msg' can be provided when assertRaises\nis used as a context object.\n\nThe context manager keeps a reference to the exception as\nthe 'exception' attribute. This allows you to inspect the\nexception after the assertion::\n\n    with self.assertRaises(SomeException) as cm:\n        do_something()\n    the_exception = cm.exception\n    self.assertEqual(the_exception.error_code, 3)",
      "source_code": "    def assertRaises(self, expected_exception, *args, **kwargs):\n        \"\"\"Fail unless an exception of class expected_exception is raised\n           by the callable when invoked with specified positional and\n           keyword arguments. If a different type of exception is\n           raised, it will not be caught, and the test case will be\n           deemed to have suffered an error, exactly as for an\n           unexpected exception.\n\n           If called with the callable and arguments omitted, will return a\n           context object used like this::\n\n                with self.assertRaises(SomeException):\n                    do_something()\n\n           An optional keyword argument 'msg' can be provided when assertRaises\n           is used as a context object.\n\n           The context manager keeps a reference to the exception as\n           the 'exception' attribute. This allows you to inspect the\n           exception after the assertion::\n\n               with self.assertRaises(SomeException) as cm:\n                   do_something()\n               the_exception = cm.exception\n               self.assertEqual(the_exception.error_code, 3)\n        \"\"\"\n        context = _AssertRaisesContext(expected_exception, self)\n        try:\n            return context.handle('assertRaises', args, kwargs)\n        finally:\n            # bpo-23890: manually break a reference cycle\n            context = None\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.LegacyShortUUIDTest.assertRaisesRegex",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, expected_exception, expected_regex, *args, **kwargs)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "expected_exception": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "expected_regex": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Asserts that the message in a raised exception matches a regex.\n\nArgs:\n    expected_exception: Exception class expected to be raised.\n    expected_regex: Regex (re.Pattern object or string) expected\n            to be found in error message.\n    args: Function to be called and extra positional args.\n    kwargs: Extra kwargs.\n    msg: Optional message used in case of failure. Can only be used\n            when assertRaisesRegex is used as a context manager.",
      "source_code": "    def assertRaisesRegex(self, expected_exception, expected_regex,\n                          *args, **kwargs):\n        \"\"\"Asserts that the message in a raised exception matches a regex.\n\n        Args:\n            expected_exception: Exception class expected to be raised.\n            expected_regex: Regex (re.Pattern object or string) expected\n                    to be found in error message.\n            args: Function to be called and extra positional args.\n            kwargs: Extra kwargs.\n            msg: Optional message used in case of failure. Can only be used\n                    when assertRaisesRegex is used as a context manager.\n        \"\"\"\n        context = _AssertRaisesContext(expected_exception, self, expected_regex)\n        return context.handle('assertRaisesRegex', args, kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.LegacyShortUUIDTest.assertRaisesRegexp",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.LegacyShortUUIDTest.assertRegex",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, text, expected_regex, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "text": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "expected_regex": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Fail the test unless the text matches the regular expression.",
      "source_code": "    def assertRegex(self, text, expected_regex, msg=None):\n        \"\"\"Fail the test unless the text matches the regular expression.\"\"\"\n        if isinstance(expected_regex, (str, bytes)):\n            assert expected_regex, \"expected_regex must not be empty.\"\n            expected_regex = re.compile(expected_regex)\n        if not expected_regex.search(text):\n            standardMsg = \"Regex didn't match: %r not found in %r\" % (\n                expected_regex.pattern, text)\n            # _formatMessage ensures the longMessage option is respected\n            msg = self._formatMessage(msg, standardMsg)\n            raise self.failureException(msg)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.LegacyShortUUIDTest.assertRegexpMatches",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.LegacyShortUUIDTest.assertSequenceEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, seq1, seq2, msg=None, seq_type=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "seq1": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "seq2": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "seq_type": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "An equality assertion for ordered sequences (like lists and tuples).\n\nFor the purposes of this function, a valid ordered sequence type is one\nwhich can be indexed, has a length, and has an equality operator.\n\nArgs:\n    seq1: The first sequence to compare.\n    seq2: The second sequence to compare.\n    seq_type: The expected datatype of the sequences, or None if no\n            datatype should be enforced.\n    msg: Optional message to use on failure instead of a list of\n            differences.",
      "source_code": "    def assertSequenceEqual(self, seq1, seq2, msg=None, seq_type=None):\n        \"\"\"An equality assertion for ordered sequences (like lists and tuples).\n\n        For the purposes of this function, a valid ordered sequence type is one\n        which can be indexed, has a length, and has an equality operator.\n\n        Args:\n            seq1: The first sequence to compare.\n            seq2: The second sequence to compare.\n            seq_type: The expected datatype of the sequences, or None if no\n                    datatype should be enforced.\n            msg: Optional message to use on failure instead of a list of\n                    differences.\n        \"\"\"\n        if seq_type is not None:\n            seq_type_name = seq_type.__name__\n            if not isinstance(seq1, seq_type):\n                raise self.failureException('First sequence is not a %s: %s'\n                                        % (seq_type_name, safe_repr(seq1)))\n            if not isinstance(seq2, seq_type):\n                raise self.failureException('Second sequence is not a %s: %s'\n                                        % (seq_type_name, safe_repr(seq2)))\n        else:\n            seq_type_name = \"sequence\"\n\n        differing = None\n        try:\n            len1 = len(seq1)\n        except (TypeError, NotImplementedError):\n            differing = 'First %s has no length.    Non-sequence?' % (\n                    seq_type_name)\n\n        if differing is None:\n            try:\n                len2 = len(seq2)\n            except (TypeError, NotImplementedError):\n                differing = 'Second %s has no length.    Non-sequence?' % (\n                        seq_type_name)\n\n        if differing is None:\n            if seq1 == seq2:\n                return\n\n            differing = '%ss differ: %s != %s\\n' % (\n                    (seq_type_name.capitalize(),) +\n                    _common_shorten_repr(seq1, seq2))\n\n            for i in range(min(len1, len2)):\n                try:\n                    item1 = seq1[i]\n                except (TypeError, IndexError, NotImplementedError):\n                    differing += ('\\nUnable to index element %d of first %s\\n' %\n                                 (i, seq_type_name))\n                    break\n\n                try:\n                    item2 = seq2[i]\n                except (TypeError, IndexError, NotImplementedError):\n                    differing += ('\\nUnable to index element %d of second %s\\n' %\n                                 (i, seq_type_name))\n                    break\n\n                if item1 != item2:\n                    differing += ('\\nFirst differing element %d:\\n%s\\n%s\\n' %\n                                 ((i,) + _common_shorten_repr(item1, item2)))\n                    break\n            else:\n                if (len1 == len2 and seq_type is None and\n                    type(seq1) != type(seq2)):\n                    # The sequences are the same, but have differing types.\n                    return\n\n            if len1 > len2:\n                differing += ('\\nFirst %s contains %d additional '\n                             'elements.\\n' % (seq_type_name, len1 - len2))\n                try:\n                    differing += ('First extra element %d:\\n%s\\n' %\n                                  (len2, safe_repr(seq1[len2])))\n                except (TypeError, IndexError, NotImplementedError):\n                    differing += ('Unable to index element %d '\n                                  'of first %s\\n' % (len2, seq_type_name))\n            elif len1 < len2:\n                differing += ('\\nSecond %s contains %d additional '\n                             'elements.\\n' % (seq_type_name, len2 - len1))\n                try:\n                    differing += ('First extra element %d:\\n%s\\n' %\n                                  (len1, safe_repr(seq2[len1])))\n                except (TypeError, IndexError, NotImplementedError):\n                    differing += ('Unable to index element %d '\n                                  'of second %s\\n' % (len1, seq_type_name))\n        standardMsg = differing\n        diffMsg = '\\n' + '\\n'.join(\n            difflib.ndiff(pprint.pformat(seq1).splitlines(),\n                          pprint.pformat(seq2).splitlines()))\n\n        standardMsg = self._truncateMessage(standardMsg, diffMsg)\n        msg = self._formatMessage(msg, standardMsg)\n        self.fail(msg)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.LegacyShortUUIDTest.assertSetEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, set1, set2, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "set1": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "set2": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "A set-specific equality assertion.\n\nArgs:\n    set1: The first set to compare.\n    set2: The second set to compare.\n    msg: Optional message to use on failure instead of a list of\n            differences.\n\nassertSetEqual uses ducktyping to support different types of sets, and\nis optimized for sets specifically (parameters must support a\ndifference method).",
      "source_code": "    def assertSetEqual(self, set1, set2, msg=None):\n        \"\"\"A set-specific equality assertion.\n\n        Args:\n            set1: The first set to compare.\n            set2: The second set to compare.\n            msg: Optional message to use on failure instead of a list of\n                    differences.\n\n        assertSetEqual uses ducktyping to support different types of sets, and\n        is optimized for sets specifically (parameters must support a\n        difference method).\n        \"\"\"\n        try:\n            difference1 = set1.difference(set2)\n        except TypeError as e:\n            self.fail('invalid type when attempting set difference: %s' % e)\n        except AttributeError as e:\n            self.fail('first argument does not support set difference: %s' % e)\n\n        try:\n            difference2 = set2.difference(set1)\n        except TypeError as e:\n            self.fail('invalid type when attempting set difference: %s' % e)\n        except AttributeError as e:\n            self.fail('second argument does not support set difference: %s' % e)\n\n        if not (difference1 or difference2):\n            return\n\n        lines = []\n        if difference1:\n            lines.append('Items in the first set but not the second:')\n            for item in difference1:\n                lines.append(repr(item))\n        if difference2:\n            lines.append('Items in the second set but not the first:')\n            for item in difference2:\n                lines.append(repr(item))\n\n        standardMsg = '\\n'.join(lines)\n        self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.LegacyShortUUIDTest.assertTrue",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, expr, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "expr": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Check that the expression is true.",
      "source_code": "    def assertTrue(self, expr, msg=None):\n        \"\"\"Check that the expression is true.\"\"\"\n        if not expr:\n            msg = self._formatMessage(msg, \"%s is not true\" % safe_repr(expr))\n            raise self.failureException(msg)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.LegacyShortUUIDTest.assertTupleEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, tuple1, tuple2, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "tuple1": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "tuple2": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "A tuple-specific equality assertion.\n\nArgs:\n    tuple1: The first tuple to compare.\n    tuple2: The second tuple to compare.\n    msg: Optional message to use on failure instead of a list of\n            differences.",
      "source_code": "    def assertTupleEqual(self, tuple1, tuple2, msg=None):\n        \"\"\"A tuple-specific equality assertion.\n\n        Args:\n            tuple1: The first tuple to compare.\n            tuple2: The second tuple to compare.\n            msg: Optional message to use on failure instead of a list of\n                    differences.\n        \"\"\"\n        self.assertSequenceEqual(tuple1, tuple2, msg, seq_type=tuple)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.LegacyShortUUIDTest.assertWarns",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, expected_warning, *args, **kwargs)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "expected_warning": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Fail unless a warning of class warnClass is triggered\nby the callable when invoked with specified positional and\nkeyword arguments.  If a different type of warning is\ntriggered, it will not be handled: depending on the other\nwarning filtering rules in effect, it might be silenced, printed\nout, or raised as an exception.\n\nIf called with the callable and arguments omitted, will return a\ncontext object used like this::\n\n     with self.assertWarns(SomeWarning):\n         do_something()\n\nAn optional keyword argument 'msg' can be provided when assertWarns\nis used as a context object.\n\nThe context manager keeps a reference to the first matching\nwarning as the 'warning' attribute; similarly, the 'filename'\nand 'lineno' attributes give you information about the line\nof Python code from which the warning was triggered.\nThis allows you to inspect the warning after the assertion::\n\n    with self.assertWarns(SomeWarning) as cm:\n        do_something()\n    the_warning = cm.warning\n    self.assertEqual(the_warning.some_attribute, 147)",
      "source_code": "    def assertWarns(self, expected_warning, *args, **kwargs):\n        \"\"\"Fail unless a warning of class warnClass is triggered\n           by the callable when invoked with specified positional and\n           keyword arguments.  If a different type of warning is\n           triggered, it will not be handled: depending on the other\n           warning filtering rules in effect, it might be silenced, printed\n           out, or raised as an exception.\n\n           If called with the callable and arguments omitted, will return a\n           context object used like this::\n\n                with self.assertWarns(SomeWarning):\n                    do_something()\n\n           An optional keyword argument 'msg' can be provided when assertWarns\n           is used as a context object.\n\n           The context manager keeps a reference to the first matching\n           warning as the 'warning' attribute; similarly, the 'filename'\n           and 'lineno' attributes give you information about the line\n           of Python code from which the warning was triggered.\n           This allows you to inspect the warning after the assertion::\n\n               with self.assertWarns(SomeWarning) as cm:\n                   do_something()\n               the_warning = cm.warning\n               self.assertEqual(the_warning.some_attribute, 147)\n        \"\"\"\n        context = _AssertWarnsContext(expected_warning, self)\n        return context.handle('assertWarns', args, kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.LegacyShortUUIDTest.assertWarnsRegex",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, expected_warning, expected_regex, *args, **kwargs)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "expected_warning": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "expected_regex": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Asserts that the message in a triggered warning matches a regexp.\nBasic functioning is similar to assertWarns() with the addition\nthat only warnings whose messages also match the regular expression\nare considered successful matches.\n\nArgs:\n    expected_warning: Warning class expected to be triggered.\n    expected_regex: Regex (re.Pattern object or string) expected\n            to be found in error message.\n    args: Function to be called and extra positional args.\n    kwargs: Extra kwargs.\n    msg: Optional message used in case of failure. Can only be used\n            when assertWarnsRegex is used as a context manager.",
      "source_code": "    def assertWarnsRegex(self, expected_warning, expected_regex,\n                         *args, **kwargs):\n        \"\"\"Asserts that the message in a triggered warning matches a regexp.\n        Basic functioning is similar to assertWarns() with the addition\n        that only warnings whose messages also match the regular expression\n        are considered successful matches.\n\n        Args:\n            expected_warning: Warning class expected to be triggered.\n            expected_regex: Regex (re.Pattern object or string) expected\n                    to be found in error message.\n            args: Function to be called and extra positional args.\n            kwargs: Extra kwargs.\n            msg: Optional message used in case of failure. Can only be used\n                    when assertWarnsRegex is used as a context manager.\n        \"\"\"\n        context = _AssertWarnsContext(expected_warning, self, expected_regex)\n        return context.handle('assertWarnsRegex', args, kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.LegacyShortUUIDTest.assert_",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.LegacyShortUUIDTest.countTestCases",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def countTestCases(self):\n        return 1\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.LegacyShortUUIDTest.debug",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Run the test without collecting errors in a TestResult",
      "source_code": "    def debug(self):\n        \"\"\"Run the test without collecting errors in a TestResult\"\"\"\n        testMethod = getattr(self, self._testMethodName)\n        if (getattr(self.__class__, \"__unittest_skip__\", False) or\n            getattr(testMethod, \"__unittest_skip__\", False)):\n            # If the class or method was skipped.\n            skip_why = (getattr(self.__class__, '__unittest_skip_why__', '')\n                        or getattr(testMethod, '__unittest_skip_why__', ''))\n            raise SkipTest(skip_why)\n\n        self._callSetUp()\n        self._callTestMethod(testMethod)\n        self._callTearDown()\n        while self._cleanups:\n            function, args, kwargs = self._cleanups.pop()\n            self._callCleanup(function, *args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.LegacyShortUUIDTest.defaultTestResult",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def defaultTestResult(self):\n        return result.TestResult()\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.LegacyShortUUIDTest.doCleanups",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Execute all cleanup functions. Normally called for you after\ntearDown.",
      "source_code": "    def doCleanups(self):\n        \"\"\"Execute all cleanup functions. Normally called for you after\n        tearDown.\"\"\"\n        outcome = self._outcome or _Outcome()\n        while self._cleanups:\n            function, args, kwargs = self._cleanups.pop()\n            with outcome.testPartExecutor(self):\n                self._callCleanup(function, *args, **kwargs)\n\n        # return this for backwards compatibility\n        # even though we no longer use it internally\n        return outcome.success\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.LegacyShortUUIDTest.fail",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Fail immediately, with the given message.",
      "source_code": "    def fail(self, msg=None):\n        \"\"\"Fail immediately, with the given message.\"\"\"\n        raise self.failureException(msg)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.LegacyShortUUIDTest.failIf",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.LegacyShortUUIDTest.failIfAlmostEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.LegacyShortUUIDTest.failIfEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.LegacyShortUUIDTest.failUnless",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.LegacyShortUUIDTest.failUnlessAlmostEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.LegacyShortUUIDTest.failUnlessEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.LegacyShortUUIDTest.failUnlessRaises",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.LegacyShortUUIDTest.id",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def id(self):\n        return \"%s.%s\" % (strclass(self.__class__), self._testMethodName)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.LegacyShortUUIDTest.run",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, result=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "result": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def run(self, result=None):\n        if result is None:\n            result = self.defaultTestResult()\n            startTestRun = getattr(result, 'startTestRun', None)\n            stopTestRun = getattr(result, 'stopTestRun', None)\n            if startTestRun is not None:\n                startTestRun()\n        else:\n            stopTestRun = None\n\n        result.startTest(self)\n        try:\n            testMethod = getattr(self, self._testMethodName)\n            if (getattr(self.__class__, \"__unittest_skip__\", False) or\n                getattr(testMethod, \"__unittest_skip__\", False)):\n                # If the class or method was skipped.\n                skip_why = (getattr(self.__class__, '__unittest_skip_why__', '')\n                            or getattr(testMethod, '__unittest_skip_why__', ''))\n                self._addSkip(result, self, skip_why)\n                return result\n\n            expecting_failure = (\n                getattr(self, \"__unittest_expecting_failure__\", False) or\n                getattr(testMethod, \"__unittest_expecting_failure__\", False)\n            )\n            outcome = _Outcome(result)\n            try:\n                self._outcome = outcome\n\n                with outcome.testPartExecutor(self):\n                    self._callSetUp()\n                if outcome.success:\n                    outcome.expecting_failure = expecting_failure\n                    with outcome.testPartExecutor(self, isTest=True):\n                        self._callTestMethod(testMethod)\n                    outcome.expecting_failure = False\n                    with outcome.testPartExecutor(self):\n                        self._callTearDown()\n\n                self.doCleanups()\n                for test, reason in outcome.skipped:\n                    self._addSkip(result, test, reason)\n                self._feedErrorsToResult(result, outcome.errors)\n                if outcome.success:\n                    if expecting_failure:\n                        if outcome.expectedFailure:\n                            self._addExpectedFailure(result, outcome.expectedFailure)\n                        else:\n                            self._addUnexpectedSuccess(result)\n                    else:\n                        result.addSuccess(self)\n                return result\n            finally:\n                # explicitly break reference cycles:\n                # outcome.errors -> frame -> outcome -> outcome.errors\n                # outcome.expectedFailure -> frame -> outcome -> outcome.expectedFailure\n                outcome.errors.clear()\n                outcome.expectedFailure = None\n\n                # clear the outcome, no more needed\n                self._outcome = None\n\n        finally:\n            result.stopTest(self)\n            if stopTestRun is not None:\n                stopTestRun()\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.LegacyShortUUIDTest.setUp",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Hook method for setting up the test fixture before exercising it.",
      "source_code": "    def setUp(self):\n        \"Hook method for setting up the test fixture before exercising it.\"\n        pass\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.LegacyShortUUIDTest.shortDescription",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Returns a one-line description of the test, or None if no\ndescription has been provided.\n\nThe default implementation of this method returns the first line of\nthe specified test method's docstring.",
      "source_code": "    def shortDescription(self):\n        \"\"\"Returns a one-line description of the test, or None if no\n        description has been provided.\n\n        The default implementation of this method returns the first line of\n        the specified test method's docstring.\n        \"\"\"\n        doc = self._testMethodDoc\n        return doc.strip().split(\"\\n\")[0].strip() if doc else None\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.LegacyShortUUIDTest.skipTest",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, reason)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "reason": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Skip this test.",
      "source_code": "    def skipTest(self, reason):\n        \"\"\"Skip this test.\"\"\"\n        raise SkipTest(reason)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.LegacyShortUUIDTest.subTest",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, msg=<object object at 0x7e3e03b88ce0>, **params)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "<object object at 0x7e3e03b88ce0>",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "params": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [
        "contextlib.contextmanager"
      ],
      "examples": [],
      "docstring": "Return a context manager that will return the enclosed block\nof code in a subtest identified by the optional message and\nkeyword parameters.  A failure in the subtest marks the test\ncase as failed but resumes execution at the end of the enclosed\nblock, allowing further test code to be executed.",
      "source_code": "    @contextlib.contextmanager\n    def subTest(self, msg=_subtest_msg_sentinel, **params):\n        \"\"\"Return a context manager that will return the enclosed block\n        of code in a subtest identified by the optional message and\n        keyword parameters.  A failure in the subtest marks the test\n        case as failed but resumes execution at the end of the enclosed\n        block, allowing further test code to be executed.\n        \"\"\"\n        if self._outcome is None or not self._outcome.result_supports_subtests:\n            yield\n            return\n        parent = self._subtest\n        if parent is None:\n            params_map = _OrderedChainMap(params)\n        else:\n            params_map = parent.params.new_child(params)\n        self._subtest = _SubTest(self, msg, params_map)\n        try:\n            with self._outcome.testPartExecutor(self._subtest, isTest=True):\n                yield\n            if not self._outcome.success:\n                result = self._outcome.result\n                if result is not None and result.failfast:\n                    raise _ShouldStop\n            elif self._outcome.expectedFailure:\n                # If the test is expecting a failure, we really want to\n                # stop now and register the expected failure.\n                raise _ShouldStop\n        finally:\n            self._subtest = parent\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.LegacyShortUUIDTest.tearDown",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Hook method for deconstructing the test fixture after testing it.",
      "source_code": "    def tearDown(self):\n        \"Hook method for deconstructing the test fixture after testing it.\"\n        pass\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.LegacyShortUUIDTest.test_alphabet",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def test_alphabet(self):\n        backup_alphabet = get_alphabet()\n\n        alphabet = \"01\"\n        set_alphabet(alphabet)\n        self.assertEqual(alphabet, get_alphabet())\n\n        set_alphabet(\"01010101010101\")\n        self.assertEqual(alphabet, get_alphabet())\n\n        self.assertEqual(set(uuid()), set(\"01\"))\n        self.assertTrue(116 < len(uuid()) < 140)\n\n        u = uuid4()\n        self.assertEqual(u, decode(encode(u)))\n\n        u = uuid()\n        self.assertEqual(u, encode(decode(u)))\n\n        self.assertRaises(ValueError, set_alphabet, \"1\")\n        self.assertRaises(ValueError, set_alphabet, \"1111111\")\n\n        set_alphabet(backup_alphabet)\n\n        self.assertRaises(ValueError, lambda x: ShortUUID(x), \"0\")\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.LegacyShortUUIDTest.test_decoding",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def test_decoding(self):\n        u = UUID(\"{3b1f8b40-222c-4a6e-b77e-779d5a94e21c}\")\n        self.assertEqual(decode(\"CXc85b4rqinB7s5J52TRYb\"), u)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.LegacyShortUUIDTest.test_encoding",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def test_encoding(self):\n        u = UUID(\"{3b1f8b40-222c-4a6e-b77e-779d5a94e21c}\")\n        self.assertEqual(encode(u), \"CXc85b4rqinB7s5J52TRYb\")\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.LegacyShortUUIDTest.test_generation",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def test_generation(self):\n        self.assertTrue(20 < len(uuid()) < 24)\n        self.assertTrue(20 < len(uuid(\"http://www.example.com/\")) < 24)\n        self.assertTrue(20 < len(uuid(\"HTTP://www.example.com/\")) < 24)\n        self.assertTrue(20 < len(uuid(\"example.com/\")) < 24)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.LegacyShortUUIDTest.test_random",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def test_random(self):\n        self.assertEqual(len(random()), 22)\n        for i in range(1, 100):\n            self.assertEqual(len(random(i)), i)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ShortUUID.decode",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, string: str, legacy: bool = False) -> uuid.UUID",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "string": {
          "default": null,
          "annotation": "<class 'str'>",
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "legacy": {
          "default": "False",
          "annotation": "<class 'bool'>",
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": "<class 'uuid.UUID'>",
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Decode a string according to the current alphabet into a UUID.\n\nRaises ValueError when encountering illegal characters or a too-long string.\n\nIf string too short, fills leftmost (MSB) bits with 0.\n\nPass `legacy=True` if your UUID was encoded with a ShortUUID version prior to\n1.0.0.",
      "source_code": "    def decode(self, string: str, legacy: bool = False) -> _uu.UUID:\n        \"\"\"\n        Decode a string according to the current alphabet into a UUID.\n\n        Raises ValueError when encountering illegal characters or a too-long string.\n\n        If string too short, fills leftmost (MSB) bits with 0.\n\n        Pass `legacy=True` if your UUID was encoded with a ShortUUID version prior to\n        1.0.0.\n        \"\"\"\n        if not isinstance(string, str):\n            raise ValueError(\"Input `string` must be a str.\")\n        if legacy:\n            string = string[::-1]\n        return _uu.UUID(int=string_to_int(string, self._alphabet))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ShortUUID.encode",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, uuid: uuid.UUID, pad_length: Optional[int] = None) -> str",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "uuid": {
          "default": null,
          "annotation": "<class 'uuid.UUID'>",
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "pad_length": {
          "default": "None",
          "annotation": "typing.Optional[int]",
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": "<class 'str'>",
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Encode a UUID into a string (LSB first) according to the alphabet.\n\nIf leftmost (MSB) bits are 0, the string might be shorter.",
      "source_code": "    def encode(self, uuid: _uu.UUID, pad_length: Optional[int] = None) -> str:\n        \"\"\"\n        Encode a UUID into a string (LSB first) according to the alphabet.\n\n        If leftmost (MSB) bits are 0, the string might be shorter.\n        \"\"\"\n        if not isinstance(uuid, _uu.UUID):\n            raise ValueError(\"Input `uuid` must be a UUID object.\")\n        if pad_length is None:\n            pad_length = self._length\n        return int_to_string(uuid.int, self._alphabet, padding=pad_length)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ShortUUID.encoded_length",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, num_bytes: int = 16) -> int",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "num_bytes": {
          "default": "16",
          "annotation": "<class 'int'>",
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": "<class 'int'>",
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Return the string length of the shortened UUID.",
      "source_code": "    def encoded_length(self, num_bytes: int = 16) -> int:\n        \"\"\"Return the string length of the shortened UUID.\"\"\"\n        factor = math.log(256) / math.log(self._alpha_len)\n        return int(math.ceil(factor * num_bytes))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ShortUUID.get_alphabet",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self) -> str",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": "<class 'str'>",
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Return the current alphabet used for new UUIDs.",
      "source_code": "    def get_alphabet(self) -> str:\n        \"\"\"Return the current alphabet used for new UUIDs.\"\"\"\n        return \"\".join(self._alphabet)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ShortUUID.random",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, length: Optional[int] = None) -> str",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "length": {
          "default": "None",
          "annotation": "typing.Optional[int]",
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": "<class 'str'>",
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Generate and return a cryptographically secure short random string of `length`.",
      "source_code": "    def random(self, length: Optional[int] = None) -> str:\n        \"\"\"Generate and return a cryptographically secure short random string of `length`.\"\"\"\n        if length is None:\n            length = self._length\n\n        return \"\".join(secrets.choice(self._alphabet) for _ in range(length))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ShortUUID.set_alphabet",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, alphabet: str) -> None",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "alphabet": {
          "default": null,
          "annotation": "<class 'str'>",
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": "None",
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Set the alphabet to be used for new UUIDs.",
      "source_code": "    def set_alphabet(self, alphabet: str) -> None:\n        \"\"\"Set the alphabet to be used for new UUIDs.\"\"\"\n        # Turn the alphabet into a set and sort it to prevent duplicates\n        # and ensure reproducibility.\n        new_alphabet = list(sorted(set(alphabet)))\n        if len(new_alphabet) > 1:\n            self._alphabet = new_alphabet\n            self._alpha_len = len(self._alphabet)\n        else:\n            raise ValueError(\"Alphabet with more than \" \"one unique symbols required.\")\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ShortUUID.uuid",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, name: Optional[str] = None, pad_length: Optional[int] = None) -> str",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "name": {
          "default": "None",
          "annotation": "typing.Optional[str]",
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "pad_length": {
          "default": "None",
          "annotation": "typing.Optional[int]",
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": "<class 'str'>",
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Generate and return a UUID.\n\nIf the name parameter is provided, set the namespace to the provided\nname and generate a UUID.",
      "source_code": "    def uuid(self, name: Optional[str] = None, pad_length: Optional[int] = None) -> str:\n        \"\"\"\n        Generate and return a UUID.\n\n        If the name parameter is provided, set the namespace to the provided\n        name and generate a UUID.\n        \"\"\"\n        if pad_length is None:\n            pad_length = self._length\n\n        # If no name is given, generate a random UUID.\n        if name is None:\n            u = _uu.uuid4()\n        elif name.lower().startswith((\"http://\", \"https://\")):\n            u = _uu.uuid5(_uu.NAMESPACE_URL, name)\n        else:\n            u = _uu.uuid5(_uu.NAMESPACE_DNS, name)\n        return self.encode(u, pad_length)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ShortUUIDPaddingTest.addCleanup",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, function, /, *args, **kwargs)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_ONLY",
          "description": null
        },
        "function": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_ONLY",
          "description": null
        },
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Add a function, with arguments, to be called when the test is\ncompleted. Functions added are called on a LIFO basis and are\ncalled after tearDown on test failure or success.\n\nCleanup items are called even if setUp fails (unlike tearDown).",
      "source_code": "    def addCleanup(self, function, /, *args, **kwargs):\n        \"\"\"Add a function, with arguments, to be called when the test is\n        completed. Functions added are called on a LIFO basis and are\n        called after tearDown on test failure or success.\n\n        Cleanup items are called even if setUp fails (unlike tearDown).\"\"\"\n        self._cleanups.append((function, args, kwargs))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ShortUUIDPaddingTest.addTypeEqualityFunc",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, typeobj, function)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "typeobj": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "function": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Add a type specific assertEqual style function to compare a type.\n\nThis method is for use by TestCase subclasses that need to register\ntheir own type equality functions to provide nicer error messages.\n\nArgs:\n    typeobj: The data type to call this function on when both values\n            are of the same type in assertEqual().\n    function: The callable taking two arguments and an optional\n            msg= argument that raises self.failureException with a\n            useful error message when the two arguments are not equal.",
      "source_code": "    def addTypeEqualityFunc(self, typeobj, function):\n        \"\"\"Add a type specific assertEqual style function to compare a type.\n\n        This method is for use by TestCase subclasses that need to register\n        their own type equality functions to provide nicer error messages.\n\n        Args:\n            typeobj: The data type to call this function on when both values\n                    are of the same type in assertEqual().\n            function: The callable taking two arguments and an optional\n                    msg= argument that raises self.failureException with a\n                    useful error message when the two arguments are not equal.\n        \"\"\"\n        self._type_equality_funcs[typeobj] = function\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ShortUUIDPaddingTest.assertAlmostEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, first, second, places=None, msg=None, delta=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "first": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "second": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "places": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "delta": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Fail if the two objects are unequal as determined by their\ndifference rounded to the given number of decimal places\n(default 7) and comparing to zero, or by comparing that the\ndifference between the two objects is more than the given\ndelta.\n\nNote that decimal places (from zero) are usually not the same\nas significant digits (measured from the most significant digit).\n\nIf the two objects compare equal then they will automatically\ncompare almost equal.",
      "source_code": "    def assertAlmostEqual(self, first, second, places=None, msg=None,\n                          delta=None):\n        \"\"\"Fail if the two objects are unequal as determined by their\n           difference rounded to the given number of decimal places\n           (default 7) and comparing to zero, or by comparing that the\n           difference between the two objects is more than the given\n           delta.\n\n           Note that decimal places (from zero) are usually not the same\n           as significant digits (measured from the most significant digit).\n\n           If the two objects compare equal then they will automatically\n           compare almost equal.\n        \"\"\"\n        if first == second:\n            # shortcut\n            return\n        if delta is not None and places is not None:\n            raise TypeError(\"specify delta or places not both\")\n\n        diff = abs(first - second)\n        if delta is not None:\n            if diff <= delta:\n                return\n\n            standardMsg = '%s != %s within %s delta (%s difference)' % (\n                safe_repr(first),\n                safe_repr(second),\n                safe_repr(delta),\n                safe_repr(diff))\n        else:\n            if places is None:\n                places = 7\n\n            if round(diff, places) == 0:\n                return\n\n            standardMsg = '%s != %s within %r places (%s difference)' % (\n                safe_repr(first),\n                safe_repr(second),\n                places,\n                safe_repr(diff))\n        msg = self._formatMessage(msg, standardMsg)\n        raise self.failureException(msg)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ShortUUIDPaddingTest.assertAlmostEquals",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ShortUUIDPaddingTest.assertCountEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, first, second, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "first": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "second": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Asserts that two iterables have the same elements, the same number of\ntimes, without regard to order.\n\n    self.assertEqual(Counter(list(first)),\n                     Counter(list(second)))\n\n Example:\n    - [0, 1, 1] and [1, 0, 1] compare equal.\n    - [0, 0, 1] and [0, 1] compare unequal.",
      "source_code": "    def assertCountEqual(self, first, second, msg=None):\n        \"\"\"Asserts that two iterables have the same elements, the same number of\n        times, without regard to order.\n\n            self.assertEqual(Counter(list(first)),\n                             Counter(list(second)))\n\n         Example:\n            - [0, 1, 1] and [1, 0, 1] compare equal.\n            - [0, 0, 1] and [0, 1] compare unequal.\n\n        \"\"\"\n        first_seq, second_seq = list(first), list(second)\n        try:\n            first = collections.Counter(first_seq)\n            second = collections.Counter(second_seq)\n        except TypeError:\n            # Handle case with unhashable elements\n            differences = _count_diff_all_purpose(first_seq, second_seq)\n        else:\n            if first == second:\n                return\n            differences = _count_diff_hashable(first_seq, second_seq)\n\n        if differences:\n            standardMsg = 'Element counts were not equal:\\n'\n            lines = ['First has %d, Second has %d:  %r' % diff for diff in differences]\n            diffMsg = '\\n'.join(lines)\n            standardMsg = self._truncateMessage(standardMsg, diffMsg)\n            msg = self._formatMessage(msg, standardMsg)\n            self.fail(msg)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ShortUUIDPaddingTest.assertDictContainsSubset",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, subset, dictionary, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "subset": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "dictionary": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Checks whether dictionary is a superset of subset.",
      "source_code": "    def assertDictContainsSubset(self, subset, dictionary, msg=None):\n        \"\"\"Checks whether dictionary is a superset of subset.\"\"\"\n        warnings.warn('assertDictContainsSubset is deprecated',\n                      DeprecationWarning,\n                      stacklevel=2)\n        missing = []\n        mismatched = []\n        for key, value in subset.items():\n            if key not in dictionary:\n                missing.append(key)\n            elif value != dictionary[key]:\n                mismatched.append('%s, expected: %s, actual: %s' %\n                                  (safe_repr(key), safe_repr(value),\n                                   safe_repr(dictionary[key])))\n\n        if not (missing or mismatched):\n            return\n\n        standardMsg = ''\n        if missing:\n            standardMsg = 'Missing: %s' % ','.join(safe_repr(m) for m in\n                                                    missing)\n        if mismatched:\n            if standardMsg:\n                standardMsg += '; '\n            standardMsg += 'Mismatched values: %s' % ','.join(mismatched)\n\n        self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ShortUUIDPaddingTest.assertDictEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, d1, d2, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "d1": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "d2": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def assertDictEqual(self, d1, d2, msg=None):\n        self.assertIsInstance(d1, dict, 'First argument is not a dictionary')\n        self.assertIsInstance(d2, dict, 'Second argument is not a dictionary')\n\n        if d1 != d2:\n            standardMsg = '%s != %s' % _common_shorten_repr(d1, d2)\n            diff = ('\\n' + '\\n'.join(difflib.ndiff(\n                           pprint.pformat(d1).splitlines(),\n                           pprint.pformat(d2).splitlines())))\n            standardMsg = self._truncateMessage(standardMsg, diff)\n            self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ShortUUIDPaddingTest.assertEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, first, second, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "first": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "second": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Fail if the two objects are unequal as determined by the '=='\noperator.",
      "source_code": "    def assertEqual(self, first, second, msg=None):\n        \"\"\"Fail if the two objects are unequal as determined by the '=='\n           operator.\n        \"\"\"\n        assertion_func = self._getAssertEqualityFunc(first, second)\n        assertion_func(first, second, msg=msg)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ShortUUIDPaddingTest.assertEquals",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ShortUUIDPaddingTest.assertFalse",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, expr, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "expr": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Check that the expression is false.",
      "source_code": "    def assertFalse(self, expr, msg=None):\n        \"\"\"Check that the expression is false.\"\"\"\n        if expr:\n            msg = self._formatMessage(msg, \"%s is not false\" % safe_repr(expr))\n            raise self.failureException(msg)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ShortUUIDPaddingTest.assertGreater",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, a, b, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "a": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "b": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Just like self.assertTrue(a > b), but with a nicer default message.",
      "source_code": "    def assertGreater(self, a, b, msg=None):\n        \"\"\"Just like self.assertTrue(a > b), but with a nicer default message.\"\"\"\n        if not a > b:\n            standardMsg = '%s not greater than %s' % (safe_repr(a), safe_repr(b))\n            self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ShortUUIDPaddingTest.assertGreaterEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, a, b, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "a": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "b": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Just like self.assertTrue(a >= b), but with a nicer default message.",
      "source_code": "    def assertGreaterEqual(self, a, b, msg=None):\n        \"\"\"Just like self.assertTrue(a >= b), but with a nicer default message.\"\"\"\n        if not a >= b:\n            standardMsg = '%s not greater than or equal to %s' % (safe_repr(a), safe_repr(b))\n            self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ShortUUIDPaddingTest.assertIn",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, member, container, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "member": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "container": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Just like self.assertTrue(a in b), but with a nicer default message.",
      "source_code": "    def assertIn(self, member, container, msg=None):\n        \"\"\"Just like self.assertTrue(a in b), but with a nicer default message.\"\"\"\n        if member not in container:\n            standardMsg = '%s not found in %s' % (safe_repr(member),\n                                                  safe_repr(container))\n            self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ShortUUIDPaddingTest.assertIs",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, expr1, expr2, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "expr1": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "expr2": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Just like self.assertTrue(a is b), but with a nicer default message.",
      "source_code": "    def assertIs(self, expr1, expr2, msg=None):\n        \"\"\"Just like self.assertTrue(a is b), but with a nicer default message.\"\"\"\n        if expr1 is not expr2:\n            standardMsg = '%s is not %s' % (safe_repr(expr1),\n                                             safe_repr(expr2))\n            self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ShortUUIDPaddingTest.assertIsInstance",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, obj, cls, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "obj": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "cls": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Same as self.assertTrue(isinstance(obj, cls)), with a nicer\ndefault message.",
      "source_code": "    def assertIsInstance(self, obj, cls, msg=None):\n        \"\"\"Same as self.assertTrue(isinstance(obj, cls)), with a nicer\n        default message.\"\"\"\n        if not isinstance(obj, cls):\n            standardMsg = '%s is not an instance of %r' % (safe_repr(obj), cls)\n            self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ShortUUIDPaddingTest.assertIsNone",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, obj, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "obj": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Same as self.assertTrue(obj is None), with a nicer default message.",
      "source_code": "    def assertIsNone(self, obj, msg=None):\n        \"\"\"Same as self.assertTrue(obj is None), with a nicer default message.\"\"\"\n        if obj is not None:\n            standardMsg = '%s is not None' % (safe_repr(obj),)\n            self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ShortUUIDPaddingTest.assertIsNot",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, expr1, expr2, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "expr1": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "expr2": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Just like self.assertTrue(a is not b), but with a nicer default message.",
      "source_code": "    def assertIsNot(self, expr1, expr2, msg=None):\n        \"\"\"Just like self.assertTrue(a is not b), but with a nicer default message.\"\"\"\n        if expr1 is expr2:\n            standardMsg = 'unexpectedly identical: %s' % (safe_repr(expr1),)\n            self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ShortUUIDPaddingTest.assertIsNotNone",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, obj, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "obj": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Included for symmetry with assertIsNone.",
      "source_code": "    def assertIsNotNone(self, obj, msg=None):\n        \"\"\"Included for symmetry with assertIsNone.\"\"\"\n        if obj is None:\n            standardMsg = 'unexpectedly None'\n            self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ShortUUIDPaddingTest.assertLess",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, a, b, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "a": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "b": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Just like self.assertTrue(a < b), but with a nicer default message.",
      "source_code": "    def assertLess(self, a, b, msg=None):\n        \"\"\"Just like self.assertTrue(a < b), but with a nicer default message.\"\"\"\n        if not a < b:\n            standardMsg = '%s not less than %s' % (safe_repr(a), safe_repr(b))\n            self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ShortUUIDPaddingTest.assertLessEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, a, b, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "a": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "b": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Just like self.assertTrue(a <= b), but with a nicer default message.",
      "source_code": "    def assertLessEqual(self, a, b, msg=None):\n        \"\"\"Just like self.assertTrue(a <= b), but with a nicer default message.\"\"\"\n        if not a <= b:\n            standardMsg = '%s not less than or equal to %s' % (safe_repr(a), safe_repr(b))\n            self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ShortUUIDPaddingTest.assertListEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, list1, list2, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "list1": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "list2": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "A list-specific equality assertion.\n\nArgs:\n    list1: The first list to compare.\n    list2: The second list to compare.\n    msg: Optional message to use on failure instead of a list of\n            differences.",
      "source_code": "    def assertListEqual(self, list1, list2, msg=None):\n        \"\"\"A list-specific equality assertion.\n\n        Args:\n            list1: The first list to compare.\n            list2: The second list to compare.\n            msg: Optional message to use on failure instead of a list of\n                    differences.\n\n        \"\"\"\n        self.assertSequenceEqual(list1, list2, msg, seq_type=list)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ShortUUIDPaddingTest.assertLogs",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, logger=None, level=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "logger": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "level": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Fail unless a log message of level *level* or higher is emitted\non *logger_name* or its children.  If omitted, *level* defaults to\nINFO and *logger* defaults to the root logger.\n\nThis method must be used as a context manager, and will yield\na recording object with two attributes: `output` and `records`.\nAt the end of the context manager, the `output` attribute will\nbe a list of the matching formatted log messages and the\n`records` attribute will be a list of the corresponding LogRecord\nobjects.\n\nExample::\n\n    with self.assertLogs('foo', level='INFO') as cm:\n        logging.getLogger('foo').info('first message')\n        logging.getLogger('foo.bar').error('second message')\n    self.assertEqual(cm.output, ['INFO:foo:first message',\n                                 'ERROR:foo.bar:second message'])",
      "source_code": "    def assertLogs(self, logger=None, level=None):\n        \"\"\"Fail unless a log message of level *level* or higher is emitted\n        on *logger_name* or its children.  If omitted, *level* defaults to\n        INFO and *logger* defaults to the root logger.\n\n        This method must be used as a context manager, and will yield\n        a recording object with two attributes: `output` and `records`.\n        At the end of the context manager, the `output` attribute will\n        be a list of the matching formatted log messages and the\n        `records` attribute will be a list of the corresponding LogRecord\n        objects.\n\n        Example::\n\n            with self.assertLogs('foo', level='INFO') as cm:\n                logging.getLogger('foo').info('first message')\n                logging.getLogger('foo.bar').error('second message')\n            self.assertEqual(cm.output, ['INFO:foo:first message',\n                                         'ERROR:foo.bar:second message'])\n        \"\"\"\n        # Lazy import to avoid importing logging if it is not needed.\n        from ._log import _AssertLogsContext\n        return _AssertLogsContext(self, logger, level, no_logs=False)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ShortUUIDPaddingTest.assertMultiLineEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, first, second, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "first": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "second": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Assert that two multi-line strings are equal.",
      "source_code": "    def assertMultiLineEqual(self, first, second, msg=None):\n        \"\"\"Assert that two multi-line strings are equal.\"\"\"\n        self.assertIsInstance(first, str, 'First argument is not a string')\n        self.assertIsInstance(second, str, 'Second argument is not a string')\n\n        if first != second:\n            # don't use difflib if the strings are too long\n            if (len(first) > self._diffThreshold or\n                len(second) > self._diffThreshold):\n                self._baseAssertEqual(first, second, msg)\n            firstlines = first.splitlines(keepends=True)\n            secondlines = second.splitlines(keepends=True)\n            if len(firstlines) == 1 and first.strip('\\r\\n') == first:\n                firstlines = [first + '\\n']\n                secondlines = [second + '\\n']\n            standardMsg = '%s != %s' % _common_shorten_repr(first, second)\n            diff = '\\n' + ''.join(difflib.ndiff(firstlines, secondlines))\n            standardMsg = self._truncateMessage(standardMsg, diff)\n            self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ShortUUIDPaddingTest.assertNoLogs",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, logger=None, level=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "logger": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "level": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Fail unless no log messages of level *level* or higher are emitted\non *logger_name* or its children.\n\nThis method must be used as a context manager.",
      "source_code": "    def assertNoLogs(self, logger=None, level=None):\n        \"\"\" Fail unless no log messages of level *level* or higher are emitted\n        on *logger_name* or its children.\n\n        This method must be used as a context manager.\n        \"\"\"\n        from ._log import _AssertLogsContext\n        return _AssertLogsContext(self, logger, level, no_logs=True)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ShortUUIDPaddingTest.assertNotAlmostEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, first, second, places=None, msg=None, delta=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "first": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "second": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "places": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "delta": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Fail if the two objects are equal as determined by their\ndifference rounded to the given number of decimal places\n(default 7) and comparing to zero, or by comparing that the\ndifference between the two objects is less than the given delta.\n\nNote that decimal places (from zero) are usually not the same\nas significant digits (measured from the most significant digit).\n\nObjects that are equal automatically fail.",
      "source_code": "    def assertNotAlmostEqual(self, first, second, places=None, msg=None,\n                             delta=None):\n        \"\"\"Fail if the two objects are equal as determined by their\n           difference rounded to the given number of decimal places\n           (default 7) and comparing to zero, or by comparing that the\n           difference between the two objects is less than the given delta.\n\n           Note that decimal places (from zero) are usually not the same\n           as significant digits (measured from the most significant digit).\n\n           Objects that are equal automatically fail.\n        \"\"\"\n        if delta is not None and places is not None:\n            raise TypeError(\"specify delta or places not both\")\n        diff = abs(first - second)\n        if delta is not None:\n            if not (first == second) and diff > delta:\n                return\n            standardMsg = '%s == %s within %s delta (%s difference)' % (\n                safe_repr(first),\n                safe_repr(second),\n                safe_repr(delta),\n                safe_repr(diff))\n        else:\n            if places is None:\n                places = 7\n            if not (first == second) and round(diff, places) != 0:\n                return\n            standardMsg = '%s == %s within %r places' % (safe_repr(first),\n                                                         safe_repr(second),\n                                                         places)\n\n        msg = self._formatMessage(msg, standardMsg)\n        raise self.failureException(msg)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ShortUUIDPaddingTest.assertNotAlmostEquals",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ShortUUIDPaddingTest.assertNotEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, first, second, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "first": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "second": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Fail if the two objects are equal as determined by the '!='\noperator.",
      "source_code": "    def assertNotEqual(self, first, second, msg=None):\n        \"\"\"Fail if the two objects are equal as determined by the '!='\n           operator.\n        \"\"\"\n        if not first != second:\n            msg = self._formatMessage(msg, '%s == %s' % (safe_repr(first),\n                                                          safe_repr(second)))\n            raise self.failureException(msg)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ShortUUIDPaddingTest.assertNotEquals",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ShortUUIDPaddingTest.assertNotIn",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, member, container, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "member": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "container": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Just like self.assertTrue(a not in b), but with a nicer default message.",
      "source_code": "    def assertNotIn(self, member, container, msg=None):\n        \"\"\"Just like self.assertTrue(a not in b), but with a nicer default message.\"\"\"\n        if member in container:\n            standardMsg = '%s unexpectedly found in %s' % (safe_repr(member),\n                                                        safe_repr(container))\n            self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ShortUUIDPaddingTest.assertNotIsInstance",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, obj, cls, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "obj": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "cls": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Included for symmetry with assertIsInstance.",
      "source_code": "    def assertNotIsInstance(self, obj, cls, msg=None):\n        \"\"\"Included for symmetry with assertIsInstance.\"\"\"\n        if isinstance(obj, cls):\n            standardMsg = '%s is an instance of %r' % (safe_repr(obj), cls)\n            self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ShortUUIDPaddingTest.assertNotRegex",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, text, unexpected_regex, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "text": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "unexpected_regex": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Fail the test if the text matches the regular expression.",
      "source_code": "    def assertNotRegex(self, text, unexpected_regex, msg=None):\n        \"\"\"Fail the test if the text matches the regular expression.\"\"\"\n        if isinstance(unexpected_regex, (str, bytes)):\n            unexpected_regex = re.compile(unexpected_regex)\n        match = unexpected_regex.search(text)\n        if match:\n            standardMsg = 'Regex matched: %r matches %r in %r' % (\n                text[match.start() : match.end()],\n                unexpected_regex.pattern,\n                text)\n            # _formatMessage ensures the longMessage option is respected\n            msg = self._formatMessage(msg, standardMsg)\n            raise self.failureException(msg)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ShortUUIDPaddingTest.assertNotRegexpMatches",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ShortUUIDPaddingTest.assertRaises",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, expected_exception, *args, **kwargs)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "expected_exception": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Fail unless an exception of class expected_exception is raised\nby the callable when invoked with specified positional and\nkeyword arguments. If a different type of exception is\nraised, it will not be caught, and the test case will be\ndeemed to have suffered an error, exactly as for an\nunexpected exception.\n\nIf called with the callable and arguments omitted, will return a\ncontext object used like this::\n\n     with self.assertRaises(SomeException):\n         do_something()\n\nAn optional keyword argument 'msg' can be provided when assertRaises\nis used as a context object.\n\nThe context manager keeps a reference to the exception as\nthe 'exception' attribute. This allows you to inspect the\nexception after the assertion::\n\n    with self.assertRaises(SomeException) as cm:\n        do_something()\n    the_exception = cm.exception\n    self.assertEqual(the_exception.error_code, 3)",
      "source_code": "    def assertRaises(self, expected_exception, *args, **kwargs):\n        \"\"\"Fail unless an exception of class expected_exception is raised\n           by the callable when invoked with specified positional and\n           keyword arguments. If a different type of exception is\n           raised, it will not be caught, and the test case will be\n           deemed to have suffered an error, exactly as for an\n           unexpected exception.\n\n           If called with the callable and arguments omitted, will return a\n           context object used like this::\n\n                with self.assertRaises(SomeException):\n                    do_something()\n\n           An optional keyword argument 'msg' can be provided when assertRaises\n           is used as a context object.\n\n           The context manager keeps a reference to the exception as\n           the 'exception' attribute. This allows you to inspect the\n           exception after the assertion::\n\n               with self.assertRaises(SomeException) as cm:\n                   do_something()\n               the_exception = cm.exception\n               self.assertEqual(the_exception.error_code, 3)\n        \"\"\"\n        context = _AssertRaisesContext(expected_exception, self)\n        try:\n            return context.handle('assertRaises', args, kwargs)\n        finally:\n            # bpo-23890: manually break a reference cycle\n            context = None\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ShortUUIDPaddingTest.assertRaisesRegex",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, expected_exception, expected_regex, *args, **kwargs)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "expected_exception": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "expected_regex": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Asserts that the message in a raised exception matches a regex.\n\nArgs:\n    expected_exception: Exception class expected to be raised.\n    expected_regex: Regex (re.Pattern object or string) expected\n            to be found in error message.\n    args: Function to be called and extra positional args.\n    kwargs: Extra kwargs.\n    msg: Optional message used in case of failure. Can only be used\n            when assertRaisesRegex is used as a context manager.",
      "source_code": "    def assertRaisesRegex(self, expected_exception, expected_regex,\n                          *args, **kwargs):\n        \"\"\"Asserts that the message in a raised exception matches a regex.\n\n        Args:\n            expected_exception: Exception class expected to be raised.\n            expected_regex: Regex (re.Pattern object or string) expected\n                    to be found in error message.\n            args: Function to be called and extra positional args.\n            kwargs: Extra kwargs.\n            msg: Optional message used in case of failure. Can only be used\n                    when assertRaisesRegex is used as a context manager.\n        \"\"\"\n        context = _AssertRaisesContext(expected_exception, self, expected_regex)\n        return context.handle('assertRaisesRegex', args, kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ShortUUIDPaddingTest.assertRaisesRegexp",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ShortUUIDPaddingTest.assertRegex",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, text, expected_regex, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "text": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "expected_regex": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Fail the test unless the text matches the regular expression.",
      "source_code": "    def assertRegex(self, text, expected_regex, msg=None):\n        \"\"\"Fail the test unless the text matches the regular expression.\"\"\"\n        if isinstance(expected_regex, (str, bytes)):\n            assert expected_regex, \"expected_regex must not be empty.\"\n            expected_regex = re.compile(expected_regex)\n        if not expected_regex.search(text):\n            standardMsg = \"Regex didn't match: %r not found in %r\" % (\n                expected_regex.pattern, text)\n            # _formatMessage ensures the longMessage option is respected\n            msg = self._formatMessage(msg, standardMsg)\n            raise self.failureException(msg)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ShortUUIDPaddingTest.assertRegexpMatches",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ShortUUIDPaddingTest.assertSequenceEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, seq1, seq2, msg=None, seq_type=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "seq1": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "seq2": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "seq_type": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "An equality assertion for ordered sequences (like lists and tuples).\n\nFor the purposes of this function, a valid ordered sequence type is one\nwhich can be indexed, has a length, and has an equality operator.\n\nArgs:\n    seq1: The first sequence to compare.\n    seq2: The second sequence to compare.\n    seq_type: The expected datatype of the sequences, or None if no\n            datatype should be enforced.\n    msg: Optional message to use on failure instead of a list of\n            differences.",
      "source_code": "    def assertSequenceEqual(self, seq1, seq2, msg=None, seq_type=None):\n        \"\"\"An equality assertion for ordered sequences (like lists and tuples).\n\n        For the purposes of this function, a valid ordered sequence type is one\n        which can be indexed, has a length, and has an equality operator.\n\n        Args:\n            seq1: The first sequence to compare.\n            seq2: The second sequence to compare.\n            seq_type: The expected datatype of the sequences, or None if no\n                    datatype should be enforced.\n            msg: Optional message to use on failure instead of a list of\n                    differences.\n        \"\"\"\n        if seq_type is not None:\n            seq_type_name = seq_type.__name__\n            if not isinstance(seq1, seq_type):\n                raise self.failureException('First sequence is not a %s: %s'\n                                        % (seq_type_name, safe_repr(seq1)))\n            if not isinstance(seq2, seq_type):\n                raise self.failureException('Second sequence is not a %s: %s'\n                                        % (seq_type_name, safe_repr(seq2)))\n        else:\n            seq_type_name = \"sequence\"\n\n        differing = None\n        try:\n            len1 = len(seq1)\n        except (TypeError, NotImplementedError):\n            differing = 'First %s has no length.    Non-sequence?' % (\n                    seq_type_name)\n\n        if differing is None:\n            try:\n                len2 = len(seq2)\n            except (TypeError, NotImplementedError):\n                differing = 'Second %s has no length.    Non-sequence?' % (\n                        seq_type_name)\n\n        if differing is None:\n            if seq1 == seq2:\n                return\n\n            differing = '%ss differ: %s != %s\\n' % (\n                    (seq_type_name.capitalize(),) +\n                    _common_shorten_repr(seq1, seq2))\n\n            for i in range(min(len1, len2)):\n                try:\n                    item1 = seq1[i]\n                except (TypeError, IndexError, NotImplementedError):\n                    differing += ('\\nUnable to index element %d of first %s\\n' %\n                                 (i, seq_type_name))\n                    break\n\n                try:\n                    item2 = seq2[i]\n                except (TypeError, IndexError, NotImplementedError):\n                    differing += ('\\nUnable to index element %d of second %s\\n' %\n                                 (i, seq_type_name))\n                    break\n\n                if item1 != item2:\n                    differing += ('\\nFirst differing element %d:\\n%s\\n%s\\n' %\n                                 ((i,) + _common_shorten_repr(item1, item2)))\n                    break\n            else:\n                if (len1 == len2 and seq_type is None and\n                    type(seq1) != type(seq2)):\n                    # The sequences are the same, but have differing types.\n                    return\n\n            if len1 > len2:\n                differing += ('\\nFirst %s contains %d additional '\n                             'elements.\\n' % (seq_type_name, len1 - len2))\n                try:\n                    differing += ('First extra element %d:\\n%s\\n' %\n                                  (len2, safe_repr(seq1[len2])))\n                except (TypeError, IndexError, NotImplementedError):\n                    differing += ('Unable to index element %d '\n                                  'of first %s\\n' % (len2, seq_type_name))\n            elif len1 < len2:\n                differing += ('\\nSecond %s contains %d additional '\n                             'elements.\\n' % (seq_type_name, len2 - len1))\n                try:\n                    differing += ('First extra element %d:\\n%s\\n' %\n                                  (len1, safe_repr(seq2[len1])))\n                except (TypeError, IndexError, NotImplementedError):\n                    differing += ('Unable to index element %d '\n                                  'of second %s\\n' % (len1, seq_type_name))\n        standardMsg = differing\n        diffMsg = '\\n' + '\\n'.join(\n            difflib.ndiff(pprint.pformat(seq1).splitlines(),\n                          pprint.pformat(seq2).splitlines()))\n\n        standardMsg = self._truncateMessage(standardMsg, diffMsg)\n        msg = self._formatMessage(msg, standardMsg)\n        self.fail(msg)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ShortUUIDPaddingTest.assertSetEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, set1, set2, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "set1": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "set2": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "A set-specific equality assertion.\n\nArgs:\n    set1: The first set to compare.\n    set2: The second set to compare.\n    msg: Optional message to use on failure instead of a list of\n            differences.\n\nassertSetEqual uses ducktyping to support different types of sets, and\nis optimized for sets specifically (parameters must support a\ndifference method).",
      "source_code": "    def assertSetEqual(self, set1, set2, msg=None):\n        \"\"\"A set-specific equality assertion.\n\n        Args:\n            set1: The first set to compare.\n            set2: The second set to compare.\n            msg: Optional message to use on failure instead of a list of\n                    differences.\n\n        assertSetEqual uses ducktyping to support different types of sets, and\n        is optimized for sets specifically (parameters must support a\n        difference method).\n        \"\"\"\n        try:\n            difference1 = set1.difference(set2)\n        except TypeError as e:\n            self.fail('invalid type when attempting set difference: %s' % e)\n        except AttributeError as e:\n            self.fail('first argument does not support set difference: %s' % e)\n\n        try:\n            difference2 = set2.difference(set1)\n        except TypeError as e:\n            self.fail('invalid type when attempting set difference: %s' % e)\n        except AttributeError as e:\n            self.fail('second argument does not support set difference: %s' % e)\n\n        if not (difference1 or difference2):\n            return\n\n        lines = []\n        if difference1:\n            lines.append('Items in the first set but not the second:')\n            for item in difference1:\n                lines.append(repr(item))\n        if difference2:\n            lines.append('Items in the second set but not the first:')\n            for item in difference2:\n                lines.append(repr(item))\n\n        standardMsg = '\\n'.join(lines)\n        self.fail(self._formatMessage(msg, standardMsg))\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ShortUUIDPaddingTest.assertTrue",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, expr, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "expr": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Check that the expression is true.",
      "source_code": "    def assertTrue(self, expr, msg=None):\n        \"\"\"Check that the expression is true.\"\"\"\n        if not expr:\n            msg = self._formatMessage(msg, \"%s is not true\" % safe_repr(expr))\n            raise self.failureException(msg)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ShortUUIDPaddingTest.assertTupleEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, tuple1, tuple2, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "tuple1": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "tuple2": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "A tuple-specific equality assertion.\n\nArgs:\n    tuple1: The first tuple to compare.\n    tuple2: The second tuple to compare.\n    msg: Optional message to use on failure instead of a list of\n            differences.",
      "source_code": "    def assertTupleEqual(self, tuple1, tuple2, msg=None):\n        \"\"\"A tuple-specific equality assertion.\n\n        Args:\n            tuple1: The first tuple to compare.\n            tuple2: The second tuple to compare.\n            msg: Optional message to use on failure instead of a list of\n                    differences.\n        \"\"\"\n        self.assertSequenceEqual(tuple1, tuple2, msg, seq_type=tuple)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ShortUUIDPaddingTest.assertWarns",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, expected_warning, *args, **kwargs)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "expected_warning": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Fail unless a warning of class warnClass is triggered\nby the callable when invoked with specified positional and\nkeyword arguments.  If a different type of warning is\ntriggered, it will not be handled: depending on the other\nwarning filtering rules in effect, it might be silenced, printed\nout, or raised as an exception.\n\nIf called with the callable and arguments omitted, will return a\ncontext object used like this::\n\n     with self.assertWarns(SomeWarning):\n         do_something()\n\nAn optional keyword argument 'msg' can be provided when assertWarns\nis used as a context object.\n\nThe context manager keeps a reference to the first matching\nwarning as the 'warning' attribute; similarly, the 'filename'\nand 'lineno' attributes give you information about the line\nof Python code from which the warning was triggered.\nThis allows you to inspect the warning after the assertion::\n\n    with self.assertWarns(SomeWarning) as cm:\n        do_something()\n    the_warning = cm.warning\n    self.assertEqual(the_warning.some_attribute, 147)",
      "source_code": "    def assertWarns(self, expected_warning, *args, **kwargs):\n        \"\"\"Fail unless a warning of class warnClass is triggered\n           by the callable when invoked with specified positional and\n           keyword arguments.  If a different type of warning is\n           triggered, it will not be handled: depending on the other\n           warning filtering rules in effect, it might be silenced, printed\n           out, or raised as an exception.\n\n           If called with the callable and arguments omitted, will return a\n           context object used like this::\n\n                with self.assertWarns(SomeWarning):\n                    do_something()\n\n           An optional keyword argument 'msg' can be provided when assertWarns\n           is used as a context object.\n\n           The context manager keeps a reference to the first matching\n           warning as the 'warning' attribute; similarly, the 'filename'\n           and 'lineno' attributes give you information about the line\n           of Python code from which the warning was triggered.\n           This allows you to inspect the warning after the assertion::\n\n               with self.assertWarns(SomeWarning) as cm:\n                   do_something()\n               the_warning = cm.warning\n               self.assertEqual(the_warning.some_attribute, 147)\n        \"\"\"\n        context = _AssertWarnsContext(expected_warning, self)\n        return context.handle('assertWarns', args, kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ShortUUIDPaddingTest.assertWarnsRegex",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, expected_warning, expected_regex, *args, **kwargs)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "expected_warning": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "expected_regex": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Asserts that the message in a triggered warning matches a regexp.\nBasic functioning is similar to assertWarns() with the addition\nthat only warnings whose messages also match the regular expression\nare considered successful matches.\n\nArgs:\n    expected_warning: Warning class expected to be triggered.\n    expected_regex: Regex (re.Pattern object or string) expected\n            to be found in error message.\n    args: Function to be called and extra positional args.\n    kwargs: Extra kwargs.\n    msg: Optional message used in case of failure. Can only be used\n            when assertWarnsRegex is used as a context manager.",
      "source_code": "    def assertWarnsRegex(self, expected_warning, expected_regex,\n                         *args, **kwargs):\n        \"\"\"Asserts that the message in a triggered warning matches a regexp.\n        Basic functioning is similar to assertWarns() with the addition\n        that only warnings whose messages also match the regular expression\n        are considered successful matches.\n\n        Args:\n            expected_warning: Warning class expected to be triggered.\n            expected_regex: Regex (re.Pattern object or string) expected\n                    to be found in error message.\n            args: Function to be called and extra positional args.\n            kwargs: Extra kwargs.\n            msg: Optional message used in case of failure. Can only be used\n                    when assertWarnsRegex is used as a context manager.\n        \"\"\"\n        context = _AssertWarnsContext(expected_warning, self, expected_regex)\n        return context.handle('assertWarnsRegex', args, kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ShortUUIDPaddingTest.assert_",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ShortUUIDPaddingTest.countTestCases",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def countTestCases(self):\n        return 1\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ShortUUIDPaddingTest.debug",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Run the test without collecting errors in a TestResult",
      "source_code": "    def debug(self):\n        \"\"\"Run the test without collecting errors in a TestResult\"\"\"\n        testMethod = getattr(self, self._testMethodName)\n        if (getattr(self.__class__, \"__unittest_skip__\", False) or\n            getattr(testMethod, \"__unittest_skip__\", False)):\n            # If the class or method was skipped.\n            skip_why = (getattr(self.__class__, '__unittest_skip_why__', '')\n                        or getattr(testMethod, '__unittest_skip_why__', ''))\n            raise SkipTest(skip_why)\n\n        self._callSetUp()\n        self._callTestMethod(testMethod)\n        self._callTearDown()\n        while self._cleanups:\n            function, args, kwargs = self._cleanups.pop()\n            self._callCleanup(function, *args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ShortUUIDPaddingTest.defaultTestResult",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def defaultTestResult(self):\n        return result.TestResult()\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ShortUUIDPaddingTest.doCleanups",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Execute all cleanup functions. Normally called for you after\ntearDown.",
      "source_code": "    def doCleanups(self):\n        \"\"\"Execute all cleanup functions. Normally called for you after\n        tearDown.\"\"\"\n        outcome = self._outcome or _Outcome()\n        while self._cleanups:\n            function, args, kwargs = self._cleanups.pop()\n            with outcome.testPartExecutor(self):\n                self._callCleanup(function, *args, **kwargs)\n\n        # return this for backwards compatibility\n        # even though we no longer use it internally\n        return outcome.success\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ShortUUIDPaddingTest.fail",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Fail immediately, with the given message.",
      "source_code": "    def fail(self, msg=None):\n        \"\"\"Fail immediately, with the given message.\"\"\"\n        raise self.failureException(msg)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ShortUUIDPaddingTest.failIf",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ShortUUIDPaddingTest.failIfAlmostEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ShortUUIDPaddingTest.failIfEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ShortUUIDPaddingTest.failUnless",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ShortUUIDPaddingTest.failUnlessAlmostEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ShortUUIDPaddingTest.failUnlessEqual",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ShortUUIDPaddingTest.failUnlessRaises",
      "module": "shortuuid.test_shortuuid",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                'Please use {0} instead.'.format(original_func.__name__),\n                DeprecationWarning, 2)\n            return original_func(*args, **kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ShortUUIDPaddingTest.id",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def id(self):\n        return \"%s.%s\" % (strclass(self.__class__), self._testMethodName)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ShortUUIDPaddingTest.run",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, result=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "result": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def run(self, result=None):\n        if result is None:\n            result = self.defaultTestResult()\n            startTestRun = getattr(result, 'startTestRun', None)\n            stopTestRun = getattr(result, 'stopTestRun', None)\n            if startTestRun is not None:\n                startTestRun()\n        else:\n            stopTestRun = None\n\n        result.startTest(self)\n        try:\n            testMethod = getattr(self, self._testMethodName)\n            if (getattr(self.__class__, \"__unittest_skip__\", False) or\n                getattr(testMethod, \"__unittest_skip__\", False)):\n                # If the class or method was skipped.\n                skip_why = (getattr(self.__class__, '__unittest_skip_why__', '')\n                            or getattr(testMethod, '__unittest_skip_why__', ''))\n                self._addSkip(result, self, skip_why)\n                return result\n\n            expecting_failure = (\n                getattr(self, \"__unittest_expecting_failure__\", False) or\n                getattr(testMethod, \"__unittest_expecting_failure__\", False)\n            )\n            outcome = _Outcome(result)\n            try:\n                self._outcome = outcome\n\n                with outcome.testPartExecutor(self):\n                    self._callSetUp()\n                if outcome.success:\n                    outcome.expecting_failure = expecting_failure\n                    with outcome.testPartExecutor(self, isTest=True):\n                        self._callTestMethod(testMethod)\n                    outcome.expecting_failure = False\n                    with outcome.testPartExecutor(self):\n                        self._callTearDown()\n\n                self.doCleanups()\n                for test, reason in outcome.skipped:\n                    self._addSkip(result, test, reason)\n                self._feedErrorsToResult(result, outcome.errors)\n                if outcome.success:\n                    if expecting_failure:\n                        if outcome.expectedFailure:\n                            self._addExpectedFailure(result, outcome.expectedFailure)\n                        else:\n                            self._addUnexpectedSuccess(result)\n                    else:\n                        result.addSuccess(self)\n                return result\n            finally:\n                # explicitly break reference cycles:\n                # outcome.errors -> frame -> outcome -> outcome.errors\n                # outcome.expectedFailure -> frame -> outcome -> outcome.expectedFailure\n                outcome.errors.clear()\n                outcome.expectedFailure = None\n\n                # clear the outcome, no more needed\n                self._outcome = None\n\n        finally:\n            result.stopTest(self)\n            if stopTestRun is not None:\n                stopTestRun()\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ShortUUIDPaddingTest.setUp",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Hook method for setting up the test fixture before exercising it.",
      "source_code": "    def setUp(self):\n        \"Hook method for setting up the test fixture before exercising it.\"\n        pass\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ShortUUIDPaddingTest.shortDescription",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Returns a one-line description of the test, or None if no\ndescription has been provided.\n\nThe default implementation of this method returns the first line of\nthe specified test method's docstring.",
      "source_code": "    def shortDescription(self):\n        \"\"\"Returns a one-line description of the test, or None if no\n        description has been provided.\n\n        The default implementation of this method returns the first line of\n        the specified test method's docstring.\n        \"\"\"\n        doc = self._testMethodDoc\n        return doc.strip().split(\"\\n\")[0].strip() if doc else None\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ShortUUIDPaddingTest.skipTest",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, reason)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "reason": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Skip this test.",
      "source_code": "    def skipTest(self, reason):\n        \"\"\"Skip this test.\"\"\"\n        raise SkipTest(reason)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ShortUUIDPaddingTest.subTest",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self, msg=<object object at 0x7e3e03b88ce0>, **params)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "<object object at 0x7e3e03b88ce0>",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "params": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [
        "contextlib.contextmanager"
      ],
      "examples": [],
      "docstring": "Return a context manager that will return the enclosed block\nof code in a subtest identified by the optional message and\nkeyword parameters.  A failure in the subtest marks the test\ncase as failed but resumes execution at the end of the enclosed\nblock, allowing further test code to be executed.",
      "source_code": "    @contextlib.contextmanager\n    def subTest(self, msg=_subtest_msg_sentinel, **params):\n        \"\"\"Return a context manager that will return the enclosed block\n        of code in a subtest identified by the optional message and\n        keyword parameters.  A failure in the subtest marks the test\n        case as failed but resumes execution at the end of the enclosed\n        block, allowing further test code to be executed.\n        \"\"\"\n        if self._outcome is None or not self._outcome.result_supports_subtests:\n            yield\n            return\n        parent = self._subtest\n        if parent is None:\n            params_map = _OrderedChainMap(params)\n        else:\n            params_map = parent.params.new_child(params)\n        self._subtest = _SubTest(self, msg, params_map)\n        try:\n            with self._outcome.testPartExecutor(self._subtest, isTest=True):\n                yield\n            if not self._outcome.success:\n                result = self._outcome.result\n                if result is not None and result.failfast:\n                    raise _ShouldStop\n            elif self._outcome.expectedFailure:\n                # If the test is expecting a failure, we really want to\n                # stop now and register the expected failure.\n                raise _ShouldStop\n        finally:\n            self._subtest = parent\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ShortUUIDPaddingTest.tearDown",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Hook method for deconstructing the test fixture after testing it.",
      "source_code": "    def tearDown(self):\n        \"Hook method for deconstructing the test fixture after testing it.\"\n        pass\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ShortUUIDPaddingTest.test_consistency",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def test_consistency(self):\n        su = ShortUUID()\n        num_iterations = 1000\n        uid_lengths = defaultdict(int)\n\n        for count in range(num_iterations):\n            random_uid = uuid4()\n            encoded_random = su.encode(random_uid)\n            uid_lengths[len(encoded_random)] += 1\n            decoded_random = su.decode(encoded_random)\n\n            self.assertEqual(random_uid, decoded_random)\n\n        self.assertEqual(len(uid_lengths), 1)\n        uid_length = next(iter(uid_lengths.keys()))  # Get the 1 value\n\n        self.assertEqual(uid_lengths[uid_length], num_iterations)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ShortUUIDPaddingTest.test_decoding",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def test_decoding(self):\n        su = ShortUUID()\n        random_uid = uuid4()\n        smallest_uid = UUID(int=0)\n\n        encoded_random = su.encode(random_uid)\n        encoded_small = su.encode(smallest_uid)\n\n        self.assertEqual(su.decode(encoded_small), smallest_uid)\n        self.assertEqual(su.decode(encoded_random), random_uid)\n"
    },
    {
      "type": "method",
      "qualified_name": "shortuuid.test_shortuuid.ShortUUIDPaddingTest.test_padding",
      "module": "shortuuid.test_shortuuid",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def test_padding(self):\n        su = ShortUUID()\n        random_uid = uuid4()\n        smallest_uid = UUID(int=0)\n\n        encoded_random = su.encode(random_uid)\n        encoded_small = su.encode(smallest_uid)\n\n        self.assertEqual(len(encoded_random), len(encoded_small))\n"
    }
  ]
}