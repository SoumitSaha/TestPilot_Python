{
  "pyfiglet": [
    {
      "type": "function",
      "qualified_name": "pyfiglet.color_to_ansi",
      "module": "pyfiglet",
      "signature": "(color, isBackground)",
      "parameters": {
        "color": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "isBackground": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "def color_to_ansi(color, isBackground):\n    if not color:\n        return ''\n    color = color.upper()\n    if color.count(';') > 0 and color.count(';') != 2:\n        raise InvalidColor('Specified color \\'{}\\' not a valid color in R;G;B format')\n    elif color.count(';') == 0 and color not in COLOR_CODES:\n        raise InvalidColor('Specified color \\'{}\\' not found in ANSI COLOR_CODES list'.format(color))\n\n    if color in COLOR_CODES:\n        ansiCode = COLOR_CODES[color]\n        if isBackground:\n            ansiCode += 10\n    else:\n        ansiCode = 48 if isBackground else 38\n        ansiCode = '{};2;{}'.format(ansiCode, color)\n\n    return '\\033[{}m'.format(ansiCode)\n"
    },
    {
      "type": "function",
      "qualified_name": "pyfiglet.figlet_format",
      "module": "pyfiglet",
      "signature": "(text, font='standard', **kwargs)",
      "parameters": {
        "text": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "font": {
          "default": "standard",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "def figlet_format(text, font=DEFAULT_FONT, **kwargs):\n    fig = Figlet(font, **kwargs)\n    return fig.renderText(text)\n"
    },
    {
      "type": "function",
      "qualified_name": "pyfiglet.main",
      "module": "pyfiglet",
      "signature": "()",
      "parameters": {},
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "def main():\n    parser = OptionParser(version=__version__,\n                          usage='%prog [options] [text..]')\n    parser.add_option('-f', '--font', default=DEFAULT_FONT,\n                      help='font to render with (default: %default)',\n                      metavar='FONT')\n    parser.add_option('-D', '--direction', type='choice',\n                      choices=('auto', 'left-to-right', 'right-to-left'),\n                      default='auto', metavar='DIRECTION',\n                      help='set direction text will be formatted in '\n                           '(default: %default)')\n    parser.add_option('-j', '--justify', type='choice',\n                      choices=('auto', 'left', 'center', 'right'),\n                      default='auto', metavar='SIDE',\n                      help='set justification, defaults to print direction')\n    parser.add_option('-w', '--width', type='int', default=80, metavar='COLS',\n                      help='set terminal width for wrapping/justification '\n                           '(default: %default)')\n    parser.add_option('-r', '--reverse', action='store_true', default=False,\n                      help='shows mirror image of output text')\n    parser.add_option('-n', '--normalize-surrounding-newlines', action='store_true', default=False,\n                      help='output has one empty line before and after')\n    parser.add_option('-s', '--strip-surrounding-newlines', action='store_true', default=False,\n                      help='removes empty leading and trailing lines')                      \n    parser.add_option('-F', '--flip', action='store_true', default=False,\n                      help='flips rendered output text over')\n    parser.add_option('-l', '--list_fonts', action='store_true', default=False,\n                      help='show installed fonts list')\n    parser.add_option('-i', '--info_font', action='store_true', default=False,\n                      help='show font\\'s information, use with -f FONT')\n    parser.add_option('-L', '--load', default=None,\n                      help='load and install the specified font definition')\n    parser.add_option('-c', '--color', default=':',\n                      help='''prints text with passed foreground color,\n                            --color=foreground:background\n                            --color=:background\\t\\t\\t # only background\n                            --color=foreground | foreground:\\t # only foreground\n                            --color=list\\t\\t\\t # list all colors\n                            COLOR = list[COLOR] | [0-255];[0-255];[0-255] (RGB)''')\n    opts, args = parser.parse_args()\n\n    if opts.list_fonts:\n        print('\\n'.join(sorted(FigletFont.getFonts())))\n        exit(0)\n\n    if opts.color == 'list':\n        print('[0-255];[0-255];[0-255] # RGB\\n' + '\\n'.join((sorted(COLOR_CODES.keys()))))\n        exit(0)\n\n    if opts.info_font:\n        print(FigletFont.infoFont(opts.font))\n        exit(0)\n\n    if opts.load:\n        FigletFont.installFonts(opts.load)\n        exit(0)\n\n    if len(args) == 0:\n        parser.print_help()\n        return 1\n\n    if sys.version_info < (3,):\n        args = [arg.decode('UTF-8') for arg in args]\n\n    text = ' '.join(args)\n\n    try:\n        f = Figlet(\n            font=opts.font, direction=opts.direction,\n            justify=opts.justify, width=opts.width,\n        )\n    except FontNotFound as err:\n        print(f\"pyfiglet error: requested font {opts.font!r} not found.\")\n        return 1\n\n    r = f.renderText(text)\n    if opts.reverse:\n        r = r.reverse()\n    if opts.flip:\n        r = r.flip()\n    if opts.strip_surrounding_newlines:\n        r = r.strip_surrounding_newlines()\n    elif opts.normalize_surrounding_newlines:\n        r = r.normalize_surrounding_newlines()\n\n    if sys.version_info > (3,):\n        # Set stdout to binary mode\n        sys.stdout = sys.stdout.detach()\n\n    ansiColors = parse_color(opts.color)\n    if ansiColors:\n        sys.stdout.write(ansiColors.encode('UTF-8'))\n\n    sys.stdout.write(r.encode('UTF-8'))\n    sys.stdout.write(b'\\n')\n\n    if ansiColors:\n        sys.stdout.write(RESET_COLORS)\n\n    return 0\n"
    },
    {
      "type": "function",
      "qualified_name": "pyfiglet.parse_color",
      "module": "pyfiglet",
      "signature": "(color)",
      "parameters": {
        "color": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "def parse_color(color):\n    foreground, _, background = color.partition(\":\")\n    ansiForeground = color_to_ansi(foreground, isBackground=False)\n    ansiBackground = color_to_ansi(background, isBackground=True)\n    return ansiForeground + ansiBackground\n"
    },
    {
      "type": "function",
      "qualified_name": "pyfiglet.print_figlet",
      "module": "pyfiglet",
      "signature": "(text, font='standard', colors=':', **kwargs)",
      "parameters": {
        "text": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "font": {
          "default": "standard",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "colors": {
          "default": ":",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "def print_figlet(text, font=DEFAULT_FONT, colors=\":\", **kwargs):\n    ansiColors = parse_color(colors)\n    if ansiColors:\n        sys.stdout.write(ansiColors)\n\n    print(figlet_format(text, font, **kwargs))\n\n    if ansiColors:\n        sys.stdout.write(RESET_COLORS.decode('UTF-8', 'replace'))\n        sys.stdout.flush()\n"
    },
    {
      "type": "function",
      "qualified_name": "pyfiglet.__main__.main",
      "module": "pyfiglet.__main__",
      "signature": "()",
      "parameters": {},
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "def main():\n    parser = OptionParser(version=__version__,\n                          usage='%prog [options] [text..]')\n    parser.add_option('-f', '--font', default=DEFAULT_FONT,\n                      help='font to render with (default: %default)',\n                      metavar='FONT')\n    parser.add_option('-D', '--direction', type='choice',\n                      choices=('auto', 'left-to-right', 'right-to-left'),\n                      default='auto', metavar='DIRECTION',\n                      help='set direction text will be formatted in '\n                           '(default: %default)')\n    parser.add_option('-j', '--justify', type='choice',\n                      choices=('auto', 'left', 'center', 'right'),\n                      default='auto', metavar='SIDE',\n                      help='set justification, defaults to print direction')\n    parser.add_option('-w', '--width', type='int', default=80, metavar='COLS',\n                      help='set terminal width for wrapping/justification '\n                           '(default: %default)')\n    parser.add_option('-r', '--reverse', action='store_true', default=False,\n                      help='shows mirror image of output text')\n    parser.add_option('-n', '--normalize-surrounding-newlines', action='store_true', default=False,\n                      help='output has one empty line before and after')\n    parser.add_option('-s', '--strip-surrounding-newlines', action='store_true', default=False,\n                      help='removes empty leading and trailing lines')                      \n    parser.add_option('-F', '--flip', action='store_true', default=False,\n                      help='flips rendered output text over')\n    parser.add_option('-l', '--list_fonts', action='store_true', default=False,\n                      help='show installed fonts list')\n    parser.add_option('-i', '--info_font', action='store_true', default=False,\n                      help='show font\\'s information, use with -f FONT')\n    parser.add_option('-L', '--load', default=None,\n                      help='load and install the specified font definition')\n    parser.add_option('-c', '--color', default=':',\n                      help='''prints text with passed foreground color,\n                            --color=foreground:background\n                            --color=:background\\t\\t\\t # only background\n                            --color=foreground | foreground:\\t # only foreground\n                            --color=list\\t\\t\\t # list all colors\n                            COLOR = list[COLOR] | [0-255];[0-255];[0-255] (RGB)''')\n    opts, args = parser.parse_args()\n\n    if opts.list_fonts:\n        print('\\n'.join(sorted(FigletFont.getFonts())))\n        exit(0)\n\n    if opts.color == 'list':\n        print('[0-255];[0-255];[0-255] # RGB\\n' + '\\n'.join((sorted(COLOR_CODES.keys()))))\n        exit(0)\n\n    if opts.info_font:\n        print(FigletFont.infoFont(opts.font))\n        exit(0)\n\n    if opts.load:\n        FigletFont.installFonts(opts.load)\n        exit(0)\n\n    if len(args) == 0:\n        parser.print_help()\n        return 1\n\n    if sys.version_info < (3,):\n        args = [arg.decode('UTF-8') for arg in args]\n\n    text = ' '.join(args)\n\n    try:\n        f = Figlet(\n            font=opts.font, direction=opts.direction,\n            justify=opts.justify, width=opts.width,\n        )\n    except FontNotFound as err:\n        print(f\"pyfiglet error: requested font {opts.font!r} not found.\")\n        return 1\n\n    r = f.renderText(text)\n    if opts.reverse:\n        r = r.reverse()\n    if opts.flip:\n        r = r.flip()\n    if opts.strip_surrounding_newlines:\n        r = r.strip_surrounding_newlines()\n    elif opts.normalize_surrounding_newlines:\n        r = r.normalize_surrounding_newlines()\n\n    if sys.version_info > (3,):\n        # Set stdout to binary mode\n        sys.stdout = sys.stdout.detach()\n\n    ansiColors = parse_color(opts.color)\n    if ansiColors:\n        sys.stdout.write(ansiColors.encode('UTF-8'))\n\n    sys.stdout.write(r.encode('UTF-8'))\n    sys.stdout.write(b'\\n')\n\n    if ansiColors:\n        sys.stdout.write(RESET_COLORS)\n\n    return 0\n"
    },
    {
      "type": "function",
      "qualified_name": "pyfiglet.test.banner",
      "module": "pyfiglet.test",
      "signature": "(text)",
      "parameters": {
        "text": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "def banner(text):\n    cprint(Figlet().renderText(text), \"blue\")\n"
    },
    {
      "type": "function",
      "qualified_name": "pyfiglet.test.cprint",
      "module": "pyfiglet.test",
      "signature": "(text, color)",
      "parameters": {
        "text": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "color": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def cprint(text, color):\n        print(text)\n"
    },
    {
      "type": "function",
      "qualified_name": "pyfiglet.test.dump",
      "module": "pyfiglet.test",
      "signature": "(text)",
      "parameters": {
        "text": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "def dump(text):\n    for line in text.split('\\n'):\n        print(repr(line))\n"
    },
    {
      "type": "function",
      "qualified_name": "pyfiglet.test.fail",
      "module": "pyfiglet.test",
      "signature": "(text)",
      "parameters": {
        "text": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "def fail(text):\n    cprint(text, 'red')\n"
    },
    {
      "type": "function",
      "qualified_name": "pyfiglet.test.main",
      "module": "pyfiglet.test",
      "signature": "()",
      "parameters": {},
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "def main():\n    parser = OptionParser(version=__version__)\n\n    parser.add_option('-s', '--show', action='store_true', default=False,\n                      help='pause at each failure and compare output '\n                           '(default: %default)')\n\n    opts, args = parser.parse_args()\n    test = Test(opts)\n    banner(\"TESTING one word\")\n    test.check_text(\"foo\", True)\n    banner(\"TESTING cut at space\")\n    test.check_text(\"This is a very long text with many spaces and little words\", False)\n    banner(\"TESTING cut at last char\")\n    test.check_text(\"Averylongwordthatwillbecutatsomepoint I hope\", False)\n    banner(\"TESTING explicit new line\")\n    test.check_text(\"line1\\nline2\", True)\n    if len(test.check_result()[0]) == 0:\n        return 0\n    else:\n        return 1\n"
    },
    {
      "type": "function",
      "qualified_name": "pyfiglet.test.win",
      "module": "pyfiglet.test",
      "signature": "(text)",
      "parameters": {
        "text": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "def win(text):\n    cprint(text, 'green')\n"
    },
    {
      "type": "class",
      "qualified_name": "pyfiglet.CharNotPrinted",
      "module": "pyfiglet",
      "signature": "(self, error)",
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Raised when the width is not sufficient to print a character",
      "source_code": "class CharNotPrinted(FigletError):\n    \"\"\"\n    Raised when the width is not sufficient to print a character\n    \"\"\"\n"
    },
    {
      "type": "class",
      "qualified_name": "pyfiglet.Figlet",
      "module": "pyfiglet",
      "signature": "(self, font='standard', direction='auto', justify='auto', width=80)",
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Main figlet class.",
      "source_code": "class Figlet(object):\n    \"\"\"\n    Main figlet class.\n    \"\"\"\n\n    def __init__(self, font=DEFAULT_FONT, direction='auto', justify='auto',\n                 width=80):\n        self.font = font\n        self._direction = direction\n        self._justify = justify\n        self.width = width\n        self.setFont()\n        self.engine = FigletRenderingEngine(base=self)\n\n    def setFont(self, **kwargs):\n        if 'font' in kwargs:\n            self.font = kwargs['font']\n\n        self.Font = FigletFont(font=self.font)\n\n    def getDirection(self):\n        if self._direction == 'auto':\n            direction = self.Font.printDirection\n            if direction == 0:\n                return 'left-to-right'\n            elif direction == 1:\n                return 'right-to-left'\n            else:\n                return 'left-to-right'\n\n        else:\n            return self._direction\n\n    direction = property(getDirection)\n\n    def getJustify(self):\n        if self._justify == 'auto':\n            if self.direction == 'left-to-right':\n                return 'left'\n            elif self.direction == 'right-to-left':\n                return 'right'\n\n        else:\n            return self._justify\n\n    justify = property(getJustify)\n\n    def renderText(self, text):\n        # wrapper method to engine\n        return self.engine.render(text)\n\n    def getFonts(self):\n        return self.Font.getFonts()\n"
    },
    {
      "type": "class",
      "qualified_name": "pyfiglet.FigletBuilder",
      "module": "pyfiglet",
      "signature": "(self, text, font, direction, width, justify)",
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Represent the internals of the build process",
      "source_code": "class FigletBuilder(object):\n    \"\"\"\n    Represent the internals of the build process\n    \"\"\"\n    def __init__(self, text, font, direction, width, justify):\n\n        self.text = list(map(ord, list(text)))\n        self.direction = direction\n        self.width = width\n        self.font = font\n        self.justify = justify\n\n        self.iterator = 0\n        self.maxSmush = 0\n        self.newBlankRegistered = False\n\n        self.curCharWidth = 0\n        self.prevCharWidth = 0\n        self.currentTotalWidth = 0\n\n        self.blankMarkers = list()\n        self.product = FigletProduct()\n        self.buffer = ['' for i in range(self.font.height)]\n\n        # constants.. lifted from figlet222\n        self.SM_EQUAL = 1    # smush equal chars (not hardblanks)\n        self.SM_LOWLINE = 2    # smush _ with any char in hierarchy\n        self.SM_HIERARCHY = 4    # hierarchy: |, /\\, [], {}, (), <>\n        self.SM_PAIR = 8    # hierarchy: [ + ] -> |, { + } -> |, ( + ) -> |\n        self.SM_BIGX = 16    # / + \\ -> X, > + < -> X\n        self.SM_HARDBLANK = 32    # hardblank + hardblank -> hardblank\n        self.SM_KERN = 64\n        self.SM_SMUSH = 128\n\n    # builder interface\n\n    def addCharToProduct(self):\n        curChar = self.getCurChar()\n\n        # if the character is a newline, we flush the buffer\n        if self.text[self.iterator] == ord(\"\\n\"):\n                self.blankMarkers.append(([row for row in self.buffer], self.iterator))\n                self.handleNewLine()\n                return None\n\n        if curChar is None:\n            return\n        if self.width < self.getCurWidth():\n            raise CharNotPrinted(\"Width is not enough to print this character\")\n        self.curCharWidth = self.getCurWidth()\n        self.maxSmush = self.currentSmushAmount(curChar)\n\n        self.currentTotalWidth = len(self.buffer[0]) + self.curCharWidth - self.maxSmush\n\n        if self.text[self.iterator] == ord(' '):\n            self.blankMarkers.append(([row for row in self.buffer], self.iterator))\n\n        if self.text[self.iterator] == ord('\\n'):\n            self.blankMarkers.append(([row for row in self.buffer], self.iterator))\n            self.handleNewLine()\n\n        if (self.currentTotalWidth >= self.width):\n            self.handleNewLine()\n        else:\n            for row in range(0, self.font.height):\n                self.addCurCharRowToBufferRow(curChar, row)\n\n\n        self.prevCharWidth = self.curCharWidth\n\n    def goToNextChar(self):\n        self.iterator += 1\n\n    def returnProduct(self):\n        \"\"\"\n        Returns the output string created by formatProduct\n        \"\"\"\n        if self.buffer[0] != '':\n            self.flushLastBuffer()\n        self.formatProduct()\n        return self.product.getString()\n\n    def isNotFinished(self):\n        ret = self.iterator < len(self.text)\n        return ret\n\n    # private\n\n    def flushLastBuffer(self):\n        self.product.append(self.buffer)\n\n    def formatProduct(self):\n        \"\"\"\n        This create the output string representation from\n        the internal representation of the product\n        \"\"\"\n        string_acc = ''\n        for buffer in self.product.queue:\n            buffer = self.justifyString(self.justify, buffer)\n            string_acc += self.replaceHardblanks(buffer)\n        self.product.buffer_string = string_acc\n\n    def getCharAt(self, i):\n        if i < 0 or i >= len(list(self.text)):\n            return None\n        c = self.text[i]\n\n        if c not in self.font.chars:\n            return None\n        else:\n            return self.font.chars[c]\n\n    def getCharWidthAt(self, i):\n        if i < 0 or i >= len(self.text):\n            return None\n        c = self.text[i]\n        if c not in self.font.chars:\n            return None\n        else:\n            return self.font.width[c]\n\n    def getCurChar(self):\n        return self.getCharAt(self.iterator)\n\n    def getCurWidth(self):\n        return self.getCharWidthAt(self.iterator)\n\n    def getLeftSmushedChar(self, i, addLeft):\n        idx = len(addLeft) - self.maxSmush + i\n        if idx >= 0 and idx < len(addLeft):\n            left = addLeft[idx]\n        else:\n            left = ''\n        return left, idx\n\n    def currentSmushAmount(self, curChar):\n        return self.smushAmount(self.buffer, curChar)\n\n    def updateSmushedCharInLeftBuffer(self, addLeft, idx, smushed):\n        l = list(addLeft)\n        if idx < 0 or idx > len(l):\n            return addLeft\n        l[idx] = smushed\n        addLeft = ''.join(l)\n        return addLeft\n\n    def smushRow(self, curChar, row):\n        addLeft = self.buffer[row]\n        addRight = curChar[row]\n\n        if self.direction == 'right-to-left':\n            addLeft, addRight = addRight, addLeft\n\n        for i in range(0, self.maxSmush):\n            left, idx = self.getLeftSmushedChar(i, addLeft)\n            right = addRight[i]\n            smushed = self.smushChars(left=left, right=right)\n            addLeft = self.updateSmushedCharInLeftBuffer(addLeft, idx, smushed)\n        return addLeft, addRight\n\n    def addCurCharRowToBufferRow(self, curChar, row):\n        addLeft, addRight = self.smushRow(curChar, row)\n        self.buffer[row] = addLeft + addRight[self.maxSmush:]\n\n    def cutBufferCommon(self):\n        self.currentTotalWidth = 0\n        self.buffer = ['' for i in range(self.font.height)]\n        self.blankMarkers = list()\n        self.prevCharWidth = 0\n        curChar = self.getCurChar()\n        if curChar is None:\n            return\n        self.maxSmush = self.currentSmushAmount(curChar)\n\n    def cutBufferAtLastBlank(self, saved_buffer, saved_iterator):\n        self.product.append(saved_buffer)\n        self.iterator = saved_iterator\n        self.cutBufferCommon()\n\n    def cutBufferAtLastChar(self):\n        self.product.append(self.buffer)\n        self.iterator -= 1\n        self.cutBufferCommon()\n\n    def blankExist(self, last_blank):\n        return last_blank != -1\n\n    def getLastBlank(self):\n        try:\n            saved_buffer, saved_iterator = self.blankMarkers.pop()\n        except IndexError:\n            return -1,-1\n        return (saved_buffer, saved_iterator)\n\n    def handleNewLine(self):\n        saved_buffer, saved_iterator = self.getLastBlank()\n        if self.blankExist(saved_iterator):\n            self.cutBufferAtLastBlank(saved_buffer, saved_iterator)\n        else:\n            self.cutBufferAtLastChar()\n\n    def justifyString(self, justify, buffer):\n        if justify == 'right':\n            for row in range(0, self.font.height):\n                buffer[row] = (\n                        ' ' * (self.width - len(buffer[row]) - 1)\n                        ) + buffer[row]\n        elif justify == 'center':\n            for row in range(0, self.font.height):\n                buffer[row] = (\n                        ' ' * int((self.width - len(buffer[row])) / 2)\n                        ) + buffer[row]\n        return buffer\n\n    def replaceHardblanks(self, buffer):\n        string = '\\n'.join(buffer) + '\\n'\n        string = string.replace(self.font.hardBlank, ' ')\n        return string\n\n    def smushAmount(self, buffer=[], curChar=[]):\n        \"\"\"\n        Calculate the amount of smushing we can do between this char and the\n        last If this is the first char it will throw a series of exceptions\n        which are caught and cause appropriate values to be set for later.\n\n        This differs from C figlet which will just get bogus values from\n        memory and then discard them after.\n        \"\"\"\n        if (self.font.smushMode & (self.SM_SMUSH | self.SM_KERN)) == 0:\n            return 0\n\n        maxSmush = self.curCharWidth\n        for row in range(0, self.font.height):\n            lineLeft = buffer[row]\n            lineRight = curChar[row]\n            if self.direction == 'right-to-left':\n                lineLeft, lineRight = lineRight, lineLeft\n\n            # Only strip ascii space to match figlet exactly.\n            linebd = len(lineLeft.rstrip(' ')) - 1\n            if linebd < 0:\n                linebd = 0\n\n            if linebd < len(lineLeft):\n                ch1 = lineLeft[linebd]\n            else:\n                linebd = 0\n                ch1 = ''\n\n            # Only strip ascii space to match figlet exactly.\n            charbd = len(lineRight) - len(lineRight.lstrip(' '))\n            if charbd < len(lineRight):\n                ch2 = lineRight[charbd]\n            else:\n                charbd = len(lineRight)\n                ch2 = ''\n\n            amt = charbd + len(lineLeft) - 1 - linebd\n\n            if ch1 == '' or ch1 == ' ':\n                amt += 1\n            elif (ch2 != ''\n                    and self.smushChars(left=ch1, right=ch2) is not None):\n                amt += 1\n\n            if amt < maxSmush:\n                maxSmush = amt\n\n        return maxSmush\n\n    def smushChars(self, left='', right=''):\n        \"\"\"\n        Given 2 characters which represent the edges rendered figlet\n        fonts where they would touch, see if they can be smushed together.\n        Returns None if this cannot or should not be done.\n        \"\"\"\n        # Don't use isspace because this also matches unicode chars that figlet\n        # treats as hard breaks\n        if left == ' ':\n            return right\n        if right == ' ':\n            return left\n\n        # Disallows overlapping if previous or current char has a width of 1 or\n        # zero\n        if (self.prevCharWidth < 2) or (self.curCharWidth < 2):\n            return\n\n        # kerning only\n        if (self.font.smushMode & self.SM_SMUSH) == 0:\n            return\n\n        # smushing by universal overlapping\n        if (self.font.smushMode & 63) == 0:\n            # Ensure preference to visiable characters.\n            if left == self.font.hardBlank:\n                return right\n            if right == self.font.hardBlank:\n                return left\n\n            # Ensures that the dominant (foreground)\n            # fig-character for overlapping is the latter in the\n            # user's text, not necessarily the rightmost character.\n            if self.direction == 'right-to-left':\n                return left\n            else:\n                return right\n\n        if self.font.smushMode & self.SM_HARDBLANK:\n            if (left == self.font.hardBlank\n                    and right == self.font.hardBlank):\n                return left\n\n        if (left == self.font.hardBlank\n                or right == self.font.hardBlank):\n            return\n\n        if self.font.smushMode & self.SM_EQUAL:\n            if left == right:\n                return left\n\n        smushes = ()\n\n        if self.font.smushMode & self.SM_LOWLINE:\n            smushes += (('_', r'|/\\[]{}()<>'),)\n\n        if self.font.smushMode & self.SM_HIERARCHY:\n            smushes += (\n                ('|', r'/\\[]{}()<>'),\n                (r'\\/', '[]{}()<>'),\n                ('[]', '{}()<>'),\n                ('{}', '()<>'),\n                ('()', '<>'),\n            )\n\n        for a, b in smushes:\n            if left in a and right in b:\n                return right\n            if right in a and left in b:\n                return left\n\n        if self.font.smushMode & self.SM_PAIR:\n            for pair in [left+right, right+left]:\n                if pair in ['[]', '{}', '()']:\n                    return '|'\n\n        if self.font.smushMode & self.SM_BIGX:\n            if (left == '/') and (right == '\\\\'):\n                return '|'\n            if (right == '/') and (left == '\\\\'):\n                return 'Y'\n            if (left == '>') and (right == '<'):\n                return 'X'\n        return\n"
    },
    {
      "type": "class",
      "qualified_name": "pyfiglet.FigletError",
      "module": "pyfiglet",
      "signature": "(self, error)",
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Common base class for all non-exit exceptions.",
      "source_code": "class FigletError(Exception):\n    def __init__(self, error):\n        self.error = error\n\n    def __str__(self):\n        return self.error\n"
    },
    {
      "type": "class",
      "qualified_name": "pyfiglet.FigletFont",
      "module": "pyfiglet",
      "signature": "(self, font='standard')",
      "return_description": null,
      "raises": [],
      "decorators": [
        "classmethod",
        "classmethod",
        "classmethod",
        "classmethod",
        "staticmethod"
      ],
      "examples": [],
      "docstring": "This class represents the currently loaded font, including\nmeta-data about how it should be displayed by default",
      "source_code": "class FigletFont(object):\n    \"\"\"\n    This class represents the currently loaded font, including\n    meta-data about how it should be displayed by default\n    \"\"\"\n\n    reMagicNumber = re.compile(r'^[tf]lf2.')\n    reEndMarker = re.compile(r'(.)\\s*$')\n\n    def __init__(self, font=DEFAULT_FONT):\n        self.font = font\n\n        self.comment = ''\n        self.chars = {}\n        self.width = {}\n        self.data = self.preloadFont(font)\n        self.loadFont()\n\n    @classmethod\n    def preloadFont(cls, font):\n        \"\"\"\n        Load font data if exist\n        \"\"\"\n        # Find a plausible looking font file.\n        data = None\n        font_path = None\n        for extension in ('tlf', 'flf'):\n            fn = '%s.%s' % (font, extension)\n            path = importlib.resources.files('pyfiglet.fonts').joinpath(fn)\n            if path.exists():\n                font_path = path\n                break\n            else:\n                for location in (\"./\", SHARED_DIRECTORY):\n                    full_name = os.path.join(location, fn)\n                    if os.path.isfile(full_name):\n                        font_path = pathlib.Path(full_name)\n                        break\n\n        # Unzip the first file if this file/stream looks like a ZIP file.\n        if font_path:\n            with font_path.open('rb') as f:\n                if zipfile.is_zipfile(f):\n                    with zipfile.ZipFile(f) as zip_file:\n                        zip_font = zip_file.open(zip_file.namelist()[0])\n                        data = zip_font.read()\n                else:\n                    # ZIP file check moves the current file pointer - reset to start of file.\n                    f.seek(0)\n                    data = f.read()\n\n        # Return the decoded data (if any).\n        if data:\n            return data.decode('UTF-8', 'replace')\n        else:\n            raise FontNotFound(font)\n\n    @classmethod\n    def isValidFont(cls, font):\n        if not font.endswith(('.flf', '.tlf')):\n            return False\n        f = None\n        full_file = os.path.join(SHARED_DIRECTORY, font)\n        if os.path.isfile(font):\n            f = open(font, 'rb')\n        elif os.path.isfile(full_file):\n            f = open(full_file, 'rb')\n        else:\n            f = importlib.resources.files('pyfiglet.fonts').joinpath(font).open('rb')\n\n        if zipfile.is_zipfile(f):\n            # If we have a match, the ZIP file spec says we should just read the first file in the ZIP.\n            with zipfile.ZipFile(f) as zip_file:\n                zip_font = zip_file.open(zip_file.namelist()[0])\n                header = zip_font.readline().decode('UTF-8', 'replace')\n        else:\n            # ZIP file check moves the current file pointer - reset to start of file.\n            f.seek(0)\n            header = f.readline().decode('UTF-8', 'replace')\n\n        f.close()\n\n        return cls.reMagicNumber.search(header)\n\n    @classmethod\n    def getFonts(cls):\n        all_files = importlib.resources.files('pyfiglet.fonts').iterdir()\n        if os.path.isdir(SHARED_DIRECTORY):\n             all_files = itertools.chain(all_files, pathlib.Path(SHARED_DIRECTORY).iterdir())\n        return [font.name.split('.', 2)[0] for font\n                in all_files\n                if font.is_file() and cls.isValidFont(font.name)]\n\n    @classmethod\n    def infoFont(cls, font, short=False):\n        \"\"\"\n        Get informations of font\n        \"\"\"\n        data = FigletFont.preloadFont(font)\n        infos = []\n        reStartMarker = re.compile(r\"\"\"\n            ^(FONT|COMMENT|FONTNAME_REGISTRY|FAMILY_NAME|FOUNDRY|WEIGHT_NAME|\n              SETWIDTH_NAME|SLANT|ADD_STYLE_NAME|PIXEL_SIZE|POINT_SIZE|\n              RESOLUTION_X|RESOLUTION_Y|SPACING|AVERAGE_WIDTH|\n              FONT_DESCENT|FONT_ASCENT|CAP_HEIGHT|X_HEIGHT|FACE_NAME|FULL_NAME|\n              COPYRIGHT|_DEC_|DEFAULT_CHAR|NOTICE|RELATIVE_).*\"\"\", re.VERBOSE)\n        reEndMarker = re.compile(r'^.*[@#$]$')\n        for line in data.splitlines()[0:100]:\n            if (cls.reMagicNumber.search(line) is None\n                    and reStartMarker.search(line) is None\n                    and reEndMarker.search(line) is None):\n                infos.append(line)\n        return '\\n'.join(infos) if not short else infos[0]\n\n    @staticmethod\n    def installFonts(file_name):\n        \"\"\"\n        Install the specified font file to this system.\n        \"\"\"\n        if hasattr(importlib.resources.files('pyfiglet'), 'resolve'):\n            # Figlet looks like a standard directory - so lets use that to install new fonts.\n            location = str(importlib.resources.files('pyfiglet.fonts'))\n        else:\n            # Figlet is installed using a zipped resource - don't try to upload to it.\n            location = SHARED_DIRECTORY\n\n        print(\"Installing {} to {}\".format(file_name, location))\n\n        # Make sure the required destination directory exists\n        if not os.path.exists(location):\n            os.makedirs(location)\n\n        # Copy the font definitions - unpacking any zip files as needed.\n        if os.path.splitext(file_name)[1].lower() == \".zip\":\n            # Ignore any structure inside the ZIP file.\n            with zipfile.ZipFile(file_name) as zip_file:\n                for font in zip_file.namelist():\n                    font_file = os.path.basename(font)\n                    if not font_file:\n                        continue\n                    with zip_file.open(font) as src:\n                        with open(os.path.join(location, font_file), \"wb\") as dest:\n                            shutil.copyfileobj(src, dest)\n        else:\n            shutil.copy(file_name, location)\n\n    def loadFont(self):\n        \"\"\"\n        Parse loaded font data for the rendering engine to consume\n        \"\"\"\n        try:\n            # Remove any unicode line splitting characters other\n            # than CRLF - to match figlet line parsing\n            data = re.sub(r\"[\\u0085\\u2028\\u2029]\", \" \", self.data)\n\n            # Parse first line of file, the header\n            data = data.splitlines()\n\n            header = data.pop(0)\n            if self.reMagicNumber.search(header) is None:\n                raise FontError('%s is not a valid figlet font' % self.font)\n\n            header = self.reMagicNumber.sub('', header)\n            header = header.split()\n\n            if len(header) < 6:\n                raise FontError('malformed header for %s' % self.font)\n\n            hardBlank = header[0]\n            height, baseLine, maxLength, oldLayout, commentLines = map(\n                int, header[1:6])\n            printDirection = fullLayout = None\n\n            # these are all optional for backwards compat\n            if len(header) > 6:\n                printDirection = int(header[6])\n            if len(header) > 7:\n                fullLayout = int(header[7])\n\n            # if the new layout style isn't available,\n            # convert old layout style. backwards compatibility\n            if fullLayout is None:\n                if oldLayout == 0:\n                    fullLayout = 64\n                elif oldLayout < 0:\n                    fullLayout = 0\n                else:\n                    fullLayout = (oldLayout & 31) | 128\n\n            # Some header information is stored for later, the rendering\n            # engine needs to know this stuff.\n            self.height = height\n            self.hardBlank = hardBlank\n            self.printDirection = printDirection\n            self.smushMode = fullLayout\n\n            # Strip out comment lines\n            for i in range(0, commentLines):\n                self.comment += data.pop(0)\n\n            def __char(data):\n                \"\"\"\n                Function loads one character in the internal array from font\n                file content\n                \"\"\"\n                end = None\n                width = 0\n                chars = []\n                for j in range(0, height):\n                    line = data.pop(0)\n                    if end is None:\n                        end = self.reEndMarker.search(line).group(1)\n                        end = re.compile(re.escape(end) + r'{1,2}\\s*$')\n\n                    line = end.sub('', line)\n\n                    if len(line) > width:\n                        width = len(line)\n                    chars.append(line)\n                return width, chars\n\n            # Load ASCII standard character set (32 - 127).\n            # Don't skip space definition as later rendering pipeline will\n            # ignore all missing chars and space is critical for the line\n            # breaking logic.\n            for i in range(32, 127):\n                width, letter = __char(data)\n                if i == 32 or ''.join(letter) != '':\n                    self.chars[i] = letter\n                    self.width[i] = width\n\n            # Load German Umlaute - the follow directly after standard character 127\n            if data:\n                for i in '\u00c4\u00d6\u00dc\u00e4\u00f6\u00fc\u00df':\n                    width, letter = __char(data)\n                    if ''.join(letter) != '':\n                        self.chars[ord(i)] = letter\n                        self.width[ord(i)] = width\n\n            # Load ASCII extended character set\n            while data:\n                line = data.pop(0).strip()\n                i = line.split(' ', 1)[0]\n                if (i == ''):\n                    continue\n                hex_match = re.search('^0x', i, re.IGNORECASE)\n                if hex_match is not None:\n                    i = int(i, 16)\n                    width, letter = __char(data)\n                    if ''.join(letter) != '':\n                        self.chars[i] = letter\n                        self.width[i] = width\n\n        except Exception as e:\n            raise FontError('problem parsing %s font: %s' % (self.font, e))\n\n    def __str__(self):\n        return '<FigletFont object: %s>' % self.font\n"
    },
    {
      "type": "class",
      "qualified_name": "pyfiglet.FigletProduct",
      "module": "pyfiglet",
      "signature": "(self)",
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "This class stores the internal build part of\nthe ascii output string",
      "source_code": "class FigletProduct(object):\n    \"\"\"\n    This class stores the internal build part of\n    the ascii output string\n    \"\"\"\n    def __init__(self):\n        self.queue = list()\n        self.buffer_string = \"\"\n\n    def append(self, buffer):\n        self.queue.append(buffer)\n\n    def getString(self):\n        return FigletString(self.buffer_string)\n"
    },
    {
      "type": "class",
      "qualified_name": "pyfiglet.FigletRenderingEngine",
      "module": "pyfiglet",
      "signature": "(self, base=None)",
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "This class handles the rendering of a FigletFont,\nincluding smushing/kerning/justification/direction",
      "source_code": "class FigletRenderingEngine(object):\n    \"\"\"\n    This class handles the rendering of a FigletFont,\n    including smushing/kerning/justification/direction\n    \"\"\"\n\n    def __init__(self, base=None):\n        self.base = base\n\n    def render(self, text):\n        \"\"\"\n        Render an ASCII text string in figlet\n        \"\"\"\n        builder = FigletBuilder(text,\n                                self.base.Font,\n                                self.base.direction,\n                                self.base.width,\n                                self.base.justify)\n\n        while builder.isNotFinished():\n            builder.addCharToProduct()\n            builder.goToNextChar()\n\n        return builder.returnProduct()\n"
    },
    {
      "type": "class",
      "qualified_name": "pyfiglet.FigletString",
      "module": "pyfiglet",
      "signature": "(self, /, *args, **kwargs)",
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Rendered figlet font",
      "source_code": "class FigletString(unicode_string):\n    \"\"\"\n    Rendered figlet font\n    \"\"\"\n\n    # translation map for reversing ascii art / -> \\, etc.\n    __reverse_map__ = (\n        '\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\t\\n\\x0b\\x0c\\r\\x0e\\x0f'\n        '\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f'\n        ' !\"#$%&\\')(*+,-.\\\\'\n        '0123456789:;>=<?'\n        '@ABCDEFGHIJKLMNO'\n        'PQRSTUVWXYZ]/[^_'\n        '`abcdefghijklmno'\n        'pqrstuvwxyz}|{~\\x7f'\n        '\\x80\\x81\\x82\\x83\\x84\\x85\\x86\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8d\\x8e\\x8f'\n        '\\x90\\x91\\x92\\x93\\x94\\x95\\x96\\x97\\x98\\x99\\x9a\\x9b\\x9c\\x9d\\x9e\\x9f'\n        '\\xa0\\xa1\\xa2\\xa3\\xa4\\xa5\\xa6\\xa7\\xa8\\xa9\\xaa\\xab\\xac\\xad\\xae\\xaf'\n        '\\xb0\\xb1\\xb2\\xb3\\xb4\\xb5\\xb6\\xb7\\xb8\\xb9\\xba\\xbb\\xbc\\xbd\\xbe\\xbf'\n        '\\xc0\\xc1\\xc2\\xc3\\xc4\\xc5\\xc6\\xc7\\xc8\\xc9\\xca\\xcb\\xcc\\xcd\\xce\\xcf'\n        '\\xd0\\xd1\\xd2\\xd3\\xd4\\xd5\\xd6\\xd7\\xd8\\xd9\\xda\\xdb\\xdc\\xdd\\xde\\xdf'\n        '\\xe0\\xe1\\xe2\\xe3\\xe4\\xe5\\xe6\\xe7\\xe8\\xe9\\xea\\xeb\\xec\\xed\\xee\\xef'\n        '\\xf0\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xfe\\xff')\n\n    # translation map for flipping ascii art ^ -> v, etc.\n    __flip_map__ = (\n        '\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\t\\n\\x0b\\x0c\\r\\x0e\\x0f'\n        '\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f'\n        ' !\"#$%&\\'()*+,-.\\\\'\n        '0123456789:;<=>?'\n        '@VBCDEFGHIJKLWNO'\n        'bQbSTUAMXYZ[/]v-'\n        '`aPcdefghijklwno'\n        'pqrstu^mxyz{|}~\\x7f'\n        '\\x80\\x81\\x82\\x83\\x84\\x85\\x86\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8d\\x8e\\x8f'\n        '\\x90\\x91\\x92\\x93\\x94\\x95\\x96\\x97\\x98\\x99\\x9a\\x9b\\x9c\\x9d\\x9e\\x9f'\n        '\\xa0\\xa1\\xa2\\xa3\\xa4\\xa5\\xa6\\xa7\\xa8\\xa9\\xaa\\xab\\xac\\xad\\xae\\xaf'\n        '\\xb0\\xb1\\xb2\\xb3\\xb4\\xb5\\xb6\\xb7\\xb8\\xb9\\xba\\xbb\\xbc\\xbd\\xbe\\xbf'\n        '\\xc0\\xc1\\xc2\\xc3\\xc4\\xc5\\xc6\\xc7\\xc8\\xc9\\xca\\xcb\\xcc\\xcd\\xce\\xcf'\n        '\\xd0\\xd1\\xd2\\xd3\\xd4\\xd5\\xd6\\xd7\\xd8\\xd9\\xda\\xdb\\xdc\\xdd\\xde\\xdf'\n        '\\xe0\\xe1\\xe2\\xe3\\xe4\\xe5\\xe6\\xe7\\xe8\\xe9\\xea\\xeb\\xec\\xed\\xee\\xef'\n        '\\xf0\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xfe\\xff')\n\n    def reverse(self):\n        out = []\n        for row in self.splitlines():\n            out.append(row.translate(self.__reverse_map__)[::-1])\n\n        return self.newFromList(out)\n\n    def flip(self):\n        out = []\n        for row in self.splitlines()[::-1]:\n            out.append(row.translate(self.__flip_map__))\n\n        return self.newFromList(out)\n\n    # doesn't do self.strip() because it could remove leading whitespace on first line of the font\n    # doesn't do row.strip() because it could remove empty lines within the font character\n    def strip_surrounding_newlines(self):\n        out = []\n        chars_seen = False\n        for row in self.splitlines():\n            # if the row isn't empty or if we're in the middle of the font character, add the line.\n            if row.strip() != \"\" or chars_seen:\n                chars_seen = True\n                out.append(row)\n\n        # rstrip to get rid of the trailing newlines\n        return self.newFromList(out).rstrip()\n\n    def normalize_surrounding_newlines(self):\n        return '\\n' + self.strip_surrounding_newlines() + '\\n'\n\n    def newFromList(self, list):\n        return FigletString('\\n'.join(list) + '\\n')\n"
    },
    {
      "type": "class",
      "qualified_name": "pyfiglet.FontError",
      "module": "pyfiglet",
      "signature": "(self, error)",
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Raised when there is a problem parsing a font file",
      "source_code": "class FontError(FigletError):\n    \"\"\"\n    Raised when there is a problem parsing a font file\n    \"\"\"\n"
    },
    {
      "type": "class",
      "qualified_name": "pyfiglet.FontNotFound",
      "module": "pyfiglet",
      "signature": "(self, error)",
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Raised when a font can't be located",
      "source_code": "class FontNotFound(FigletError):\n    \"\"\"\n    Raised when a font can't be located\n    \"\"\"\n"
    },
    {
      "type": "class",
      "qualified_name": "pyfiglet.InvalidColor",
      "module": "pyfiglet",
      "signature": "(self, error)",
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Raised when the color passed is invalid",
      "source_code": "class InvalidColor(FigletError):\n    \"\"\"\n    Raised when the color passed is invalid\n    \"\"\"\n"
    },
    {
      "type": "class",
      "qualified_name": "pyfiglet.OptionParser",
      "module": "pyfiglet",
      "signature": "(self, usage=None, option_list=None, option_class=<class 'optparse.Option'>, version=None, conflict_handler='error', description=None, formatter=None, add_help_option=True, prog=None, epilog=None)",
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Class attributes:\n  standard_option_list : [Option]\n    list of standard options that will be accepted by all instances\n    of this parser class (intended to be overridden by subclasses).\n\nInstance attributes:\n  usage : string\n    a usage string for your program.  Before it is displayed\n    to the user, \"%prog\" will be expanded to the name of\n    your program (self.prog or os.path.basename(sys.argv[0])).\n  prog : string\n    the name of the current program (to override\n    os.path.basename(sys.argv[0])).\n  description : string\n    A paragraph of text giving a brief overview of your program.\n    optparse reformats this paragraph to fit the current terminal\n    width and prints it when the user requests help (after usage,\n    but before the list of options).\n  epilog : string\n    paragraph of help text to print after option help\n\n  option_groups : [OptionGroup]\n    list of option groups in this parser (option groups are\n    irrelevant for parsing the command-line, but very useful\n    for generating help)\n\n  allow_interspersed_args : bool = true\n    if true, positional arguments may be interspersed with options.\n    Assuming -a and -b each take a single argument, the command-line\n      -ablah foo bar -bboo baz\n    will be interpreted the same as\n      -ablah -bboo -- foo bar baz\n    If this flag were false, that command line would be interpreted as\n      -ablah -- foo bar -bboo baz\n    -- ie. we stop processing options as soon as we see the first\n    non-option argument.  (This is the tradition followed by\n    Python's getopt module, Perl's Getopt::Std, and other argument-\n    parsing libraries, but it is generally annoying to users.)\n\n  process_default_values : bool = true\n    if true, option default values are processed similarly to option\n    values from the command line: that is, they are passed to the\n    type-checking function for the option's type (as long as the\n    default value is a string).  (This really only matters if you\n    have defined custom types; see SF bug #955889.)  Set it to false\n    to restore the behaviour of Optik 1.4.1 and earlier.\n\n  rargs : [string]\n    the argument list currently being parsed.  Only set when\n    parse_args() is active, and continually trimmed down as\n    we consume arguments.  Mainly there for the benefit of\n    callback options.\n  largs : [string]\n    the list of leftover arguments that we have skipped while\n    parsing options.  If allow_interspersed_args is false, this\n    list is always empty.\n  values : Values\n    the set of option values currently being accumulated.  Only\n    set when parse_args() is active.  Also mainly for callbacks.\n\nBecause of the 'rargs', 'largs', and 'values' attributes,\nOptionParser is not thread-safe.  If, for some perverse reason, you\nneed to parse command-line arguments simultaneously in different\nthreads, use different OptionParser instances.",
      "source_code": "class OptionParser (OptionContainer):\n\n    \"\"\"\n    Class attributes:\n      standard_option_list : [Option]\n        list of standard options that will be accepted by all instances\n        of this parser class (intended to be overridden by subclasses).\n\n    Instance attributes:\n      usage : string\n        a usage string for your program.  Before it is displayed\n        to the user, \"%prog\" will be expanded to the name of\n        your program (self.prog or os.path.basename(sys.argv[0])).\n      prog : string\n        the name of the current program (to override\n        os.path.basename(sys.argv[0])).\n      description : string\n        A paragraph of text giving a brief overview of your program.\n        optparse reformats this paragraph to fit the current terminal\n        width and prints it when the user requests help (after usage,\n        but before the list of options).\n      epilog : string\n        paragraph of help text to print after option help\n\n      option_groups : [OptionGroup]\n        list of option groups in this parser (option groups are\n        irrelevant for parsing the command-line, but very useful\n        for generating help)\n\n      allow_interspersed_args : bool = true\n        if true, positional arguments may be interspersed with options.\n        Assuming -a and -b each take a single argument, the command-line\n          -ablah foo bar -bboo baz\n        will be interpreted the same as\n          -ablah -bboo -- foo bar baz\n        If this flag were false, that command line would be interpreted as\n          -ablah -- foo bar -bboo baz\n        -- ie. we stop processing options as soon as we see the first\n        non-option argument.  (This is the tradition followed by\n        Python's getopt module, Perl's Getopt::Std, and other argument-\n        parsing libraries, but it is generally annoying to users.)\n\n      process_default_values : bool = true\n        if true, option default values are processed similarly to option\n        values from the command line: that is, they are passed to the\n        type-checking function for the option's type (as long as the\n        default value is a string).  (This really only matters if you\n        have defined custom types; see SF bug #955889.)  Set it to false\n        to restore the behaviour of Optik 1.4.1 and earlier.\n\n      rargs : [string]\n        the argument list currently being parsed.  Only set when\n        parse_args() is active, and continually trimmed down as\n        we consume arguments.  Mainly there for the benefit of\n        callback options.\n      largs : [string]\n        the list of leftover arguments that we have skipped while\n        parsing options.  If allow_interspersed_args is false, this\n        list is always empty.\n      values : Values\n        the set of option values currently being accumulated.  Only\n        set when parse_args() is active.  Also mainly for callbacks.\n\n    Because of the 'rargs', 'largs', and 'values' attributes,\n    OptionParser is not thread-safe.  If, for some perverse reason, you\n    need to parse command-line arguments simultaneously in different\n    threads, use different OptionParser instances.\n\n    \"\"\"\n\n    standard_option_list = []\n\n    def __init__(self,\n                 usage=None,\n                 option_list=None,\n                 option_class=Option,\n                 version=None,\n                 conflict_handler=\"error\",\n                 description=None,\n                 formatter=None,\n                 add_help_option=True,\n                 prog=None,\n                 epilog=None):\n        OptionContainer.__init__(\n            self, option_class, conflict_handler, description)\n        self.set_usage(usage)\n        self.prog = prog\n        self.version = version\n        self.allow_interspersed_args = True\n        self.process_default_values = True\n        if formatter is None:\n            formatter = IndentedHelpFormatter()\n        self.formatter = formatter\n        self.formatter.set_parser(self)\n        self.epilog = epilog\n\n        # Populate the option list; initial sources are the\n        # standard_option_list class attribute, the 'option_list'\n        # argument, and (if applicable) the _add_version_option() and\n        # _add_help_option() methods.\n        self._populate_option_list(option_list,\n                                   add_help=add_help_option)\n\n        self._init_parsing_state()\n\n\n    def destroy(self):\n        \"\"\"\n        Declare that you are done with this OptionParser.  This cleans up\n        reference cycles so the OptionParser (and all objects referenced by\n        it) can be garbage-collected promptly.  After calling destroy(), the\n        OptionParser is unusable.\n        \"\"\"\n        OptionContainer.destroy(self)\n        for group in self.option_groups:\n            group.destroy()\n        del self.option_list\n        del self.option_groups\n        del self.formatter\n\n\n    # -- Private methods -----------------------------------------------\n    # (used by our or OptionContainer's constructor)\n\n    def _create_option_list(self):\n        self.option_list = []\n        self.option_groups = []\n        self._create_option_mappings()\n\n    def _add_help_option(self):\n        self.add_option(\"-h\", \"--help\",\n                        action=\"help\",\n                        help=_(\"show this help message and exit\"))\n\n    def _add_version_option(self):\n        self.add_option(\"--version\",\n                        action=\"version\",\n                        help=_(\"show program's version number and exit\"))\n\n    def _populate_option_list(self, option_list, add_help=True):\n        if self.standard_option_list:\n            self.add_options(self.standard_option_list)\n        if option_list:\n            self.add_options(option_list)\n        if self.version:\n            self._add_version_option()\n        if add_help:\n            self._add_help_option()\n\n    def _init_parsing_state(self):\n        # These are set in parse_args() for the convenience of callbacks.\n        self.rargs = None\n        self.largs = None\n        self.values = None\n\n\n    # -- Simple modifier methods ---------------------------------------\n\n    def set_usage(self, usage):\n        if usage is None:\n            self.usage = _(\"%prog [options]\")\n        elif usage is SUPPRESS_USAGE:\n            self.usage = None\n        # For backwards compatibility with Optik 1.3 and earlier.\n        elif usage.lower().startswith(\"usage: \"):\n            self.usage = usage[7:]\n        else:\n            self.usage = usage\n\n    def enable_interspersed_args(self):\n        \"\"\"Set parsing to not stop on the first non-option, allowing\n        interspersing switches with command arguments. This is the\n        default behavior. See also disable_interspersed_args() and the\n        class documentation description of the attribute\n        allow_interspersed_args.\"\"\"\n        self.allow_interspersed_args = True\n\n    def disable_interspersed_args(self):\n        \"\"\"Set parsing to stop on the first non-option. Use this if\n        you have a command processor which runs another command that\n        has options of its own and you want to make sure these options\n        don't get confused.\n        \"\"\"\n        self.allow_interspersed_args = False\n\n    def set_process_default_values(self, process):\n        self.process_default_values = process\n\n    def set_default(self, dest, value):\n        self.defaults[dest] = value\n\n    def set_defaults(self, **kwargs):\n        self.defaults.update(kwargs)\n\n    def _get_all_options(self):\n        options = self.option_list[:]\n        for group in self.option_groups:\n            options.extend(group.option_list)\n        return options\n\n    def get_default_values(self):\n        if not self.process_default_values:\n            # Old, pre-Optik 1.5 behaviour.\n            return Values(self.defaults)\n\n        defaults = self.defaults.copy()\n        for option in self._get_all_options():\n            default = defaults.get(option.dest)\n            if isinstance(default, str):\n                opt_str = option.get_opt_string()\n                defaults[option.dest] = option.check_value(opt_str, default)\n\n        return Values(defaults)\n\n\n    # -- OptionGroup methods -------------------------------------------\n\n    def add_option_group(self, *args, **kwargs):\n        # XXX lots of overlap with OptionContainer.add_option()\n        if isinstance(args[0], str):\n            group = OptionGroup(self, *args, **kwargs)\n        elif len(args) == 1 and not kwargs:\n            group = args[0]\n            if not isinstance(group, OptionGroup):\n                raise TypeError(\"not an OptionGroup instance: %r\" % group)\n            if group.parser is not self:\n                raise ValueError(\"invalid OptionGroup (wrong parser)\")\n        else:\n            raise TypeError(\"invalid arguments\")\n\n        self.option_groups.append(group)\n        return group\n\n    def get_option_group(self, opt_str):\n        option = (self._short_opt.get(opt_str) or\n                  self._long_opt.get(opt_str))\n        if option and option.container is not self:\n            return option.container\n        return None\n\n\n    # -- Option-parsing methods ----------------------------------------\n\n    def _get_args(self, args):\n        if args is None:\n            return sys.argv[1:]\n        else:\n            return args[:]              # don't modify caller's list\n\n    def parse_args(self, args=None, values=None):\n        \"\"\"\n        parse_args(args : [string] = sys.argv[1:],\n                   values : Values = None)\n        -> (values : Values, args : [string])\n\n        Parse the command-line options found in 'args' (default:\n        sys.argv[1:]).  Any errors result in a call to 'error()', which\n        by default prints the usage message to stderr and calls\n        sys.exit() with an error message.  On success returns a pair\n        (values, args) where 'values' is a Values instance (with all\n        your option values) and 'args' is the list of arguments left\n        over after parsing options.\n        \"\"\"\n        rargs = self._get_args(args)\n        if values is None:\n            values = self.get_default_values()\n\n        # Store the halves of the argument list as attributes for the\n        # convenience of callbacks:\n        #   rargs\n        #     the rest of the command-line (the \"r\" stands for\n        #     \"remaining\" or \"right-hand\")\n        #   largs\n        #     the leftover arguments -- ie. what's left after removing\n        #     options and their arguments (the \"l\" stands for \"leftover\"\n        #     or \"left-hand\")\n        self.rargs = rargs\n        self.largs = largs = []\n        self.values = values\n\n        try:\n            stop = self._process_args(largs, rargs, values)\n        except (BadOptionError, OptionValueError) as err:\n            self.error(str(err))\n\n        args = largs + rargs\n        return self.check_values(values, args)\n\n    def check_values(self, values, args):\n        \"\"\"\n        check_values(values : Values, args : [string])\n        -> (values : Values, args : [string])\n\n        Check that the supplied option values and leftover arguments are\n        valid.  Returns the option values and leftover arguments\n        (possibly adjusted, possibly completely new -- whatever you\n        like).  Default implementation just returns the passed-in\n        values; subclasses may override as desired.\n        \"\"\"\n        return (values, args)\n\n    def _process_args(self, largs, rargs, values):\n        \"\"\"_process_args(largs : [string],\n                         rargs : [string],\n                         values : Values)\n\n        Process command-line arguments and populate 'values', consuming\n        options and arguments from 'rargs'.  If 'allow_interspersed_args' is\n        false, stop at the first non-option argument.  If true, accumulate any\n        interspersed non-option arguments in 'largs'.\n        \"\"\"\n        while rargs:\n            arg = rargs[0]\n            # We handle bare \"--\" explicitly, and bare \"-\" is handled by the\n            # standard arg handler since the short arg case ensures that the\n            # len of the opt string is greater than 1.\n            if arg == \"--\":\n                del rargs[0]\n                return\n            elif arg[0:2] == \"--\":\n                # process a single long option (possibly with value(s))\n                self._process_long_opt(rargs, values)\n            elif arg[:1] == \"-\" and len(arg) > 1:\n                # process a cluster of short options (possibly with\n                # value(s) for the last one only)\n                self._process_short_opts(rargs, values)\n            elif self.allow_interspersed_args:\n                largs.append(arg)\n                del rargs[0]\n            else:\n                return                  # stop now, leave this arg in rargs\n\n        # Say this is the original argument list:\n        # [arg0, arg1, ..., arg(i-1), arg(i), arg(i+1), ..., arg(N-1)]\n        #                            ^\n        # (we are about to process arg(i)).\n        #\n        # Then rargs is [arg(i), ..., arg(N-1)] and largs is a *subset* of\n        # [arg0, ..., arg(i-1)] (any options and their arguments will have\n        # been removed from largs).\n        #\n        # The while loop will usually consume 1 or more arguments per pass.\n        # If it consumes 1 (eg. arg is an option that takes no arguments),\n        # then after _process_arg() is done the situation is:\n        #\n        #   largs = subset of [arg0, ..., arg(i)]\n        #   rargs = [arg(i+1), ..., arg(N-1)]\n        #\n        # If allow_interspersed_args is false, largs will always be\n        # *empty* -- still a subset of [arg0, ..., arg(i-1)], but\n        # not a very interesting subset!\n\n    def _match_long_opt(self, opt):\n        \"\"\"_match_long_opt(opt : string) -> string\n\n        Determine which long option string 'opt' matches, ie. which one\n        it is an unambiguous abbreviation for.  Raises BadOptionError if\n        'opt' doesn't unambiguously match any long option string.\n        \"\"\"\n        return _match_abbrev(opt, self._long_opt)\n\n    def _process_long_opt(self, rargs, values):\n        arg = rargs.pop(0)\n\n        # Value explicitly attached to arg?  Pretend it's the next\n        # argument.\n        if \"=\" in arg:\n            (opt, next_arg) = arg.split(\"=\", 1)\n            rargs.insert(0, next_arg)\n            had_explicit_value = True\n        else:\n            opt = arg\n            had_explicit_value = False\n\n        opt = self._match_long_opt(opt)\n        option = self._long_opt[opt]\n        if option.takes_value():\n            nargs = option.nargs\n            if len(rargs) < nargs:\n                self.error(ngettext(\n                    \"%(option)s option requires %(number)d argument\",\n                    \"%(option)s option requires %(number)d arguments\",\n                    nargs) % {\"option\": opt, \"number\": nargs})\n            elif nargs == 1:\n                value = rargs.pop(0)\n            else:\n                value = tuple(rargs[0:nargs])\n                del rargs[0:nargs]\n\n        elif had_explicit_value:\n            self.error(_(\"%s option does not take a value\") % opt)\n\n        else:\n            value = None\n\n        option.process(opt, value, values, self)\n\n    def _process_short_opts(self, rargs, values):\n        arg = rargs.pop(0)\n        stop = False\n        i = 1\n        for ch in arg[1:]:\n            opt = \"-\" + ch\n            option = self._short_opt.get(opt)\n            i += 1                      # we have consumed a character\n\n            if not option:\n                raise BadOptionError(opt)\n            if option.takes_value():\n                # Any characters left in arg?  Pretend they're the\n                # next arg, and stop consuming characters of arg.\n                if i < len(arg):\n                    rargs.insert(0, arg[i:])\n                    stop = True\n\n                nargs = option.nargs\n                if len(rargs) < nargs:\n                    self.error(ngettext(\n                        \"%(option)s option requires %(number)d argument\",\n                        \"%(option)s option requires %(number)d arguments\",\n                        nargs) % {\"option\": opt, \"number\": nargs})\n                elif nargs == 1:\n                    value = rargs.pop(0)\n                else:\n                    value = tuple(rargs[0:nargs])\n                    del rargs[0:nargs]\n\n            else:                       # option doesn't take a value\n                value = None\n\n            option.process(opt, value, values, self)\n\n            if stop:\n                break\n\n\n    # -- Feedback methods ----------------------------------------------\n\n    def get_prog_name(self):\n        if self.prog is None:\n            return os.path.basename(sys.argv[0])\n        else:\n            return self.prog\n\n    def expand_prog_name(self, s):\n        return s.replace(\"%prog\", self.get_prog_name())\n\n    def get_description(self):\n        return self.expand_prog_name(self.description)\n\n    def exit(self, status=0, msg=None):\n        if msg:\n            sys.stderr.write(msg)\n        sys.exit(status)\n\n    def error(self, msg):\n        \"\"\"error(msg : string)\n\n        Print a usage message incorporating 'msg' to stderr and exit.\n        If you override this in a subclass, it should not return -- it\n        should either exit or raise an exception.\n        \"\"\"\n        self.print_usage(sys.stderr)\n        self.exit(2, \"%s: error: %s\\n\" % (self.get_prog_name(), msg))\n\n    def get_usage(self):\n        if self.usage:\n            return self.formatter.format_usage(\n                self.expand_prog_name(self.usage))\n        else:\n            return \"\"\n\n    def print_usage(self, file=None):\n        \"\"\"print_usage(file : file = stdout)\n\n        Print the usage message for the current program (self.usage) to\n        'file' (default stdout).  Any occurrence of the string \"%prog\" in\n        self.usage is replaced with the name of the current program\n        (basename of sys.argv[0]).  Does nothing if self.usage is empty\n        or not defined.\n        \"\"\"\n        if self.usage:\n            print(self.get_usage(), file=file)\n\n    def get_version(self):\n        if self.version:\n            return self.expand_prog_name(self.version)\n        else:\n            return \"\"\n\n    def print_version(self, file=None):\n        \"\"\"print_version(file : file = stdout)\n\n        Print the version message for this program (self.version) to\n        'file' (default stdout).  As with print_usage(), any occurrence\n        of \"%prog\" in self.version is replaced by the current program's\n        name.  Does nothing if self.version is empty or undefined.\n        \"\"\"\n        if self.version:\n            print(self.get_version(), file=file)\n\n    def format_option_help(self, formatter=None):\n        if formatter is None:\n            formatter = self.formatter\n        formatter.store_option_strings(self)\n        result = []\n        result.append(formatter.format_heading(_(\"Options\")))\n        formatter.indent()\n        if self.option_list:\n            result.append(OptionContainer.format_option_help(self, formatter))\n            result.append(\"\\n\")\n        for group in self.option_groups:\n            result.append(group.format_help(formatter))\n            result.append(\"\\n\")\n        formatter.dedent()\n        # Drop the last \"\\n\", or the header if no options or option groups:\n        return \"\".join(result[:-1])\n\n    def format_epilog(self, formatter):\n        return formatter.format_epilog(self.epilog)\n\n    def format_help(self, formatter=None):\n        if formatter is None:\n            formatter = self.formatter\n        result = []\n        if self.usage:\n            result.append(self.get_usage() + \"\\n\")\n        if self.description:\n            result.append(self.format_description(formatter) + \"\\n\")\n        result.append(self.format_option_help(formatter))\n        result.append(self.format_epilog(formatter))\n        return \"\".join(result)\n\n    def print_help(self, file=None):\n        \"\"\"print_help(file : file = stdout)\n\n        Print an extended help message, listing all options and any\n        help text provided with them, to 'file' (default stdout).\n        \"\"\"\n        if file is None:\n            file = sys.stdout\n        file.write(self.format_help())\n"
    },
    {
      "type": "class",
      "qualified_name": "pyfiglet.unicode_string",
      "module": "pyfiglet",
      "signature": "(self, /, *args, **kwargs)",
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "str(object='') -> str\nstr(bytes_or_buffer[, encoding[, errors]]) -> str\n\nCreate a new string object from the given object. If encoding or\nerrors is specified, then the object must expose a data buffer\nthat will be decoded using the given encoding and error handler.\nOtherwise, returns the result of object.__str__() (if defined)\nor repr(object).\nencoding defaults to sys.getdefaultencoding().\nerrors defaults to 'strict'.",
      "source_code": null
    },
    {
      "type": "class",
      "qualified_name": "pyfiglet.test.Figlet",
      "module": "pyfiglet.test",
      "signature": "(self, font='standard', direction='auto', justify='auto', width=80)",
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Main figlet class.",
      "source_code": "class Figlet(object):\n    \"\"\"\n    Main figlet class.\n    \"\"\"\n\n    def __init__(self, font=DEFAULT_FONT, direction='auto', justify='auto',\n                 width=80):\n        self.font = font\n        self._direction = direction\n        self._justify = justify\n        self.width = width\n        self.setFont()\n        self.engine = FigletRenderingEngine(base=self)\n\n    def setFont(self, **kwargs):\n        if 'font' in kwargs:\n            self.font = kwargs['font']\n\n        self.Font = FigletFont(font=self.font)\n\n    def getDirection(self):\n        if self._direction == 'auto':\n            direction = self.Font.printDirection\n            if direction == 0:\n                return 'left-to-right'\n            elif direction == 1:\n                return 'right-to-left'\n            else:\n                return 'left-to-right'\n\n        else:\n            return self._direction\n\n    direction = property(getDirection)\n\n    def getJustify(self):\n        if self._justify == 'auto':\n            if self.direction == 'left-to-right':\n                return 'left'\n            elif self.direction == 'right-to-left':\n                return 'right'\n\n        else:\n            return self._justify\n\n    justify = property(getJustify)\n\n    def renderText(self, text):\n        # wrapper method to engine\n        return self.engine.render(text)\n\n    def getFonts(self):\n        return self.Font.getFonts()\n"
    },
    {
      "type": "class",
      "qualified_name": "pyfiglet.test.OptionParser",
      "module": "pyfiglet.test",
      "signature": "(self, usage=None, option_list=None, option_class=<class 'optparse.Option'>, version=None, conflict_handler='error', description=None, formatter=None, add_help_option=True, prog=None, epilog=None)",
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Class attributes:\n  standard_option_list : [Option]\n    list of standard options that will be accepted by all instances\n    of this parser class (intended to be overridden by subclasses).\n\nInstance attributes:\n  usage : string\n    a usage string for your program.  Before it is displayed\n    to the user, \"%prog\" will be expanded to the name of\n    your program (self.prog or os.path.basename(sys.argv[0])).\n  prog : string\n    the name of the current program (to override\n    os.path.basename(sys.argv[0])).\n  description : string\n    A paragraph of text giving a brief overview of your program.\n    optparse reformats this paragraph to fit the current terminal\n    width and prints it when the user requests help (after usage,\n    but before the list of options).\n  epilog : string\n    paragraph of help text to print after option help\n\n  option_groups : [OptionGroup]\n    list of option groups in this parser (option groups are\n    irrelevant for parsing the command-line, but very useful\n    for generating help)\n\n  allow_interspersed_args : bool = true\n    if true, positional arguments may be interspersed with options.\n    Assuming -a and -b each take a single argument, the command-line\n      -ablah foo bar -bboo baz\n    will be interpreted the same as\n      -ablah -bboo -- foo bar baz\n    If this flag were false, that command line would be interpreted as\n      -ablah -- foo bar -bboo baz\n    -- ie. we stop processing options as soon as we see the first\n    non-option argument.  (This is the tradition followed by\n    Python's getopt module, Perl's Getopt::Std, and other argument-\n    parsing libraries, but it is generally annoying to users.)\n\n  process_default_values : bool = true\n    if true, option default values are processed similarly to option\n    values from the command line: that is, they are passed to the\n    type-checking function for the option's type (as long as the\n    default value is a string).  (This really only matters if you\n    have defined custom types; see SF bug #955889.)  Set it to false\n    to restore the behaviour of Optik 1.4.1 and earlier.\n\n  rargs : [string]\n    the argument list currently being parsed.  Only set when\n    parse_args() is active, and continually trimmed down as\n    we consume arguments.  Mainly there for the benefit of\n    callback options.\n  largs : [string]\n    the list of leftover arguments that we have skipped while\n    parsing options.  If allow_interspersed_args is false, this\n    list is always empty.\n  values : Values\n    the set of option values currently being accumulated.  Only\n    set when parse_args() is active.  Also mainly for callbacks.\n\nBecause of the 'rargs', 'largs', and 'values' attributes,\nOptionParser is not thread-safe.  If, for some perverse reason, you\nneed to parse command-line arguments simultaneously in different\nthreads, use different OptionParser instances.",
      "source_code": "class OptionParser (OptionContainer):\n\n    \"\"\"\n    Class attributes:\n      standard_option_list : [Option]\n        list of standard options that will be accepted by all instances\n        of this parser class (intended to be overridden by subclasses).\n\n    Instance attributes:\n      usage : string\n        a usage string for your program.  Before it is displayed\n        to the user, \"%prog\" will be expanded to the name of\n        your program (self.prog or os.path.basename(sys.argv[0])).\n      prog : string\n        the name of the current program (to override\n        os.path.basename(sys.argv[0])).\n      description : string\n        A paragraph of text giving a brief overview of your program.\n        optparse reformats this paragraph to fit the current terminal\n        width and prints it when the user requests help (after usage,\n        but before the list of options).\n      epilog : string\n        paragraph of help text to print after option help\n\n      option_groups : [OptionGroup]\n        list of option groups in this parser (option groups are\n        irrelevant for parsing the command-line, but very useful\n        for generating help)\n\n      allow_interspersed_args : bool = true\n        if true, positional arguments may be interspersed with options.\n        Assuming -a and -b each take a single argument, the command-line\n          -ablah foo bar -bboo baz\n        will be interpreted the same as\n          -ablah -bboo -- foo bar baz\n        If this flag were false, that command line would be interpreted as\n          -ablah -- foo bar -bboo baz\n        -- ie. we stop processing options as soon as we see the first\n        non-option argument.  (This is the tradition followed by\n        Python's getopt module, Perl's Getopt::Std, and other argument-\n        parsing libraries, but it is generally annoying to users.)\n\n      process_default_values : bool = true\n        if true, option default values are processed similarly to option\n        values from the command line: that is, they are passed to the\n        type-checking function for the option's type (as long as the\n        default value is a string).  (This really only matters if you\n        have defined custom types; see SF bug #955889.)  Set it to false\n        to restore the behaviour of Optik 1.4.1 and earlier.\n\n      rargs : [string]\n        the argument list currently being parsed.  Only set when\n        parse_args() is active, and continually trimmed down as\n        we consume arguments.  Mainly there for the benefit of\n        callback options.\n      largs : [string]\n        the list of leftover arguments that we have skipped while\n        parsing options.  If allow_interspersed_args is false, this\n        list is always empty.\n      values : Values\n        the set of option values currently being accumulated.  Only\n        set when parse_args() is active.  Also mainly for callbacks.\n\n    Because of the 'rargs', 'largs', and 'values' attributes,\n    OptionParser is not thread-safe.  If, for some perverse reason, you\n    need to parse command-line arguments simultaneously in different\n    threads, use different OptionParser instances.\n\n    \"\"\"\n\n    standard_option_list = []\n\n    def __init__(self,\n                 usage=None,\n                 option_list=None,\n                 option_class=Option,\n                 version=None,\n                 conflict_handler=\"error\",\n                 description=None,\n                 formatter=None,\n                 add_help_option=True,\n                 prog=None,\n                 epilog=None):\n        OptionContainer.__init__(\n            self, option_class, conflict_handler, description)\n        self.set_usage(usage)\n        self.prog = prog\n        self.version = version\n        self.allow_interspersed_args = True\n        self.process_default_values = True\n        if formatter is None:\n            formatter = IndentedHelpFormatter()\n        self.formatter = formatter\n        self.formatter.set_parser(self)\n        self.epilog = epilog\n\n        # Populate the option list; initial sources are the\n        # standard_option_list class attribute, the 'option_list'\n        # argument, and (if applicable) the _add_version_option() and\n        # _add_help_option() methods.\n        self._populate_option_list(option_list,\n                                   add_help=add_help_option)\n\n        self._init_parsing_state()\n\n\n    def destroy(self):\n        \"\"\"\n        Declare that you are done with this OptionParser.  This cleans up\n        reference cycles so the OptionParser (and all objects referenced by\n        it) can be garbage-collected promptly.  After calling destroy(), the\n        OptionParser is unusable.\n        \"\"\"\n        OptionContainer.destroy(self)\n        for group in self.option_groups:\n            group.destroy()\n        del self.option_list\n        del self.option_groups\n        del self.formatter\n\n\n    # -- Private methods -----------------------------------------------\n    # (used by our or OptionContainer's constructor)\n\n    def _create_option_list(self):\n        self.option_list = []\n        self.option_groups = []\n        self._create_option_mappings()\n\n    def _add_help_option(self):\n        self.add_option(\"-h\", \"--help\",\n                        action=\"help\",\n                        help=_(\"show this help message and exit\"))\n\n    def _add_version_option(self):\n        self.add_option(\"--version\",\n                        action=\"version\",\n                        help=_(\"show program's version number and exit\"))\n\n    def _populate_option_list(self, option_list, add_help=True):\n        if self.standard_option_list:\n            self.add_options(self.standard_option_list)\n        if option_list:\n            self.add_options(option_list)\n        if self.version:\n            self._add_version_option()\n        if add_help:\n            self._add_help_option()\n\n    def _init_parsing_state(self):\n        # These are set in parse_args() for the convenience of callbacks.\n        self.rargs = None\n        self.largs = None\n        self.values = None\n\n\n    # -- Simple modifier methods ---------------------------------------\n\n    def set_usage(self, usage):\n        if usage is None:\n            self.usage = _(\"%prog [options]\")\n        elif usage is SUPPRESS_USAGE:\n            self.usage = None\n        # For backwards compatibility with Optik 1.3 and earlier.\n        elif usage.lower().startswith(\"usage: \"):\n            self.usage = usage[7:]\n        else:\n            self.usage = usage\n\n    def enable_interspersed_args(self):\n        \"\"\"Set parsing to not stop on the first non-option, allowing\n        interspersing switches with command arguments. This is the\n        default behavior. See also disable_interspersed_args() and the\n        class documentation description of the attribute\n        allow_interspersed_args.\"\"\"\n        self.allow_interspersed_args = True\n\n    def disable_interspersed_args(self):\n        \"\"\"Set parsing to stop on the first non-option. Use this if\n        you have a command processor which runs another command that\n        has options of its own and you want to make sure these options\n        don't get confused.\n        \"\"\"\n        self.allow_interspersed_args = False\n\n    def set_process_default_values(self, process):\n        self.process_default_values = process\n\n    def set_default(self, dest, value):\n        self.defaults[dest] = value\n\n    def set_defaults(self, **kwargs):\n        self.defaults.update(kwargs)\n\n    def _get_all_options(self):\n        options = self.option_list[:]\n        for group in self.option_groups:\n            options.extend(group.option_list)\n        return options\n\n    def get_default_values(self):\n        if not self.process_default_values:\n            # Old, pre-Optik 1.5 behaviour.\n            return Values(self.defaults)\n\n        defaults = self.defaults.copy()\n        for option in self._get_all_options():\n            default = defaults.get(option.dest)\n            if isinstance(default, str):\n                opt_str = option.get_opt_string()\n                defaults[option.dest] = option.check_value(opt_str, default)\n\n        return Values(defaults)\n\n\n    # -- OptionGroup methods -------------------------------------------\n\n    def add_option_group(self, *args, **kwargs):\n        # XXX lots of overlap with OptionContainer.add_option()\n        if isinstance(args[0], str):\n            group = OptionGroup(self, *args, **kwargs)\n        elif len(args) == 1 and not kwargs:\n            group = args[0]\n            if not isinstance(group, OptionGroup):\n                raise TypeError(\"not an OptionGroup instance: %r\" % group)\n            if group.parser is not self:\n                raise ValueError(\"invalid OptionGroup (wrong parser)\")\n        else:\n            raise TypeError(\"invalid arguments\")\n\n        self.option_groups.append(group)\n        return group\n\n    def get_option_group(self, opt_str):\n        option = (self._short_opt.get(opt_str) or\n                  self._long_opt.get(opt_str))\n        if option and option.container is not self:\n            return option.container\n        return None\n\n\n    # -- Option-parsing methods ----------------------------------------\n\n    def _get_args(self, args):\n        if args is None:\n            return sys.argv[1:]\n        else:\n            return args[:]              # don't modify caller's list\n\n    def parse_args(self, args=None, values=None):\n        \"\"\"\n        parse_args(args : [string] = sys.argv[1:],\n                   values : Values = None)\n        -> (values : Values, args : [string])\n\n        Parse the command-line options found in 'args' (default:\n        sys.argv[1:]).  Any errors result in a call to 'error()', which\n        by default prints the usage message to stderr and calls\n        sys.exit() with an error message.  On success returns a pair\n        (values, args) where 'values' is a Values instance (with all\n        your option values) and 'args' is the list of arguments left\n        over after parsing options.\n        \"\"\"\n        rargs = self._get_args(args)\n        if values is None:\n            values = self.get_default_values()\n\n        # Store the halves of the argument list as attributes for the\n        # convenience of callbacks:\n        #   rargs\n        #     the rest of the command-line (the \"r\" stands for\n        #     \"remaining\" or \"right-hand\")\n        #   largs\n        #     the leftover arguments -- ie. what's left after removing\n        #     options and their arguments (the \"l\" stands for \"leftover\"\n        #     or \"left-hand\")\n        self.rargs = rargs\n        self.largs = largs = []\n        self.values = values\n\n        try:\n            stop = self._process_args(largs, rargs, values)\n        except (BadOptionError, OptionValueError) as err:\n            self.error(str(err))\n\n        args = largs + rargs\n        return self.check_values(values, args)\n\n    def check_values(self, values, args):\n        \"\"\"\n        check_values(values : Values, args : [string])\n        -> (values : Values, args : [string])\n\n        Check that the supplied option values and leftover arguments are\n        valid.  Returns the option values and leftover arguments\n        (possibly adjusted, possibly completely new -- whatever you\n        like).  Default implementation just returns the passed-in\n        values; subclasses may override as desired.\n        \"\"\"\n        return (values, args)\n\n    def _process_args(self, largs, rargs, values):\n        \"\"\"_process_args(largs : [string],\n                         rargs : [string],\n                         values : Values)\n\n        Process command-line arguments and populate 'values', consuming\n        options and arguments from 'rargs'.  If 'allow_interspersed_args' is\n        false, stop at the first non-option argument.  If true, accumulate any\n        interspersed non-option arguments in 'largs'.\n        \"\"\"\n        while rargs:\n            arg = rargs[0]\n            # We handle bare \"--\" explicitly, and bare \"-\" is handled by the\n            # standard arg handler since the short arg case ensures that the\n            # len of the opt string is greater than 1.\n            if arg == \"--\":\n                del rargs[0]\n                return\n            elif arg[0:2] == \"--\":\n                # process a single long option (possibly with value(s))\n                self._process_long_opt(rargs, values)\n            elif arg[:1] == \"-\" and len(arg) > 1:\n                # process a cluster of short options (possibly with\n                # value(s) for the last one only)\n                self._process_short_opts(rargs, values)\n            elif self.allow_interspersed_args:\n                largs.append(arg)\n                del rargs[0]\n            else:\n                return                  # stop now, leave this arg in rargs\n\n        # Say this is the original argument list:\n        # [arg0, arg1, ..., arg(i-1), arg(i), arg(i+1), ..., arg(N-1)]\n        #                            ^\n        # (we are about to process arg(i)).\n        #\n        # Then rargs is [arg(i), ..., arg(N-1)] and largs is a *subset* of\n        # [arg0, ..., arg(i-1)] (any options and their arguments will have\n        # been removed from largs).\n        #\n        # The while loop will usually consume 1 or more arguments per pass.\n        # If it consumes 1 (eg. arg is an option that takes no arguments),\n        # then after _process_arg() is done the situation is:\n        #\n        #   largs = subset of [arg0, ..., arg(i)]\n        #   rargs = [arg(i+1), ..., arg(N-1)]\n        #\n        # If allow_interspersed_args is false, largs will always be\n        # *empty* -- still a subset of [arg0, ..., arg(i-1)], but\n        # not a very interesting subset!\n\n    def _match_long_opt(self, opt):\n        \"\"\"_match_long_opt(opt : string) -> string\n\n        Determine which long option string 'opt' matches, ie. which one\n        it is an unambiguous abbreviation for.  Raises BadOptionError if\n        'opt' doesn't unambiguously match any long option string.\n        \"\"\"\n        return _match_abbrev(opt, self._long_opt)\n\n    def _process_long_opt(self, rargs, values):\n        arg = rargs.pop(0)\n\n        # Value explicitly attached to arg?  Pretend it's the next\n        # argument.\n        if \"=\" in arg:\n            (opt, next_arg) = arg.split(\"=\", 1)\n            rargs.insert(0, next_arg)\n            had_explicit_value = True\n        else:\n            opt = arg\n            had_explicit_value = False\n\n        opt = self._match_long_opt(opt)\n        option = self._long_opt[opt]\n        if option.takes_value():\n            nargs = option.nargs\n            if len(rargs) < nargs:\n                self.error(ngettext(\n                    \"%(option)s option requires %(number)d argument\",\n                    \"%(option)s option requires %(number)d arguments\",\n                    nargs) % {\"option\": opt, \"number\": nargs})\n            elif nargs == 1:\n                value = rargs.pop(0)\n            else:\n                value = tuple(rargs[0:nargs])\n                del rargs[0:nargs]\n\n        elif had_explicit_value:\n            self.error(_(\"%s option does not take a value\") % opt)\n\n        else:\n            value = None\n\n        option.process(opt, value, values, self)\n\n    def _process_short_opts(self, rargs, values):\n        arg = rargs.pop(0)\n        stop = False\n        i = 1\n        for ch in arg[1:]:\n            opt = \"-\" + ch\n            option = self._short_opt.get(opt)\n            i += 1                      # we have consumed a character\n\n            if not option:\n                raise BadOptionError(opt)\n            if option.takes_value():\n                # Any characters left in arg?  Pretend they're the\n                # next arg, and stop consuming characters of arg.\n                if i < len(arg):\n                    rargs.insert(0, arg[i:])\n                    stop = True\n\n                nargs = option.nargs\n                if len(rargs) < nargs:\n                    self.error(ngettext(\n                        \"%(option)s option requires %(number)d argument\",\n                        \"%(option)s option requires %(number)d arguments\",\n                        nargs) % {\"option\": opt, \"number\": nargs})\n                elif nargs == 1:\n                    value = rargs.pop(0)\n                else:\n                    value = tuple(rargs[0:nargs])\n                    del rargs[0:nargs]\n\n            else:                       # option doesn't take a value\n                value = None\n\n            option.process(opt, value, values, self)\n\n            if stop:\n                break\n\n\n    # -- Feedback methods ----------------------------------------------\n\n    def get_prog_name(self):\n        if self.prog is None:\n            return os.path.basename(sys.argv[0])\n        else:\n            return self.prog\n\n    def expand_prog_name(self, s):\n        return s.replace(\"%prog\", self.get_prog_name())\n\n    def get_description(self):\n        return self.expand_prog_name(self.description)\n\n    def exit(self, status=0, msg=None):\n        if msg:\n            sys.stderr.write(msg)\n        sys.exit(status)\n\n    def error(self, msg):\n        \"\"\"error(msg : string)\n\n        Print a usage message incorporating 'msg' to stderr and exit.\n        If you override this in a subclass, it should not return -- it\n        should either exit or raise an exception.\n        \"\"\"\n        self.print_usage(sys.stderr)\n        self.exit(2, \"%s: error: %s\\n\" % (self.get_prog_name(), msg))\n\n    def get_usage(self):\n        if self.usage:\n            return self.formatter.format_usage(\n                self.expand_prog_name(self.usage))\n        else:\n            return \"\"\n\n    def print_usage(self, file=None):\n        \"\"\"print_usage(file : file = stdout)\n\n        Print the usage message for the current program (self.usage) to\n        'file' (default stdout).  Any occurrence of the string \"%prog\" in\n        self.usage is replaced with the name of the current program\n        (basename of sys.argv[0]).  Does nothing if self.usage is empty\n        or not defined.\n        \"\"\"\n        if self.usage:\n            print(self.get_usage(), file=file)\n\n    def get_version(self):\n        if self.version:\n            return self.expand_prog_name(self.version)\n        else:\n            return \"\"\n\n    def print_version(self, file=None):\n        \"\"\"print_version(file : file = stdout)\n\n        Print the version message for this program (self.version) to\n        'file' (default stdout).  As with print_usage(), any occurrence\n        of \"%prog\" in self.version is replaced by the current program's\n        name.  Does nothing if self.version is empty or undefined.\n        \"\"\"\n        if self.version:\n            print(self.get_version(), file=file)\n\n    def format_option_help(self, formatter=None):\n        if formatter is None:\n            formatter = self.formatter\n        formatter.store_option_strings(self)\n        result = []\n        result.append(formatter.format_heading(_(\"Options\")))\n        formatter.indent()\n        if self.option_list:\n            result.append(OptionContainer.format_option_help(self, formatter))\n            result.append(\"\\n\")\n        for group in self.option_groups:\n            result.append(group.format_help(formatter))\n            result.append(\"\\n\")\n        formatter.dedent()\n        # Drop the last \"\\n\", or the header if no options or option groups:\n        return \"\".join(result[:-1])\n\n    def format_epilog(self, formatter):\n        return formatter.format_epilog(self.epilog)\n\n    def format_help(self, formatter=None):\n        if formatter is None:\n            formatter = self.formatter\n        result = []\n        if self.usage:\n            result.append(self.get_usage() + \"\\n\")\n        if self.description:\n            result.append(self.format_description(formatter) + \"\\n\")\n        result.append(self.format_option_help(formatter))\n        result.append(self.format_epilog(formatter))\n        return \"\".join(result)\n\n    def print_help(self, file=None):\n        \"\"\"print_help(file : file = stdout)\n\n        Print an extended help message, listing all options and any\n        help text provided with them, to 'file' (default stdout).\n        \"\"\"\n        if file is None:\n            file = sys.stdout\n        file.write(self.format_help())\n"
    },
    {
      "type": "class",
      "qualified_name": "pyfiglet.test.Popen",
      "module": "pyfiglet.test",
      "signature": "(self, args, bufsize=-1, executable=None, stdin=None, stdout=None, stderr=None, preexec_fn=None, close_fds=True, shell=False, cwd=None, env=None, universal_newlines=None, startupinfo=None, creationflags=0, restore_signals=True, start_new_session=False, pass_fds=(), *, user=None, group=None, extra_groups=None, encoding=None, errors=None, text=None, umask=-1, pipesize=-1, process_group=None)",
      "return_description": null,
      "raises": [],
      "decorators": [
        "property",
        "universal_newlines.setter"
      ],
      "examples": [],
      "docstring": "Execute a child program in a new process.\n\nFor a complete description of the arguments see the Python documentation.\n\nArguments:\n  args: A string, or a sequence of program arguments.\n\n  bufsize: supplied as the buffering argument to the open() function when\n      creating the stdin/stdout/stderr pipe file objects\n\n  executable: A replacement program to execute.\n\n  stdin, stdout and stderr: These specify the executed programs' standard\n      input, standard output and standard error file handles, respectively.\n\n  preexec_fn: (POSIX only) An object to be called in the child process\n      just before the child is executed.\n\n  close_fds: Controls closing or inheriting of file descriptors.\n\n  shell: If true, the command will be executed through the shell.\n\n  cwd: Sets the current directory before the child is executed.\n\n  env: Defines the environment variables for the new process.\n\n  text: If true, decode stdin, stdout and stderr using the given encoding\n      (if set) or the system default otherwise.\n\n  universal_newlines: Alias of text, provided for backwards compatibility.\n\n  startupinfo and creationflags (Windows only)\n\n  restore_signals (POSIX only)\n\n  start_new_session (POSIX only)\n\n  process_group (POSIX only)\n\n  group (POSIX only)\n\n  extra_groups (POSIX only)\n\n  user (POSIX only)\n\n  umask (POSIX only)\n\n  pass_fds (POSIX only)\n\n  encoding and errors: Text mode encoding and error handling to use for\n      file objects stdin, stdout and stderr.\n\nAttributes:\n    stdin, stdout, stderr, pid, returncode",
      "source_code": "class Popen:\n    \"\"\" Execute a child program in a new process.\n\n    For a complete description of the arguments see the Python documentation.\n\n    Arguments:\n      args: A string, or a sequence of program arguments.\n\n      bufsize: supplied as the buffering argument to the open() function when\n          creating the stdin/stdout/stderr pipe file objects\n\n      executable: A replacement program to execute.\n\n      stdin, stdout and stderr: These specify the executed programs' standard\n          input, standard output and standard error file handles, respectively.\n\n      preexec_fn: (POSIX only) An object to be called in the child process\n          just before the child is executed.\n\n      close_fds: Controls closing or inheriting of file descriptors.\n\n      shell: If true, the command will be executed through the shell.\n\n      cwd: Sets the current directory before the child is executed.\n\n      env: Defines the environment variables for the new process.\n\n      text: If true, decode stdin, stdout and stderr using the given encoding\n          (if set) or the system default otherwise.\n\n      universal_newlines: Alias of text, provided for backwards compatibility.\n\n      startupinfo and creationflags (Windows only)\n\n      restore_signals (POSIX only)\n\n      start_new_session (POSIX only)\n\n      process_group (POSIX only)\n\n      group (POSIX only)\n\n      extra_groups (POSIX only)\n\n      user (POSIX only)\n\n      umask (POSIX only)\n\n      pass_fds (POSIX only)\n\n      encoding and errors: Text mode encoding and error handling to use for\n          file objects stdin, stdout and stderr.\n\n    Attributes:\n        stdin, stdout, stderr, pid, returncode\n    \"\"\"\n    _child_created = False  # Set here since __del__ checks it\n\n    def __init__(self, args, bufsize=-1, executable=None,\n                 stdin=None, stdout=None, stderr=None,\n                 preexec_fn=None, close_fds=True,\n                 shell=False, cwd=None, env=None, universal_newlines=None,\n                 startupinfo=None, creationflags=0,\n                 restore_signals=True, start_new_session=False,\n                 pass_fds=(), *, user=None, group=None, extra_groups=None,\n                 encoding=None, errors=None, text=None, umask=-1, pipesize=-1,\n                 process_group=None):\n        \"\"\"Create new Popen instance.\"\"\"\n        if not _can_fork_exec:\n            raise OSError(\n                errno.ENOTSUP, f\"{sys.platform} does not support processes.\"\n            )\n\n        _cleanup()\n        # Held while anything is calling waitpid before returncode has been\n        # updated to prevent clobbering returncode if wait() or poll() are\n        # called from multiple threads at once.  After acquiring the lock,\n        # code must re-check self.returncode to see if another thread just\n        # finished a waitpid() call.\n        self._waitpid_lock = threading.Lock()\n\n        self._input = None\n        self._communication_started = False\n        if bufsize is None:\n            bufsize = -1  # Restore default\n        if not isinstance(bufsize, int):\n            raise TypeError(\"bufsize must be an integer\")\n\n        if pipesize is None:\n            pipesize = -1  # Restore default\n        if not isinstance(pipesize, int):\n            raise TypeError(\"pipesize must be an integer\")\n\n        if _mswindows:\n            if preexec_fn is not None:\n                raise ValueError(\"preexec_fn is not supported on Windows \"\n                                 \"platforms\")\n        else:\n            # POSIX\n            if pass_fds and not close_fds:\n                warnings.warn(\"pass_fds overriding close_fds.\", RuntimeWarning)\n                close_fds = True\n            if startupinfo is not None:\n                raise ValueError(\"startupinfo is only supported on Windows \"\n                                 \"platforms\")\n            if creationflags != 0:\n                raise ValueError(\"creationflags is only supported on Windows \"\n                                 \"platforms\")\n\n        self.args = args\n        self.stdin = None\n        self.stdout = None\n        self.stderr = None\n        self.pid = None\n        self.returncode = None\n        self.encoding = encoding\n        self.errors = errors\n        self.pipesize = pipesize\n\n        # Validate the combinations of text and universal_newlines\n        if (text is not None and universal_newlines is not None\n            and bool(universal_newlines) != bool(text)):\n            raise SubprocessError('Cannot disambiguate when both text '\n                                  'and universal_newlines are supplied but '\n                                  'different. Pass one or the other.')\n\n        # Input and output objects. The general principle is like\n        # this:\n        #\n        # Parent                   Child\n        # ------                   -----\n        # p2cwrite   ---stdin--->  p2cread\n        # c2pread    <--stdout---  c2pwrite\n        # errread    <--stderr---  errwrite\n        #\n        # On POSIX, the child objects are file descriptors.  On\n        # Windows, these are Windows file handles.  The parent objects\n        # are file descriptors on both platforms.  The parent objects\n        # are -1 when not using PIPEs. The child objects are -1\n        # when not redirecting.\n\n        (p2cread, p2cwrite,\n         c2pread, c2pwrite,\n         errread, errwrite) = self._get_handles(stdin, stdout, stderr)\n\n        # We wrap OS handles *before* launching the child, otherwise a\n        # quickly terminating child could make our fds unwrappable\n        # (see #8458).\n\n        if _mswindows:\n            if p2cwrite != -1:\n                p2cwrite = msvcrt.open_osfhandle(p2cwrite.Detach(), 0)\n            if c2pread != -1:\n                c2pread = msvcrt.open_osfhandle(c2pread.Detach(), 0)\n            if errread != -1:\n                errread = msvcrt.open_osfhandle(errread.Detach(), 0)\n\n        self.text_mode = encoding or errors or text or universal_newlines\n        if self.text_mode and encoding is None:\n            self.encoding = encoding = _text_encoding()\n\n        # How long to resume waiting on a child after the first ^C.\n        # There is no right value for this.  The purpose is to be polite\n        # yet remain good for interactive users trying to exit a tool.\n        self._sigint_wait_secs = 0.25  # 1/xkcd221.getRandomNumber()\n\n        self._closed_child_pipe_fds = False\n\n        if self.text_mode:\n            if bufsize == 1:\n                line_buffering = True\n                # Use the default buffer size for the underlying binary streams\n                # since they don't support line buffering.\n                bufsize = -1\n            else:\n                line_buffering = False\n\n        if process_group is None:\n            process_group = -1  # The internal APIs are int-only\n\n        gid = None\n        if group is not None:\n            if not hasattr(os, 'setregid'):\n                raise ValueError(\"The 'group' parameter is not supported on the \"\n                                 \"current platform\")\n\n            elif isinstance(group, str):\n                try:\n                    import grp\n                except ImportError:\n                    raise ValueError(\"The group parameter cannot be a string \"\n                                     \"on systems without the grp module\")\n\n                gid = grp.getgrnam(group).gr_gid\n            elif isinstance(group, int):\n                gid = group\n            else:\n                raise TypeError(\"Group must be a string or an integer, not {}\"\n                                .format(type(group)))\n\n            if gid < 0:\n                raise ValueError(f\"Group ID cannot be negative, got {gid}\")\n\n        gids = None\n        if extra_groups is not None:\n            if not hasattr(os, 'setgroups'):\n                raise ValueError(\"The 'extra_groups' parameter is not \"\n                                 \"supported on the current platform\")\n\n            elif isinstance(extra_groups, str):\n                raise ValueError(\"Groups must be a list, not a string\")\n\n            gids = []\n            for extra_group in extra_groups:\n                if isinstance(extra_group, str):\n                    try:\n                        import grp\n                    except ImportError:\n                        raise ValueError(\"Items in extra_groups cannot be \"\n                                         \"strings on systems without the \"\n                                         \"grp module\")\n\n                    gids.append(grp.getgrnam(extra_group).gr_gid)\n                elif isinstance(extra_group, int):\n                    gids.append(extra_group)\n                else:\n                    raise TypeError(\"Items in extra_groups must be a string \"\n                                    \"or integer, not {}\"\n                                    .format(type(extra_group)))\n\n            # make sure that the gids are all positive here so we can do less\n            # checking in the C code\n            for gid_check in gids:\n                if gid_check < 0:\n                    raise ValueError(f\"Group ID cannot be negative, got {gid_check}\")\n\n        uid = None\n        if user is not None:\n            if not hasattr(os, 'setreuid'):\n                raise ValueError(\"The 'user' parameter is not supported on \"\n                                 \"the current platform\")\n\n            elif isinstance(user, str):\n                try:\n                    import pwd\n                except ImportError:\n                    raise ValueError(\"The user parameter cannot be a string \"\n                                     \"on systems without the pwd module\")\n                uid = pwd.getpwnam(user).pw_uid\n            elif isinstance(user, int):\n                uid = user\n            else:\n                raise TypeError(\"User must be a string or an integer\")\n\n            if uid < 0:\n                raise ValueError(f\"User ID cannot be negative, got {uid}\")\n\n        try:\n            if p2cwrite != -1:\n                self.stdin = io.open(p2cwrite, 'wb', bufsize)\n                if self.text_mode:\n                    self.stdin = io.TextIOWrapper(self.stdin, write_through=True,\n                            line_buffering=line_buffering,\n                            encoding=encoding, errors=errors)\n            if c2pread != -1:\n                self.stdout = io.open(c2pread, 'rb', bufsize)\n                if self.text_mode:\n                    self.stdout = io.TextIOWrapper(self.stdout,\n                            encoding=encoding, errors=errors)\n            if errread != -1:\n                self.stderr = io.open(errread, 'rb', bufsize)\n                if self.text_mode:\n                    self.stderr = io.TextIOWrapper(self.stderr,\n                            encoding=encoding, errors=errors)\n\n            self._execute_child(args, executable, preexec_fn, close_fds,\n                                pass_fds, cwd, env,\n                                startupinfo, creationflags, shell,\n                                p2cread, p2cwrite,\n                                c2pread, c2pwrite,\n                                errread, errwrite,\n                                restore_signals,\n                                gid, gids, uid, umask,\n                                start_new_session, process_group)\n        except:\n            # Cleanup if the child failed starting.\n            for f in filter(None, (self.stdin, self.stdout, self.stderr)):\n                try:\n                    f.close()\n                except OSError:\n                    pass  # Ignore EBADF or other errors.\n\n            if not self._closed_child_pipe_fds:\n                to_close = []\n                if stdin == PIPE:\n                    to_close.append(p2cread)\n                if stdout == PIPE:\n                    to_close.append(c2pwrite)\n                if stderr == PIPE:\n                    to_close.append(errwrite)\n                if hasattr(self, '_devnull'):\n                    to_close.append(self._devnull)\n                for fd in to_close:\n                    try:\n                        if _mswindows and isinstance(fd, Handle):\n                            fd.Close()\n                        else:\n                            os.close(fd)\n                    except OSError:\n                        pass\n\n            raise\n\n    def __repr__(self):\n        obj_repr = (\n            f\"<{self.__class__.__name__}: \"\n            f\"returncode: {self.returncode} args: {self.args!r}>\"\n        )\n        if len(obj_repr) > 80:\n            obj_repr = obj_repr[:76] + \"...>\"\n        return obj_repr\n\n    __class_getitem__ = classmethod(types.GenericAlias)\n\n    @property\n    def universal_newlines(self):\n        # universal_newlines as retained as an alias of text_mode for API\n        # compatibility. bpo-31756\n        return self.text_mode\n\n    @universal_newlines.setter\n    def universal_newlines(self, universal_newlines):\n        self.text_mode = bool(universal_newlines)\n\n    def _translate_newlines(self, data, encoding, errors):\n        data = data.decode(encoding, errors)\n        return data.replace(\"\\r\\n\", \"\\n\").replace(\"\\r\", \"\\n\")\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, exc_type, value, traceback):\n        if self.stdout:\n            self.stdout.close()\n        if self.stderr:\n            self.stderr.close()\n        try:  # Flushing a BufferedWriter may raise an error\n            if self.stdin:\n                self.stdin.close()\n        finally:\n            if exc_type == KeyboardInterrupt:\n                # https://bugs.python.org/issue25942\n                # In the case of a KeyboardInterrupt we assume the SIGINT\n                # was also already sent to our child processes.  We can't\n                # block indefinitely as that is not user friendly.\n                # If we have not already waited a brief amount of time in\n                # an interrupted .wait() or .communicate() call, do so here\n                # for consistency.\n                if self._sigint_wait_secs > 0:\n                    try:\n                        self._wait(timeout=self._sigint_wait_secs)\n                    except TimeoutExpired:\n                        pass\n                self._sigint_wait_secs = 0  # Note that this has been done.\n                return  # resume the KeyboardInterrupt\n\n            # Wait for the process to terminate, to avoid zombies.\n            self.wait()\n\n    def __del__(self, _maxsize=sys.maxsize, _warn=warnings.warn):\n        if not self._child_created:\n            # We didn't get to successfully create a child process.\n            return\n        if self.returncode is None:\n            # Not reading subprocess exit status creates a zombie process which\n            # is only destroyed at the parent python process exit\n            _warn(\"subprocess %s is still running\" % self.pid,\n                  ResourceWarning, source=self)\n        # In case the child hasn't been waited on, check if it's done.\n        self._internal_poll(_deadstate=_maxsize)\n        if self.returncode is None and _active is not None:\n            # Child is still running, keep us alive until we can wait on it.\n            _active.append(self)\n\n    def _get_devnull(self):\n        if not hasattr(self, '_devnull'):\n            self._devnull = os.open(os.devnull, os.O_RDWR)\n        return self._devnull\n\n    def _stdin_write(self, input):\n        if input:\n            try:\n                self.stdin.write(input)\n            except BrokenPipeError:\n                pass  # communicate() must ignore broken pipe errors.\n            except OSError as exc:\n                if exc.errno == errno.EINVAL:\n                    # bpo-19612, bpo-30418: On Windows, stdin.write() fails\n                    # with EINVAL if the child process exited or if the child\n                    # process is still running but closed the pipe.\n                    pass\n                else:\n                    raise\n\n        try:\n            self.stdin.close()\n        except BrokenPipeError:\n            pass  # communicate() must ignore broken pipe errors.\n        except OSError as exc:\n            if exc.errno == errno.EINVAL:\n                pass\n            else:\n                raise\n\n    def communicate(self, input=None, timeout=None):\n        \"\"\"Interact with process: Send data to stdin and close it.\n        Read data from stdout and stderr, until end-of-file is\n        reached.  Wait for process to terminate.\n\n        The optional \"input\" argument should be data to be sent to the\n        child process, or None, if no data should be sent to the child.\n        communicate() returns a tuple (stdout, stderr).\n\n        By default, all communication is in bytes, and therefore any\n        \"input\" should be bytes, and the (stdout, stderr) will be bytes.\n        If in text mode (indicated by self.text_mode), any \"input\" should\n        be a string, and (stdout, stderr) will be strings decoded\n        according to locale encoding, or by \"encoding\" if set. Text mode\n        is triggered by setting any of text, encoding, errors or\n        universal_newlines.\n        \"\"\"\n\n        if self._communication_started and input:\n            raise ValueError(\"Cannot send input after starting communication\")\n\n        # Optimization: If we are not worried about timeouts, we haven't\n        # started communicating, and we have one or zero pipes, using select()\n        # or threads is unnecessary.\n        if (timeout is None and not self._communication_started and\n            [self.stdin, self.stdout, self.stderr].count(None) >= 2):\n            stdout = None\n            stderr = None\n            if self.stdin:\n                self._stdin_write(input)\n            elif self.stdout:\n                stdout = self.stdout.read()\n                self.stdout.close()\n            elif self.stderr:\n                stderr = self.stderr.read()\n                self.stderr.close()\n            self.wait()\n        else:\n            if timeout is not None:\n                endtime = _time() + timeout\n            else:\n                endtime = None\n\n            try:\n                stdout, stderr = self._communicate(input, endtime, timeout)\n            except KeyboardInterrupt:\n                # https://bugs.python.org/issue25942\n                # See the detailed comment in .wait().\n                if timeout is not None:\n                    sigint_timeout = min(self._sigint_wait_secs,\n                                         self._remaining_time(endtime))\n                else:\n                    sigint_timeout = self._sigint_wait_secs\n                self._sigint_wait_secs = 0  # nothing else should wait.\n                try:\n                    self._wait(timeout=sigint_timeout)\n                except TimeoutExpired:\n                    pass\n                raise  # resume the KeyboardInterrupt\n\n            finally:\n                self._communication_started = True\n\n            sts = self.wait(timeout=self._remaining_time(endtime))\n\n        return (stdout, stderr)\n\n\n    def poll(self):\n        \"\"\"Check if child process has terminated. Set and return returncode\n        attribute.\"\"\"\n        return self._internal_poll()\n\n\n    def _remaining_time(self, endtime):\n        \"\"\"Convenience for _communicate when computing timeouts.\"\"\"\n        if endtime is None:\n            return None\n        else:\n            return endtime - _time()\n\n\n    def _check_timeout(self, endtime, orig_timeout, stdout_seq, stderr_seq,\n                       skip_check_and_raise=False):\n        \"\"\"Convenience for checking if a timeout has expired.\"\"\"\n        if endtime is None:\n            return\n        if skip_check_and_raise or _time() > endtime:\n            raise TimeoutExpired(\n                    self.args, orig_timeout,\n                    output=b''.join(stdout_seq) if stdout_seq else None,\n                    stderr=b''.join(stderr_seq) if stderr_seq else None)\n\n\n    def wait(self, timeout=None):\n        \"\"\"Wait for child process to terminate; returns self.returncode.\"\"\"\n        if timeout is not None:\n            endtime = _time() + timeout\n        try:\n            return self._wait(timeout=timeout)\n        except KeyboardInterrupt:\n            # https://bugs.python.org/issue25942\n            # The first keyboard interrupt waits briefly for the child to\n            # exit under the common assumption that it also received the ^C\n            # generated SIGINT and will exit rapidly.\n            if timeout is not None:\n                sigint_timeout = min(self._sigint_wait_secs,\n                                     self._remaining_time(endtime))\n            else:\n                sigint_timeout = self._sigint_wait_secs\n            self._sigint_wait_secs = 0  # nothing else should wait.\n            try:\n                self._wait(timeout=sigint_timeout)\n            except TimeoutExpired:\n                pass\n            raise  # resume the KeyboardInterrupt\n\n    def _close_pipe_fds(self,\n                        p2cread, p2cwrite,\n                        c2pread, c2pwrite,\n                        errread, errwrite):\n        # self._devnull is not always defined.\n        devnull_fd = getattr(self, '_devnull', None)\n\n        with contextlib.ExitStack() as stack:\n            if _mswindows:\n                if p2cread != -1:\n                    stack.callback(p2cread.Close)\n                if c2pwrite != -1:\n                    stack.callback(c2pwrite.Close)\n                if errwrite != -1:\n                    stack.callback(errwrite.Close)\n            else:\n                if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:\n                    stack.callback(os.close, p2cread)\n                if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:\n                    stack.callback(os.close, c2pwrite)\n                if errwrite != -1 and errread != -1 and errwrite != devnull_fd:\n                    stack.callback(os.close, errwrite)\n\n            if devnull_fd is not None:\n                stack.callback(os.close, devnull_fd)\n\n        # Prevent a double close of these handles/fds from __init__ on error.\n        self._closed_child_pipe_fds = True\n\n    if _mswindows:\n        #\n        # Windows methods\n        #\n        def _get_handles(self, stdin, stdout, stderr):\n            \"\"\"Construct and return tuple with IO objects:\n            p2cread, p2cwrite, c2pread, c2pwrite, errread, errwrite\n            \"\"\"\n            if stdin is None and stdout is None and stderr is None:\n                return (-1, -1, -1, -1, -1, -1)\n\n            p2cread, p2cwrite = -1, -1\n            c2pread, c2pwrite = -1, -1\n            errread, errwrite = -1, -1\n\n            if stdin is None:\n                p2cread = _winapi.GetStdHandle(_winapi.STD_INPUT_HANDLE)\n                if p2cread is None:\n                    p2cread, _ = _winapi.CreatePipe(None, 0)\n                    p2cread = Handle(p2cread)\n                    _winapi.CloseHandle(_)\n            elif stdin == PIPE:\n                p2cread, p2cwrite = _winapi.CreatePipe(None, 0)\n                p2cread, p2cwrite = Handle(p2cread), Handle(p2cwrite)\n            elif stdin == DEVNULL:\n                p2cread = msvcrt.get_osfhandle(self._get_devnull())\n            elif isinstance(stdin, int):\n                p2cread = msvcrt.get_osfhandle(stdin)\n            else:\n                # Assuming file-like object\n                p2cread = msvcrt.get_osfhandle(stdin.fileno())\n            p2cread = self._make_inheritable(p2cread)\n\n            if stdout is None:\n                c2pwrite = _winapi.GetStdHandle(_winapi.STD_OUTPUT_HANDLE)\n                if c2pwrite is None:\n                    _, c2pwrite = _winapi.CreatePipe(None, 0)\n                    c2pwrite = Handle(c2pwrite)\n                    _winapi.CloseHandle(_)\n            elif stdout == PIPE:\n                c2pread, c2pwrite = _winapi.CreatePipe(None, 0)\n                c2pread, c2pwrite = Handle(c2pread), Handle(c2pwrite)\n            elif stdout == DEVNULL:\n                c2pwrite = msvcrt.get_osfhandle(self._get_devnull())\n            elif isinstance(stdout, int):\n                c2pwrite = msvcrt.get_osfhandle(stdout)\n            else:\n                # Assuming file-like object\n                c2pwrite = msvcrt.get_osfhandle(stdout.fileno())\n            c2pwrite = self._make_inheritable(c2pwrite)\n\n            if stderr is None:\n                errwrite = _winapi.GetStdHandle(_winapi.STD_ERROR_HANDLE)\n                if errwrite is None:\n                    _, errwrite = _winapi.CreatePipe(None, 0)\n                    errwrite = Handle(errwrite)\n                    _winapi.CloseHandle(_)\n            elif stderr == PIPE:\n                errread, errwrite = _winapi.CreatePipe(None, 0)\n                errread, errwrite = Handle(errread), Handle(errwrite)\n            elif stderr == STDOUT:\n                errwrite = c2pwrite\n            elif stderr == DEVNULL:\n                errwrite = msvcrt.get_osfhandle(self._get_devnull())\n            elif isinstance(stderr, int):\n                errwrite = msvcrt.get_osfhandle(stderr)\n            else:\n                # Assuming file-like object\n                errwrite = msvcrt.get_osfhandle(stderr.fileno())\n            errwrite = self._make_inheritable(errwrite)\n\n            return (p2cread, p2cwrite,\n                    c2pread, c2pwrite,\n                    errread, errwrite)\n\n\n        def _make_inheritable(self, handle):\n            \"\"\"Return a duplicate of handle, which is inheritable\"\"\"\n            h = _winapi.DuplicateHandle(\n                _winapi.GetCurrentProcess(), handle,\n                _winapi.GetCurrentProcess(), 0, 1,\n                _winapi.DUPLICATE_SAME_ACCESS)\n            return Handle(h)\n\n\n        def _filter_handle_list(self, handle_list):\n            \"\"\"Filter out console handles that can't be used\n            in lpAttributeList[\"handle_list\"] and make sure the list\n            isn't empty. This also removes duplicate handles.\"\"\"\n            # An handle with it's lowest two bits set might be a special console\n            # handle that if passed in lpAttributeList[\"handle_list\"], will\n            # cause it to fail.\n            return list({handle for handle in handle_list\n                         if handle & 0x3 != 0x3\n                         or _winapi.GetFileType(handle) !=\n                            _winapi.FILE_TYPE_CHAR})\n\n\n        def _execute_child(self, args, executable, preexec_fn, close_fds,\n                           pass_fds, cwd, env,\n                           startupinfo, creationflags, shell,\n                           p2cread, p2cwrite,\n                           c2pread, c2pwrite,\n                           errread, errwrite,\n                           unused_restore_signals,\n                           unused_gid, unused_gids, unused_uid,\n                           unused_umask,\n                           unused_start_new_session, unused_process_group):\n            \"\"\"Execute program (MS Windows version)\"\"\"\n\n            assert not pass_fds, \"pass_fds not supported on Windows.\"\n\n            if isinstance(args, str):\n                pass\n            elif isinstance(args, bytes):\n                if shell:\n                    raise TypeError('bytes args is not allowed on Windows')\n                args = list2cmdline([args])\n            elif isinstance(args, os.PathLike):\n                if shell:\n                    raise TypeError('path-like args is not allowed when '\n                                    'shell is true')\n                args = list2cmdline([args])\n            else:\n                args = list2cmdline(args)\n\n            if executable is not None:\n                executable = os.fsdecode(executable)\n\n            # Process startup details\n            if startupinfo is None:\n                startupinfo = STARTUPINFO()\n            else:\n                # bpo-34044: Copy STARTUPINFO since it is modified above,\n                # so the caller can reuse it multiple times.\n                startupinfo = startupinfo.copy()\n\n            use_std_handles = -1 not in (p2cread, c2pwrite, errwrite)\n            if use_std_handles:\n                startupinfo.dwFlags |= _winapi.STARTF_USESTDHANDLES\n                startupinfo.hStdInput = p2cread\n                startupinfo.hStdOutput = c2pwrite\n                startupinfo.hStdError = errwrite\n\n            attribute_list = startupinfo.lpAttributeList\n            have_handle_list = bool(attribute_list and\n                                    \"handle_list\" in attribute_list and\n                                    attribute_list[\"handle_list\"])\n\n            # If we were given an handle_list or need to create one\n            if have_handle_list or (use_std_handles and close_fds):\n                if attribute_list is None:\n                    attribute_list = startupinfo.lpAttributeList = {}\n                handle_list = attribute_list[\"handle_list\"] = \\\n                    list(attribute_list.get(\"handle_list\", []))\n\n                if use_std_handles:\n                    handle_list += [int(p2cread), int(c2pwrite), int(errwrite)]\n\n                handle_list[:] = self._filter_handle_list(handle_list)\n\n                if handle_list:\n                    if not close_fds:\n                        warnings.warn(\"startupinfo.lpAttributeList['handle_list'] \"\n                                      \"overriding close_fds\", RuntimeWarning)\n\n                    # When using the handle_list we always request to inherit\n                    # handles but the only handles that will be inherited are\n                    # the ones in the handle_list\n                    close_fds = False\n\n            if shell:\n                startupinfo.dwFlags |= _winapi.STARTF_USESHOWWINDOW\n                startupinfo.wShowWindow = _winapi.SW_HIDE\n                comspec = os.environ.get(\"COMSPEC\", \"cmd.exe\")\n                args = '{} /c \"{}\"'.format (comspec, args)\n\n            if cwd is not None:\n                cwd = os.fsdecode(cwd)\n\n            sys.audit(\"subprocess.Popen\", executable, args, cwd, env)\n\n            # Start the process\n            try:\n                hp, ht, pid, tid = _winapi.CreateProcess(executable, args,\n                                         # no special security\n                                         None, None,\n                                         int(not close_fds),\n                                         creationflags,\n                                         env,\n                                         cwd,\n                                         startupinfo)\n            finally:\n                # Child is launched. Close the parent's copy of those pipe\n                # handles that only the child should have open.  You need\n                # to make sure that no handles to the write end of the\n                # output pipe are maintained in this process or else the\n                # pipe will not close when the child process exits and the\n                # ReadFile will hang.\n                self._close_pipe_fds(p2cread, p2cwrite,\n                                     c2pread, c2pwrite,\n                                     errread, errwrite)\n\n            # Retain the process handle, but close the thread handle\n            self._child_created = True\n            self._handle = Handle(hp)\n            self.pid = pid\n            _winapi.CloseHandle(ht)\n\n        def _internal_poll(self, _deadstate=None,\n                _WaitForSingleObject=_winapi.WaitForSingleObject,\n                _WAIT_OBJECT_0=_winapi.WAIT_OBJECT_0,\n                _GetExitCodeProcess=_winapi.GetExitCodeProcess):\n            \"\"\"Check if child process has terminated.  Returns returncode\n            attribute.\n\n            This method is called by __del__, so it can only refer to objects\n            in its local scope.\n\n            \"\"\"\n            if self.returncode is None:\n                if _WaitForSingleObject(self._handle, 0) == _WAIT_OBJECT_0:\n                    self.returncode = _GetExitCodeProcess(self._handle)\n            return self.returncode\n\n\n        def _wait(self, timeout):\n            \"\"\"Internal implementation of wait() on Windows.\"\"\"\n            if timeout is None:\n                timeout_millis = _winapi.INFINITE\n            else:\n                timeout_millis = int(timeout * 1000)\n            if self.returncode is None:\n                # API note: Returns immediately if timeout_millis == 0.\n                result = _winapi.WaitForSingleObject(self._handle,\n                                                     timeout_millis)\n                if result == _winapi.WAIT_TIMEOUT:\n                    raise TimeoutExpired(self.args, timeout)\n                self.returncode = _winapi.GetExitCodeProcess(self._handle)\n            return self.returncode\n\n\n        def _readerthread(self, fh, buffer):\n            buffer.append(fh.read())\n            fh.close()\n\n\n        def _communicate(self, input, endtime, orig_timeout):\n            # Start reader threads feeding into a list hanging off of this\n            # object, unless they've already been started.\n            if self.stdout and not hasattr(self, \"_stdout_buff\"):\n                self._stdout_buff = []\n                self.stdout_thread = \\\n                        threading.Thread(target=self._readerthread,\n                                         args=(self.stdout, self._stdout_buff))\n                self.stdout_thread.daemon = True\n                self.stdout_thread.start()\n            if self.stderr and not hasattr(self, \"_stderr_buff\"):\n                self._stderr_buff = []\n                self.stderr_thread = \\\n                        threading.Thread(target=self._readerthread,\n                                         args=(self.stderr, self._stderr_buff))\n                self.stderr_thread.daemon = True\n                self.stderr_thread.start()\n\n            if self.stdin:\n                self._stdin_write(input)\n\n            # Wait for the reader threads, or time out.  If we time out, the\n            # threads remain reading and the fds left open in case the user\n            # calls communicate again.\n            if self.stdout is not None:\n                self.stdout_thread.join(self._remaining_time(endtime))\n                if self.stdout_thread.is_alive():\n                    raise TimeoutExpired(self.args, orig_timeout)\n            if self.stderr is not None:\n                self.stderr_thread.join(self._remaining_time(endtime))\n                if self.stderr_thread.is_alive():\n                    raise TimeoutExpired(self.args, orig_timeout)\n\n            # Collect the output from and close both pipes, now that we know\n            # both have been read successfully.\n            stdout = None\n            stderr = None\n            if self.stdout:\n                stdout = self._stdout_buff\n                self.stdout.close()\n            if self.stderr:\n                stderr = self._stderr_buff\n                self.stderr.close()\n\n            # All data exchanged.  Translate lists into strings.\n            stdout = stdout[0] if stdout else None\n            stderr = stderr[0] if stderr else None\n\n            return (stdout, stderr)\n\n        def send_signal(self, sig):\n            \"\"\"Send a signal to the process.\"\"\"\n            # Don't signal a process that we know has already died.\n            if self.returncode is not None:\n                return\n            if sig == signal.SIGTERM:\n                self.terminate()\n            elif sig == signal.CTRL_C_EVENT:\n                os.kill(self.pid, signal.CTRL_C_EVENT)\n            elif sig == signal.CTRL_BREAK_EVENT:\n                os.kill(self.pid, signal.CTRL_BREAK_EVENT)\n            else:\n                raise ValueError(\"Unsupported signal: {}\".format(sig))\n\n        def terminate(self):\n            \"\"\"Terminates the process.\"\"\"\n            # Don't terminate a process that we know has already died.\n            if self.returncode is not None:\n                return\n            try:\n                _winapi.TerminateProcess(self._handle, 1)\n            except PermissionError:\n                # ERROR_ACCESS_DENIED (winerror 5) is received when the\n                # process already died.\n                rc = _winapi.GetExitCodeProcess(self._handle)\n                if rc == _winapi.STILL_ACTIVE:\n                    raise\n                self.returncode = rc\n\n        kill = terminate\n\n    else:\n        #\n        # POSIX methods\n        #\n        def _get_handles(self, stdin, stdout, stderr):\n            \"\"\"Construct and return tuple with IO objects:\n            p2cread, p2cwrite, c2pread, c2pwrite, errread, errwrite\n            \"\"\"\n            p2cread, p2cwrite = -1, -1\n            c2pread, c2pwrite = -1, -1\n            errread, errwrite = -1, -1\n\n            if stdin is None:\n                pass\n            elif stdin == PIPE:\n                p2cread, p2cwrite = os.pipe()\n                if self.pipesize > 0 and hasattr(fcntl, \"F_SETPIPE_SZ\"):\n                    fcntl.fcntl(p2cwrite, fcntl.F_SETPIPE_SZ, self.pipesize)\n            elif stdin == DEVNULL:\n                p2cread = self._get_devnull()\n            elif isinstance(stdin, int):\n                p2cread = stdin\n            else:\n                # Assuming file-like object\n                p2cread = stdin.fileno()\n\n            if stdout is None:\n                pass\n            elif stdout == PIPE:\n                c2pread, c2pwrite = os.pipe()\n                if self.pipesize > 0 and hasattr(fcntl, \"F_SETPIPE_SZ\"):\n                    fcntl.fcntl(c2pwrite, fcntl.F_SETPIPE_SZ, self.pipesize)\n            elif stdout == DEVNULL:\n                c2pwrite = self._get_devnull()\n            elif isinstance(stdout, int):\n                c2pwrite = stdout\n            else:\n                # Assuming file-like object\n                c2pwrite = stdout.fileno()\n\n            if stderr is None:\n                pass\n            elif stderr == PIPE:\n                errread, errwrite = os.pipe()\n                if self.pipesize > 0 and hasattr(fcntl, \"F_SETPIPE_SZ\"):\n                    fcntl.fcntl(errwrite, fcntl.F_SETPIPE_SZ, self.pipesize)\n            elif stderr == STDOUT:\n                if c2pwrite != -1:\n                    errwrite = c2pwrite\n                else: # child's stdout is not set, use parent's stdout\n                    errwrite = sys.__stdout__.fileno()\n            elif stderr == DEVNULL:\n                errwrite = self._get_devnull()\n            elif isinstance(stderr, int):\n                errwrite = stderr\n            else:\n                # Assuming file-like object\n                errwrite = stderr.fileno()\n\n            return (p2cread, p2cwrite,\n                    c2pread, c2pwrite,\n                    errread, errwrite)\n\n\n        def _posix_spawn(self, args, executable, env, restore_signals,\n                         p2cread, p2cwrite,\n                         c2pread, c2pwrite,\n                         errread, errwrite):\n            \"\"\"Execute program using os.posix_spawn().\"\"\"\n            if env is None:\n                env = os.environ\n\n            kwargs = {}\n            if restore_signals:\n                # See _Py_RestoreSignals() in Python/pylifecycle.c\n                sigset = []\n                for signame in ('SIGPIPE', 'SIGXFZ', 'SIGXFSZ'):\n                    signum = getattr(signal, signame, None)\n                    if signum is not None:\n                        sigset.append(signum)\n                kwargs['setsigdef'] = sigset\n\n            file_actions = []\n            for fd in (p2cwrite, c2pread, errread):\n                if fd != -1:\n                    file_actions.append((os.POSIX_SPAWN_CLOSE, fd))\n            for fd, fd2 in (\n                (p2cread, 0),\n                (c2pwrite, 1),\n                (errwrite, 2),\n            ):\n                if fd != -1:\n                    file_actions.append((os.POSIX_SPAWN_DUP2, fd, fd2))\n            if file_actions:\n                kwargs['file_actions'] = file_actions\n\n            self.pid = os.posix_spawn(executable, args, env, **kwargs)\n            self._child_created = True\n\n            self._close_pipe_fds(p2cread, p2cwrite,\n                                 c2pread, c2pwrite,\n                                 errread, errwrite)\n\n        def _execute_child(self, args, executable, preexec_fn, close_fds,\n                           pass_fds, cwd, env,\n                           startupinfo, creationflags, shell,\n                           p2cread, p2cwrite,\n                           c2pread, c2pwrite,\n                           errread, errwrite,\n                           restore_signals,\n                           gid, gids, uid, umask,\n                           start_new_session, process_group):\n            \"\"\"Execute program (POSIX version)\"\"\"\n\n            if isinstance(args, (str, bytes)):\n                args = [args]\n            elif isinstance(args, os.PathLike):\n                if shell:\n                    raise TypeError('path-like args is not allowed when '\n                                    'shell is true')\n                args = [args]\n            else:\n                args = list(args)\n\n            if shell:\n                # On Android the default shell is at '/system/bin/sh'.\n                unix_shell = ('/system/bin/sh' if\n                          hasattr(sys, 'getandroidapilevel') else '/bin/sh')\n                args = [unix_shell, \"-c\"] + args\n                if executable:\n                    args[0] = executable\n\n            if executable is None:\n                executable = args[0]\n\n            sys.audit(\"subprocess.Popen\", executable, args, cwd, env)\n\n            if (_USE_POSIX_SPAWN\n                    and os.path.dirname(executable)\n                    and preexec_fn is None\n                    and not close_fds\n                    and not pass_fds\n                    and cwd is None\n                    and (p2cread == -1 or p2cread > 2)\n                    and (c2pwrite == -1 or c2pwrite > 2)\n                    and (errwrite == -1 or errwrite > 2)\n                    and not start_new_session\n                    and process_group == -1\n                    and gid is None\n                    and gids is None\n                    and uid is None\n                    and umask < 0):\n                self._posix_spawn(args, executable, env, restore_signals,\n                                  p2cread, p2cwrite,\n                                  c2pread, c2pwrite,\n                                  errread, errwrite)\n                return\n\n            orig_executable = executable\n\n            # For transferring possible exec failure from child to parent.\n            # Data format: \"exception name:hex errno:description\"\n            # Pickle is not used; it is complex and involves memory allocation.\n            errpipe_read, errpipe_write = os.pipe()\n            # errpipe_write must not be in the standard io 0, 1, or 2 fd range.\n            low_fds_to_close = []\n            while errpipe_write < 3:\n                low_fds_to_close.append(errpipe_write)\n                errpipe_write = os.dup(errpipe_write)\n            for low_fd in low_fds_to_close:\n                os.close(low_fd)\n            try:\n                try:\n                    # We must avoid complex work that could involve\n                    # malloc or free in the child process to avoid\n                    # potential deadlocks, thus we do all this here.\n                    # and pass it to fork_exec()\n\n                    if env is not None:\n                        env_list = []\n                        for k, v in env.items():\n                            k = os.fsencode(k)\n                            if b'=' in k:\n                                raise ValueError(\"illegal environment variable name\")\n                            env_list.append(k + b'=' + os.fsencode(v))\n                    else:\n                        env_list = None  # Use execv instead of execve.\n                    executable = os.fsencode(executable)\n                    if os.path.dirname(executable):\n                        executable_list = (executable,)\n                    else:\n                        # This matches the behavior of os._execvpe().\n                        executable_list = tuple(\n                            os.path.join(os.fsencode(dir), executable)\n                            for dir in os.get_exec_path(env))\n                    fds_to_keep = set(pass_fds)\n                    fds_to_keep.add(errpipe_write)\n                    self.pid = _fork_exec(\n                            args, executable_list,\n                            close_fds, tuple(sorted(map(int, fds_to_keep))),\n                            cwd, env_list,\n                            p2cread, p2cwrite, c2pread, c2pwrite,\n                            errread, errwrite,\n                            errpipe_read, errpipe_write,\n                            restore_signals, start_new_session,\n                            process_group, gid, gids, uid, umask,\n                            preexec_fn, _USE_VFORK)\n                    self._child_created = True\n                finally:\n                    # be sure the FD is closed no matter what\n                    os.close(errpipe_write)\n\n                self._close_pipe_fds(p2cread, p2cwrite,\n                                     c2pread, c2pwrite,\n                                     errread, errwrite)\n\n                # Wait for exec to fail or succeed; possibly raising an\n                # exception (limited in size)\n                errpipe_data = bytearray()\n                while True:\n                    part = os.read(errpipe_read, 50000)\n                    errpipe_data += part\n                    if not part or len(errpipe_data) > 50000:\n                        break\n            finally:\n                # be sure the FD is closed no matter what\n                os.close(errpipe_read)\n\n            if errpipe_data:\n                try:\n                    pid, sts = os.waitpid(self.pid, 0)\n                    if pid == self.pid:\n                        self._handle_exitstatus(sts)\n                    else:\n                        self.returncode = sys.maxsize\n                except ChildProcessError:\n                    pass\n\n                try:\n                    exception_name, hex_errno, err_msg = (\n                            errpipe_data.split(b':', 2))\n                    # The encoding here should match the encoding\n                    # written in by the subprocess implementations\n                    # like _posixsubprocess\n                    err_msg = err_msg.decode()\n                except ValueError:\n                    exception_name = b'SubprocessError'\n                    hex_errno = b'0'\n                    err_msg = 'Bad exception data from child: {!r}'.format(\n                                  bytes(errpipe_data))\n                child_exception_type = getattr(\n                        builtins, exception_name.decode('ascii'),\n                        SubprocessError)\n                if issubclass(child_exception_type, OSError) and hex_errno:\n                    errno_num = int(hex_errno, 16)\n                    child_exec_never_called = (err_msg == \"noexec\")\n                    if child_exec_never_called:\n                        err_msg = \"\"\n                        # The error must be from chdir(cwd).\n                        err_filename = cwd\n                    else:\n                        err_filename = orig_executable\n                    if errno_num != 0:\n                        err_msg = os.strerror(errno_num)\n                    raise child_exception_type(errno_num, err_msg, err_filename)\n                raise child_exception_type(err_msg)\n\n\n        def _handle_exitstatus(self, sts,\n                               _waitstatus_to_exitcode=_waitstatus_to_exitcode,\n                               _WIFSTOPPED=_WIFSTOPPED,\n                               _WSTOPSIG=_WSTOPSIG):\n            \"\"\"All callers to this function MUST hold self._waitpid_lock.\"\"\"\n            # This method is called (indirectly) by __del__, so it cannot\n            # refer to anything outside of its local scope.\n            if _WIFSTOPPED(sts):\n                self.returncode = -_WSTOPSIG(sts)\n            else:\n                self.returncode = _waitstatus_to_exitcode(sts)\n\n        def _internal_poll(self, _deadstate=None, _waitpid=_waitpid,\n                _WNOHANG=_WNOHANG, _ECHILD=errno.ECHILD):\n            \"\"\"Check if child process has terminated.  Returns returncode\n            attribute.\n\n            This method is called by __del__, so it cannot reference anything\n            outside of the local scope (nor can any methods it calls).\n\n            \"\"\"\n            if self.returncode is None:\n                if not self._waitpid_lock.acquire(False):\n                    # Something else is busy calling waitpid.  Don't allow two\n                    # at once.  We know nothing yet.\n                    return None\n                try:\n                    if self.returncode is not None:\n                        return self.returncode  # Another thread waited.\n                    pid, sts = _waitpid(self.pid, _WNOHANG)\n                    if pid == self.pid:\n                        self._handle_exitstatus(sts)\n                except OSError as e:\n                    if _deadstate is not None:\n                        self.returncode = _deadstate\n                    elif e.errno == _ECHILD:\n                        # This happens if SIGCLD is set to be ignored or\n                        # waiting for child processes has otherwise been\n                        # disabled for our process.  This child is dead, we\n                        # can't get the status.\n                        # http://bugs.python.org/issue15756\n                        self.returncode = 0\n                finally:\n                    self._waitpid_lock.release()\n            return self.returncode\n\n\n        def _try_wait(self, wait_flags):\n            \"\"\"All callers to this function MUST hold self._waitpid_lock.\"\"\"\n            try:\n                (pid, sts) = os.waitpid(self.pid, wait_flags)\n            except ChildProcessError:\n                # This happens if SIGCLD is set to be ignored or waiting\n                # for child processes has otherwise been disabled for our\n                # process.  This child is dead, we can't get the status.\n                pid = self.pid\n                sts = 0\n            return (pid, sts)\n\n\n        def _wait(self, timeout):\n            \"\"\"Internal implementation of wait() on POSIX.\"\"\"\n            if self.returncode is not None:\n                return self.returncode\n\n            if timeout is not None:\n                endtime = _time() + timeout\n                # Enter a busy loop if we have a timeout.  This busy loop was\n                # cribbed from Lib/threading.py in Thread.wait() at r71065.\n                delay = 0.0005 # 500 us -> initial delay of 1 ms\n                while True:\n                    if self._waitpid_lock.acquire(False):\n                        try:\n                            if self.returncode is not None:\n                                break  # Another thread waited.\n                            (pid, sts) = self._try_wait(os.WNOHANG)\n                            assert pid == self.pid or pid == 0\n                            if pid == self.pid:\n                                self._handle_exitstatus(sts)\n                                break\n                        finally:\n                            self._waitpid_lock.release()\n                    remaining = self._remaining_time(endtime)\n                    if remaining <= 0:\n                        raise TimeoutExpired(self.args, timeout)\n                    delay = min(delay * 2, remaining, .05)\n                    time.sleep(delay)\n            else:\n                while self.returncode is None:\n                    with self._waitpid_lock:\n                        if self.returncode is not None:\n                            break  # Another thread waited.\n                        (pid, sts) = self._try_wait(0)\n                        # Check the pid and loop as waitpid has been known to\n                        # return 0 even without WNOHANG in odd situations.\n                        # http://bugs.python.org/issue14396.\n                        if pid == self.pid:\n                            self._handle_exitstatus(sts)\n            return self.returncode\n\n\n        def _communicate(self, input, endtime, orig_timeout):\n            if self.stdin and not self._communication_started:\n                # Flush stdio buffer.  This might block, if the user has\n                # been writing to .stdin in an uncontrolled fashion.\n                try:\n                    self.stdin.flush()\n                except BrokenPipeError:\n                    pass  # communicate() must ignore BrokenPipeError.\n                if not input:\n                    try:\n                        self.stdin.close()\n                    except BrokenPipeError:\n                        pass  # communicate() must ignore BrokenPipeError.\n\n            stdout = None\n            stderr = None\n\n            # Only create this mapping if we haven't already.\n            if not self._communication_started:\n                self._fileobj2output = {}\n                if self.stdout:\n                    self._fileobj2output[self.stdout] = []\n                if self.stderr:\n                    self._fileobj2output[self.stderr] = []\n\n            if self.stdout:\n                stdout = self._fileobj2output[self.stdout]\n            if self.stderr:\n                stderr = self._fileobj2output[self.stderr]\n\n            self._save_input(input)\n\n            if self._input:\n                input_view = memoryview(self._input)\n\n            with _PopenSelector() as selector:\n                if self.stdin and input:\n                    selector.register(self.stdin, selectors.EVENT_WRITE)\n                if self.stdout and not self.stdout.closed:\n                    selector.register(self.stdout, selectors.EVENT_READ)\n                if self.stderr and not self.stderr.closed:\n                    selector.register(self.stderr, selectors.EVENT_READ)\n\n                while selector.get_map():\n                    timeout = self._remaining_time(endtime)\n                    if timeout is not None and timeout < 0:\n                        self._check_timeout(endtime, orig_timeout,\n                                            stdout, stderr,\n                                            skip_check_and_raise=True)\n                        raise RuntimeError(  # Impossible :)\n                            '_check_timeout(..., skip_check_and_raise=True) '\n                            'failed to raise TimeoutExpired.')\n\n                    ready = selector.select(timeout)\n                    self._check_timeout(endtime, orig_timeout, stdout, stderr)\n\n                    # XXX Rewrite these to use non-blocking I/O on the file\n                    # objects; they are no longer using C stdio!\n\n                    for key, events in ready:\n                        if key.fileobj is self.stdin:\n                            chunk = input_view[self._input_offset :\n                                               self._input_offset + _PIPE_BUF]\n                            try:\n                                self._input_offset += os.write(key.fd, chunk)\n                            except BrokenPipeError:\n                                selector.unregister(key.fileobj)\n                                key.fileobj.close()\n                            else:\n                                if self._input_offset >= len(self._input):\n                                    selector.unregister(key.fileobj)\n                                    key.fileobj.close()\n                        elif key.fileobj in (self.stdout, self.stderr):\n                            data = os.read(key.fd, 32768)\n                            if not data:\n                                selector.unregister(key.fileobj)\n                                key.fileobj.close()\n                            self._fileobj2output[key.fileobj].append(data)\n\n            self.wait(timeout=self._remaining_time(endtime))\n\n            # All data exchanged.  Translate lists into strings.\n            if stdout is not None:\n                stdout = b''.join(stdout)\n            if stderr is not None:\n                stderr = b''.join(stderr)\n\n            # Translate newlines, if requested.\n            # This also turns bytes into strings.\n            if self.text_mode:\n                if stdout is not None:\n                    stdout = self._translate_newlines(stdout,\n                                                      self.stdout.encoding,\n                                                      self.stdout.errors)\n                if stderr is not None:\n                    stderr = self._translate_newlines(stderr,\n                                                      self.stderr.encoding,\n                                                      self.stderr.errors)\n\n            return (stdout, stderr)\n\n\n        def _save_input(self, input):\n            # This method is called from the _communicate_with_*() methods\n            # so that if we time out while communicating, we can continue\n            # sending input if we retry.\n            if self.stdin and self._input is None:\n                self._input_offset = 0\n                self._input = input\n                if input is not None and self.text_mode:\n                    self._input = self._input.encode(self.stdin.encoding,\n                                                     self.stdin.errors)\n\n\n        def send_signal(self, sig):\n            \"\"\"Send a signal to the process.\"\"\"\n            # bpo-38630: Polling reduces the risk of sending a signal to the\n            # wrong process if the process completed, the Popen.returncode\n            # attribute is still None, and the pid has been reassigned\n            # (recycled) to a new different process. This race condition can\n            # happens in two cases.\n            #\n            # Case 1. Thread A calls Popen.poll(), thread B calls\n            # Popen.send_signal(). In thread A, waitpid() succeed and returns\n            # the exit status. Thread B calls kill() because poll() in thread A\n            # did not set returncode yet. Calling poll() in thread B prevents\n            # the race condition thanks to Popen._waitpid_lock.\n            #\n            # Case 2. waitpid(pid, 0) has been called directly, without\n            # using Popen methods: returncode is still None is this case.\n            # Calling Popen.poll() will set returncode to a default value,\n            # since waitpid() fails with ProcessLookupError.\n            self.poll()\n            if self.returncode is not None:\n                # Skip signalling a process that we know has already died.\n                return\n\n            # The race condition can still happen if the race condition\n            # described above happens between the returncode test\n            # and the kill() call.\n            try:\n                os.kill(self.pid, sig)\n            except ProcessLookupError:\n                # Suppress the race condition error; bpo-40550.\n                pass\n\n        def terminate(self):\n            \"\"\"Terminate the process with SIGTERM\n            \"\"\"\n            self.send_signal(signal.SIGTERM)\n\n        def kill(self):\n            \"\"\"Kill the process with SIGKILL\n            \"\"\"\n            self.send_signal(signal.SIGKILL)\n"
    },
    {
      "type": "class",
      "qualified_name": "pyfiglet.test.Test",
      "module": "pyfiglet.test",
      "signature": "(self, opts)",
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "class Test(object):\n    def __init__(self, opts):\n        self.opts = opts\n        self.ok = 0\n        self.fail = 0\n        self.failed = []\n        self.oked = []\n        # known bugs...\n        self.skip = ['konto', 'konto_slant']\n\n        self.f = Figlet()\n\n    def outputUsingFigletorToilet(self, text, font, fontpath):\n        if os.path.isfile(fontpath + '.flf'):\n            cmd = ('figlet', '-d', 'pyfiglet/fonts', '-f', font, text)\n        elif os.path.isfile(fontpath + '.tlf'):\n            cmd = ('toilet', '-d', 'pyfiglet/fonts', '-f', font, text)\n        else:\n            raise Exception('Missing font file: {}'.format(fontpath))\n\n        p = Popen(cmd, bufsize=4096, stdout=PIPE)\n        try:\n            outputFiglet = p.communicate()[0].decode('utf8')\n        except UnicodeDecodeError as e:\n            print(\"Unicode Error handling font {}\".format(font))\n            outputFiglet = ''\n        return outputFiglet\n\n    def validate_font_output(self, font, outputFiglet, outputPyfiglet):\n        if outputPyfiglet == outputFiglet:\n            win('[OK] %s' % font)\n            self.ok += 1\n            self.oked.append(font)\n            return\n\n        fail('[FAIL] %s' % font)\n        self.fail += 1\n        self.failed.append(font)\n        self.show_result(outputFiglet, outputPyfiglet, font)\n\n    def show_result(self, outputFiglet, outputPyfiglet, font):\n        if self.opts.show is True:\n            print('[PYTHON] *** %s\\n\\n' % font)\n            dump(outputPyfiglet)\n            print('[FIGLET] *** %s\\n\\n' % font)\n            dump(outputFiglet)\n            input()\n\n    def check_font(self, text, font, use_tlf):\n        # Skip flagged bad fonts\n        if font in self.skip:\n            return\n\n        # Our TLF rendering isn't perfect, yet\n        fontpath = os.path.join('pyfiglet', 'fonts', font)\n        fig_file = os.path.isfile(fontpath + '.flf')\n        if not use_tlf and not fig_file:\n            return\n\n        self.f.setFont(font=font)\n        outputPyfiglet = self.f.renderText(text)\n        outputFiglet = self.outputUsingFigletorToilet(text, font, fontpath)\n        self.validate_font_output(font, outputFiglet, outputPyfiglet)\n\n\n    def check_text(self, text, use_tlf):\n        for font in self.f.getFonts():\n            self.check_font(text, font, use_tlf)\n\n    def check_result(self):\n        print('OK = %d, FAIL = %d' % (self.ok, self.fail))\n        if len(self.failed) > 0:\n            print('FAILED = %s' % set(self.failed))\n\n        return self.failed, self.oked\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.Figlet.getDirection",
      "module": "pyfiglet",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def getDirection(self):\n        if self._direction == 'auto':\n            direction = self.Font.printDirection\n            if direction == 0:\n                return 'left-to-right'\n            elif direction == 1:\n                return 'right-to-left'\n            else:\n                return 'left-to-right'\n\n        else:\n            return self._direction\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.Figlet.getFonts",
      "module": "pyfiglet",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def getFonts(self):\n        return self.Font.getFonts()\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.Figlet.getJustify",
      "module": "pyfiglet",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def getJustify(self):\n        if self._justify == 'auto':\n            if self.direction == 'left-to-right':\n                return 'left'\n            elif self.direction == 'right-to-left':\n                return 'right'\n\n        else:\n            return self._justify\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.Figlet.renderText",
      "module": "pyfiglet",
      "signature": "(self, text)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "text": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def renderText(self, text):\n        # wrapper method to engine\n        return self.engine.render(text)\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.Figlet.setFont",
      "module": "pyfiglet",
      "signature": "(self, **kwargs)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def setFont(self, **kwargs):\n        if 'font' in kwargs:\n            self.font = kwargs['font']\n\n        self.Font = FigletFont(font=self.font)\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.FigletBuilder.addCharToProduct",
      "module": "pyfiglet",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def addCharToProduct(self):\n        curChar = self.getCurChar()\n\n        # if the character is a newline, we flush the buffer\n        if self.text[self.iterator] == ord(\"\\n\"):\n                self.blankMarkers.append(([row for row in self.buffer], self.iterator))\n                self.handleNewLine()\n                return None\n\n        if curChar is None:\n            return\n        if self.width < self.getCurWidth():\n            raise CharNotPrinted(\"Width is not enough to print this character\")\n        self.curCharWidth = self.getCurWidth()\n        self.maxSmush = self.currentSmushAmount(curChar)\n\n        self.currentTotalWidth = len(self.buffer[0]) + self.curCharWidth - self.maxSmush\n\n        if self.text[self.iterator] == ord(' '):\n            self.blankMarkers.append(([row for row in self.buffer], self.iterator))\n\n        if self.text[self.iterator] == ord('\\n'):\n            self.blankMarkers.append(([row for row in self.buffer], self.iterator))\n            self.handleNewLine()\n\n        if (self.currentTotalWidth >= self.width):\n            self.handleNewLine()\n        else:\n            for row in range(0, self.font.height):\n                self.addCurCharRowToBufferRow(curChar, row)\n\n\n        self.prevCharWidth = self.curCharWidth\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.FigletBuilder.addCurCharRowToBufferRow",
      "module": "pyfiglet",
      "signature": "(self, curChar, row)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "curChar": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "row": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def addCurCharRowToBufferRow(self, curChar, row):\n        addLeft, addRight = self.smushRow(curChar, row)\n        self.buffer[row] = addLeft + addRight[self.maxSmush:]\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.FigletBuilder.blankExist",
      "module": "pyfiglet",
      "signature": "(self, last_blank)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "last_blank": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def blankExist(self, last_blank):\n        return last_blank != -1\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.FigletBuilder.currentSmushAmount",
      "module": "pyfiglet",
      "signature": "(self, curChar)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "curChar": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def currentSmushAmount(self, curChar):\n        return self.smushAmount(self.buffer, curChar)\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.FigletBuilder.cutBufferAtLastBlank",
      "module": "pyfiglet",
      "signature": "(self, saved_buffer, saved_iterator)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "saved_buffer": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "saved_iterator": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def cutBufferAtLastBlank(self, saved_buffer, saved_iterator):\n        self.product.append(saved_buffer)\n        self.iterator = saved_iterator\n        self.cutBufferCommon()\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.FigletBuilder.cutBufferAtLastChar",
      "module": "pyfiglet",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def cutBufferAtLastChar(self):\n        self.product.append(self.buffer)\n        self.iterator -= 1\n        self.cutBufferCommon()\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.FigletBuilder.cutBufferCommon",
      "module": "pyfiglet",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def cutBufferCommon(self):\n        self.currentTotalWidth = 0\n        self.buffer = ['' for i in range(self.font.height)]\n        self.blankMarkers = list()\n        self.prevCharWidth = 0\n        curChar = self.getCurChar()\n        if curChar is None:\n            return\n        self.maxSmush = self.currentSmushAmount(curChar)\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.FigletBuilder.flushLastBuffer",
      "module": "pyfiglet",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def flushLastBuffer(self):\n        self.product.append(self.buffer)\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.FigletBuilder.formatProduct",
      "module": "pyfiglet",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "This create the output string representation from\nthe internal representation of the product",
      "source_code": "    def formatProduct(self):\n        \"\"\"\n        This create the output string representation from\n        the internal representation of the product\n        \"\"\"\n        string_acc = ''\n        for buffer in self.product.queue:\n            buffer = self.justifyString(self.justify, buffer)\n            string_acc += self.replaceHardblanks(buffer)\n        self.product.buffer_string = string_acc\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.FigletBuilder.getCharAt",
      "module": "pyfiglet",
      "signature": "(self, i)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "i": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def getCharAt(self, i):\n        if i < 0 or i >= len(list(self.text)):\n            return None\n        c = self.text[i]\n\n        if c not in self.font.chars:\n            return None\n        else:\n            return self.font.chars[c]\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.FigletBuilder.getCharWidthAt",
      "module": "pyfiglet",
      "signature": "(self, i)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "i": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def getCharWidthAt(self, i):\n        if i < 0 or i >= len(self.text):\n            return None\n        c = self.text[i]\n        if c not in self.font.chars:\n            return None\n        else:\n            return self.font.width[c]\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.FigletBuilder.getCurChar",
      "module": "pyfiglet",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def getCurChar(self):\n        return self.getCharAt(self.iterator)\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.FigletBuilder.getCurWidth",
      "module": "pyfiglet",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def getCurWidth(self):\n        return self.getCharWidthAt(self.iterator)\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.FigletBuilder.getLastBlank",
      "module": "pyfiglet",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def getLastBlank(self):\n        try:\n            saved_buffer, saved_iterator = self.blankMarkers.pop()\n        except IndexError:\n            return -1,-1\n        return (saved_buffer, saved_iterator)\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.FigletBuilder.getLeftSmushedChar",
      "module": "pyfiglet",
      "signature": "(self, i, addLeft)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "i": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "addLeft": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def getLeftSmushedChar(self, i, addLeft):\n        idx = len(addLeft) - self.maxSmush + i\n        if idx >= 0 and idx < len(addLeft):\n            left = addLeft[idx]\n        else:\n            left = ''\n        return left, idx\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.FigletBuilder.goToNextChar",
      "module": "pyfiglet",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def goToNextChar(self):\n        self.iterator += 1\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.FigletBuilder.handleNewLine",
      "module": "pyfiglet",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def handleNewLine(self):\n        saved_buffer, saved_iterator = self.getLastBlank()\n        if self.blankExist(saved_iterator):\n            self.cutBufferAtLastBlank(saved_buffer, saved_iterator)\n        else:\n            self.cutBufferAtLastChar()\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.FigletBuilder.isNotFinished",
      "module": "pyfiglet",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def isNotFinished(self):\n        ret = self.iterator < len(self.text)\n        return ret\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.FigletBuilder.justifyString",
      "module": "pyfiglet",
      "signature": "(self, justify, buffer)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "justify": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "buffer": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def justifyString(self, justify, buffer):\n        if justify == 'right':\n            for row in range(0, self.font.height):\n                buffer[row] = (\n                        ' ' * (self.width - len(buffer[row]) - 1)\n                        ) + buffer[row]\n        elif justify == 'center':\n            for row in range(0, self.font.height):\n                buffer[row] = (\n                        ' ' * int((self.width - len(buffer[row])) / 2)\n                        ) + buffer[row]\n        return buffer\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.FigletBuilder.replaceHardblanks",
      "module": "pyfiglet",
      "signature": "(self, buffer)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "buffer": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def replaceHardblanks(self, buffer):\n        string = '\\n'.join(buffer) + '\\n'\n        string = string.replace(self.font.hardBlank, ' ')\n        return string\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.FigletBuilder.returnProduct",
      "module": "pyfiglet",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Returns the output string created by formatProduct",
      "source_code": "    def returnProduct(self):\n        \"\"\"\n        Returns the output string created by formatProduct\n        \"\"\"\n        if self.buffer[0] != '':\n            self.flushLastBuffer()\n        self.formatProduct()\n        return self.product.getString()\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.FigletBuilder.smushAmount",
      "module": "pyfiglet",
      "signature": "(self, buffer=[], curChar=[])",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "buffer": {
          "default": "[]",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "curChar": {
          "default": "[]",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Calculate the amount of smushing we can do between this char and the\nlast If this is the first char it will throw a series of exceptions\nwhich are caught and cause appropriate values to be set for later.\n\nThis differs from C figlet which will just get bogus values from\nmemory and then discard them after.",
      "source_code": "    def smushAmount(self, buffer=[], curChar=[]):\n        \"\"\"\n        Calculate the amount of smushing we can do between this char and the\n        last If this is the first char it will throw a series of exceptions\n        which are caught and cause appropriate values to be set for later.\n\n        This differs from C figlet which will just get bogus values from\n        memory and then discard them after.\n        \"\"\"\n        if (self.font.smushMode & (self.SM_SMUSH | self.SM_KERN)) == 0:\n            return 0\n\n        maxSmush = self.curCharWidth\n        for row in range(0, self.font.height):\n            lineLeft = buffer[row]\n            lineRight = curChar[row]\n            if self.direction == 'right-to-left':\n                lineLeft, lineRight = lineRight, lineLeft\n\n            # Only strip ascii space to match figlet exactly.\n            linebd = len(lineLeft.rstrip(' ')) - 1\n            if linebd < 0:\n                linebd = 0\n\n            if linebd < len(lineLeft):\n                ch1 = lineLeft[linebd]\n            else:\n                linebd = 0\n                ch1 = ''\n\n            # Only strip ascii space to match figlet exactly.\n            charbd = len(lineRight) - len(lineRight.lstrip(' '))\n            if charbd < len(lineRight):\n                ch2 = lineRight[charbd]\n            else:\n                charbd = len(lineRight)\n                ch2 = ''\n\n            amt = charbd + len(lineLeft) - 1 - linebd\n\n            if ch1 == '' or ch1 == ' ':\n                amt += 1\n            elif (ch2 != ''\n                    and self.smushChars(left=ch1, right=ch2) is not None):\n                amt += 1\n\n            if amt < maxSmush:\n                maxSmush = amt\n\n        return maxSmush\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.FigletBuilder.smushChars",
      "module": "pyfiglet",
      "signature": "(self, left='', right='')",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "left": {
          "default": "",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "right": {
          "default": "",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Given 2 characters which represent the edges rendered figlet\nfonts where they would touch, see if they can be smushed together.\nReturns None if this cannot or should not be done.",
      "source_code": "    def smushChars(self, left='', right=''):\n        \"\"\"\n        Given 2 characters which represent the edges rendered figlet\n        fonts where they would touch, see if they can be smushed together.\n        Returns None if this cannot or should not be done.\n        \"\"\"\n        # Don't use isspace because this also matches unicode chars that figlet\n        # treats as hard breaks\n        if left == ' ':\n            return right\n        if right == ' ':\n            return left\n\n        # Disallows overlapping if previous or current char has a width of 1 or\n        # zero\n        if (self.prevCharWidth < 2) or (self.curCharWidth < 2):\n            return\n\n        # kerning only\n        if (self.font.smushMode & self.SM_SMUSH) == 0:\n            return\n\n        # smushing by universal overlapping\n        if (self.font.smushMode & 63) == 0:\n            # Ensure preference to visiable characters.\n            if left == self.font.hardBlank:\n                return right\n            if right == self.font.hardBlank:\n                return left\n\n            # Ensures that the dominant (foreground)\n            # fig-character for overlapping is the latter in the\n            # user's text, not necessarily the rightmost character.\n            if self.direction == 'right-to-left':\n                return left\n            else:\n                return right\n\n        if self.font.smushMode & self.SM_HARDBLANK:\n            if (left == self.font.hardBlank\n                    and right == self.font.hardBlank):\n                return left\n\n        if (left == self.font.hardBlank\n                or right == self.font.hardBlank):\n            return\n\n        if self.font.smushMode & self.SM_EQUAL:\n            if left == right:\n                return left\n\n        smushes = ()\n\n        if self.font.smushMode & self.SM_LOWLINE:\n            smushes += (('_', r'|/\\[]{}()<>'),)\n\n        if self.font.smushMode & self.SM_HIERARCHY:\n            smushes += (\n                ('|', r'/\\[]{}()<>'),\n                (r'\\/', '[]{}()<>'),\n                ('[]', '{}()<>'),\n                ('{}', '()<>'),\n                ('()', '<>'),\n            )\n\n        for a, b in smushes:\n            if left in a and right in b:\n                return right\n            if right in a and left in b:\n                return left\n\n        if self.font.smushMode & self.SM_PAIR:\n            for pair in [left+right, right+left]:\n                if pair in ['[]', '{}', '()']:\n                    return '|'\n\n        if self.font.smushMode & self.SM_BIGX:\n            if (left == '/') and (right == '\\\\'):\n                return '|'\n            if (right == '/') and (left == '\\\\'):\n                return 'Y'\n            if (left == '>') and (right == '<'):\n                return 'X'\n        return\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.FigletBuilder.smushRow",
      "module": "pyfiglet",
      "signature": "(self, curChar, row)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "curChar": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "row": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def smushRow(self, curChar, row):\n        addLeft = self.buffer[row]\n        addRight = curChar[row]\n\n        if self.direction == 'right-to-left':\n            addLeft, addRight = addRight, addLeft\n\n        for i in range(0, self.maxSmush):\n            left, idx = self.getLeftSmushedChar(i, addLeft)\n            right = addRight[i]\n            smushed = self.smushChars(left=left, right=right)\n            addLeft = self.updateSmushedCharInLeftBuffer(addLeft, idx, smushed)\n        return addLeft, addRight\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.FigletBuilder.updateSmushedCharInLeftBuffer",
      "module": "pyfiglet",
      "signature": "(self, addLeft, idx, smushed)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "addLeft": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "idx": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "smushed": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def updateSmushedCharInLeftBuffer(self, addLeft, idx, smushed):\n        l = list(addLeft)\n        if idx < 0 or idx > len(l):\n            return addLeft\n        l[idx] = smushed\n        addLeft = ''.join(l)\n        return addLeft\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.FigletFont.installFonts",
      "module": "pyfiglet",
      "signature": "(file_name)",
      "parameters": {
        "file_name": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [
        "staticmethod"
      ],
      "examples": [],
      "docstring": "Install the specified font file to this system.",
      "source_code": "    @staticmethod\n    def installFonts(file_name):\n        \"\"\"\n        Install the specified font file to this system.\n        \"\"\"\n        if hasattr(importlib.resources.files('pyfiglet'), 'resolve'):\n            # Figlet looks like a standard directory - so lets use that to install new fonts.\n            location = str(importlib.resources.files('pyfiglet.fonts'))\n        else:\n            # Figlet is installed using a zipped resource - don't try to upload to it.\n            location = SHARED_DIRECTORY\n\n        print(\"Installing {} to {}\".format(file_name, location))\n\n        # Make sure the required destination directory exists\n        if not os.path.exists(location):\n            os.makedirs(location)\n\n        # Copy the font definitions - unpacking any zip files as needed.\n        if os.path.splitext(file_name)[1].lower() == \".zip\":\n            # Ignore any structure inside the ZIP file.\n            with zipfile.ZipFile(file_name) as zip_file:\n                for font in zip_file.namelist():\n                    font_file = os.path.basename(font)\n                    if not font_file:\n                        continue\n                    with zip_file.open(font) as src:\n                        with open(os.path.join(location, font_file), \"wb\") as dest:\n                            shutil.copyfileobj(src, dest)\n        else:\n            shutil.copy(file_name, location)\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.FigletFont.loadFont",
      "module": "pyfiglet",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Parse loaded font data for the rendering engine to consume",
      "source_code": "    def loadFont(self):\n        \"\"\"\n        Parse loaded font data for the rendering engine to consume\n        \"\"\"\n        try:\n            # Remove any unicode line splitting characters other\n            # than CRLF - to match figlet line parsing\n            data = re.sub(r\"[\\u0085\\u2028\\u2029]\", \" \", self.data)\n\n            # Parse first line of file, the header\n            data = data.splitlines()\n\n            header = data.pop(0)\n            if self.reMagicNumber.search(header) is None:\n                raise FontError('%s is not a valid figlet font' % self.font)\n\n            header = self.reMagicNumber.sub('', header)\n            header = header.split()\n\n            if len(header) < 6:\n                raise FontError('malformed header for %s' % self.font)\n\n            hardBlank = header[0]\n            height, baseLine, maxLength, oldLayout, commentLines = map(\n                int, header[1:6])\n            printDirection = fullLayout = None\n\n            # these are all optional for backwards compat\n            if len(header) > 6:\n                printDirection = int(header[6])\n            if len(header) > 7:\n                fullLayout = int(header[7])\n\n            # if the new layout style isn't available,\n            # convert old layout style. backwards compatibility\n            if fullLayout is None:\n                if oldLayout == 0:\n                    fullLayout = 64\n                elif oldLayout < 0:\n                    fullLayout = 0\n                else:\n                    fullLayout = (oldLayout & 31) | 128\n\n            # Some header information is stored for later, the rendering\n            # engine needs to know this stuff.\n            self.height = height\n            self.hardBlank = hardBlank\n            self.printDirection = printDirection\n            self.smushMode = fullLayout\n\n            # Strip out comment lines\n            for i in range(0, commentLines):\n                self.comment += data.pop(0)\n\n            def __char(data):\n                \"\"\"\n                Function loads one character in the internal array from font\n                file content\n                \"\"\"\n                end = None\n                width = 0\n                chars = []\n                for j in range(0, height):\n                    line = data.pop(0)\n                    if end is None:\n                        end = self.reEndMarker.search(line).group(1)\n                        end = re.compile(re.escape(end) + r'{1,2}\\s*$')\n\n                    line = end.sub('', line)\n\n                    if len(line) > width:\n                        width = len(line)\n                    chars.append(line)\n                return width, chars\n\n            # Load ASCII standard character set (32 - 127).\n            # Don't skip space definition as later rendering pipeline will\n            # ignore all missing chars and space is critical for the line\n            # breaking logic.\n            for i in range(32, 127):\n                width, letter = __char(data)\n                if i == 32 or ''.join(letter) != '':\n                    self.chars[i] = letter\n                    self.width[i] = width\n\n            # Load German Umlaute - the follow directly after standard character 127\n            if data:\n                for i in '\u00c4\u00d6\u00dc\u00e4\u00f6\u00fc\u00df':\n                    width, letter = __char(data)\n                    if ''.join(letter) != '':\n                        self.chars[ord(i)] = letter\n                        self.width[ord(i)] = width\n\n            # Load ASCII extended character set\n            while data:\n                line = data.pop(0).strip()\n                i = line.split(' ', 1)[0]\n                if (i == ''):\n                    continue\n                hex_match = re.search('^0x', i, re.IGNORECASE)\n                if hex_match is not None:\n                    i = int(i, 16)\n                    width, letter = __char(data)\n                    if ''.join(letter) != '':\n                        self.chars[i] = letter\n                        self.width[i] = width\n\n        except Exception as e:\n            raise FontError('problem parsing %s font: %s' % (self.font, e))\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.FigletProduct.append",
      "module": "pyfiglet",
      "signature": "(self, buffer)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "buffer": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def append(self, buffer):\n        self.queue.append(buffer)\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.FigletProduct.getString",
      "module": "pyfiglet",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def getString(self):\n        return FigletString(self.buffer_string)\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.FigletRenderingEngine.render",
      "module": "pyfiglet",
      "signature": "(self, text)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "text": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Render an ASCII text string in figlet",
      "source_code": "    def render(self, text):\n        \"\"\"\n        Render an ASCII text string in figlet\n        \"\"\"\n        builder = FigletBuilder(text,\n                                self.base.Font,\n                                self.base.direction,\n                                self.base.width,\n                                self.base.justify)\n\n        while builder.isNotFinished():\n            builder.addCharToProduct()\n            builder.goToNextChar()\n\n        return builder.returnProduct()\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.FigletString.flip",
      "module": "pyfiglet",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def flip(self):\n        out = []\n        for row in self.splitlines()[::-1]:\n            out.append(row.translate(self.__flip_map__))\n\n        return self.newFromList(out)\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.FigletString.newFromList",
      "module": "pyfiglet",
      "signature": "(self, list)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "list": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def newFromList(self, list):\n        return FigletString('\\n'.join(list) + '\\n')\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.FigletString.normalize_surrounding_newlines",
      "module": "pyfiglet",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def normalize_surrounding_newlines(self):\n        return '\\n' + self.strip_surrounding_newlines() + '\\n'\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.FigletString.reverse",
      "module": "pyfiglet",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def reverse(self):\n        out = []\n        for row in self.splitlines():\n            out.append(row.translate(self.__reverse_map__)[::-1])\n\n        return self.newFromList(out)\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.FigletString.strip_surrounding_newlines",
      "module": "pyfiglet",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def strip_surrounding_newlines(self):\n        out = []\n        chars_seen = False\n        for row in self.splitlines():\n            # if the row isn't empty or if we're in the middle of the font character, add the line.\n            if row.strip() != \"\" or chars_seen:\n                chars_seen = True\n                out.append(row)\n\n        # rstrip to get rid of the trailing newlines\n        return self.newFromList(out).rstrip()\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.OptionParser.add_option",
      "module": "pyfiglet",
      "signature": "(self, *args, **kwargs)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "add_option(Option)\nadd_option(opt_str, ..., kwarg=val, ...)",
      "source_code": "    def add_option(self, *args, **kwargs):\n        \"\"\"add_option(Option)\n           add_option(opt_str, ..., kwarg=val, ...)\n        \"\"\"\n        if isinstance(args[0], str):\n            option = self.option_class(*args, **kwargs)\n        elif len(args) == 1 and not kwargs:\n            option = args[0]\n            if not isinstance(option, Option):\n                raise TypeError(\"not an Option instance: %r\" % option)\n        else:\n            raise TypeError(\"invalid arguments\")\n\n        self._check_conflict(option)\n\n        self.option_list.append(option)\n        option.container = self\n        for opt in option._short_opts:\n            self._short_opt[opt] = option\n        for opt in option._long_opts:\n            self._long_opt[opt] = option\n\n        if option.dest is not None:     # option has a dest, we need a default\n            if option.default is not NO_DEFAULT:\n                self.defaults[option.dest] = option.default\n            elif option.dest not in self.defaults:\n                self.defaults[option.dest] = None\n\n        return option\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.OptionParser.add_option_group",
      "module": "pyfiglet",
      "signature": "(self, *args, **kwargs)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def add_option_group(self, *args, **kwargs):\n        # XXX lots of overlap with OptionContainer.add_option()\n        if isinstance(args[0], str):\n            group = OptionGroup(self, *args, **kwargs)\n        elif len(args) == 1 and not kwargs:\n            group = args[0]\n            if not isinstance(group, OptionGroup):\n                raise TypeError(\"not an OptionGroup instance: %r\" % group)\n            if group.parser is not self:\n                raise ValueError(\"invalid OptionGroup (wrong parser)\")\n        else:\n            raise TypeError(\"invalid arguments\")\n\n        self.option_groups.append(group)\n        return group\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.OptionParser.add_options",
      "module": "pyfiglet",
      "signature": "(self, option_list)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "option_list": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def add_options(self, option_list):\n        for option in option_list:\n            self.add_option(option)\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.OptionParser.check_values",
      "module": "pyfiglet",
      "signature": "(self, values, args)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "values": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "args": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "check_values(values : Values, args : [string])\n-> (values : Values, args : [string])\n\nCheck that the supplied option values and leftover arguments are\nvalid.  Returns the option values and leftover arguments\n(possibly adjusted, possibly completely new -- whatever you\nlike).  Default implementation just returns the passed-in\nvalues; subclasses may override as desired.",
      "source_code": "    def check_values(self, values, args):\n        \"\"\"\n        check_values(values : Values, args : [string])\n        -> (values : Values, args : [string])\n\n        Check that the supplied option values and leftover arguments are\n        valid.  Returns the option values and leftover arguments\n        (possibly adjusted, possibly completely new -- whatever you\n        like).  Default implementation just returns the passed-in\n        values; subclasses may override as desired.\n        \"\"\"\n        return (values, args)\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.OptionParser.destroy",
      "module": "pyfiglet",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Declare that you are done with this OptionParser.  This cleans up\nreference cycles so the OptionParser (and all objects referenced by\nit) can be garbage-collected promptly.  After calling destroy(), the\nOptionParser is unusable.",
      "source_code": "    def destroy(self):\n        \"\"\"\n        Declare that you are done with this OptionParser.  This cleans up\n        reference cycles so the OptionParser (and all objects referenced by\n        it) can be garbage-collected promptly.  After calling destroy(), the\n        OptionParser is unusable.\n        \"\"\"\n        OptionContainer.destroy(self)\n        for group in self.option_groups:\n            group.destroy()\n        del self.option_list\n        del self.option_groups\n        del self.formatter\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.OptionParser.disable_interspersed_args",
      "module": "pyfiglet",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Set parsing to stop on the first non-option. Use this if\nyou have a command processor which runs another command that\nhas options of its own and you want to make sure these options\ndon't get confused.",
      "source_code": "    def disable_interspersed_args(self):\n        \"\"\"Set parsing to stop on the first non-option. Use this if\n        you have a command processor which runs another command that\n        has options of its own and you want to make sure these options\n        don't get confused.\n        \"\"\"\n        self.allow_interspersed_args = False\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.OptionParser.enable_interspersed_args",
      "module": "pyfiglet",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Set parsing to not stop on the first non-option, allowing\ninterspersing switches with command arguments. This is the\ndefault behavior. See also disable_interspersed_args() and the\nclass documentation description of the attribute\nallow_interspersed_args.",
      "source_code": "    def enable_interspersed_args(self):\n        \"\"\"Set parsing to not stop on the first non-option, allowing\n        interspersing switches with command arguments. This is the\n        default behavior. See also disable_interspersed_args() and the\n        class documentation description of the attribute\n        allow_interspersed_args.\"\"\"\n        self.allow_interspersed_args = True\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.OptionParser.error",
      "module": "pyfiglet",
      "signature": "(self, msg)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "error(msg : string)\n\nPrint a usage message incorporating 'msg' to stderr and exit.\nIf you override this in a subclass, it should not return -- it\nshould either exit or raise an exception.",
      "source_code": "    def error(self, msg):\n        \"\"\"error(msg : string)\n\n        Print a usage message incorporating 'msg' to stderr and exit.\n        If you override this in a subclass, it should not return -- it\n        should either exit or raise an exception.\n        \"\"\"\n        self.print_usage(sys.stderr)\n        self.exit(2, \"%s: error: %s\\n\" % (self.get_prog_name(), msg))\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.OptionParser.exit",
      "module": "pyfiglet",
      "signature": "(self, status=0, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "status": {
          "default": "0",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def exit(self, status=0, msg=None):\n        if msg:\n            sys.stderr.write(msg)\n        sys.exit(status)\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.OptionParser.expand_prog_name",
      "module": "pyfiglet",
      "signature": "(self, s)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "s": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def expand_prog_name(self, s):\n        return s.replace(\"%prog\", self.get_prog_name())\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.OptionParser.format_description",
      "module": "pyfiglet",
      "signature": "(self, formatter)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "formatter": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def format_description(self, formatter):\n        return formatter.format_description(self.get_description())\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.OptionParser.format_epilog",
      "module": "pyfiglet",
      "signature": "(self, formatter)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "formatter": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def format_epilog(self, formatter):\n        return formatter.format_epilog(self.epilog)\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.OptionParser.format_help",
      "module": "pyfiglet",
      "signature": "(self, formatter=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "formatter": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def format_help(self, formatter=None):\n        if formatter is None:\n            formatter = self.formatter\n        result = []\n        if self.usage:\n            result.append(self.get_usage() + \"\\n\")\n        if self.description:\n            result.append(self.format_description(formatter) + \"\\n\")\n        result.append(self.format_option_help(formatter))\n        result.append(self.format_epilog(formatter))\n        return \"\".join(result)\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.OptionParser.format_option_help",
      "module": "pyfiglet",
      "signature": "(self, formatter=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "formatter": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def format_option_help(self, formatter=None):\n        if formatter is None:\n            formatter = self.formatter\n        formatter.store_option_strings(self)\n        result = []\n        result.append(formatter.format_heading(_(\"Options\")))\n        formatter.indent()\n        if self.option_list:\n            result.append(OptionContainer.format_option_help(self, formatter))\n            result.append(\"\\n\")\n        for group in self.option_groups:\n            result.append(group.format_help(formatter))\n            result.append(\"\\n\")\n        formatter.dedent()\n        # Drop the last \"\\n\", or the header if no options or option groups:\n        return \"\".join(result[:-1])\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.OptionParser.get_default_values",
      "module": "pyfiglet",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def get_default_values(self):\n        if not self.process_default_values:\n            # Old, pre-Optik 1.5 behaviour.\n            return Values(self.defaults)\n\n        defaults = self.defaults.copy()\n        for option in self._get_all_options():\n            default = defaults.get(option.dest)\n            if isinstance(default, str):\n                opt_str = option.get_opt_string()\n                defaults[option.dest] = option.check_value(opt_str, default)\n\n        return Values(defaults)\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.OptionParser.get_description",
      "module": "pyfiglet",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def get_description(self):\n        return self.expand_prog_name(self.description)\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.OptionParser.get_option",
      "module": "pyfiglet",
      "signature": "(self, opt_str)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "opt_str": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def get_option(self, opt_str):\n        return (self._short_opt.get(opt_str) or\n                self._long_opt.get(opt_str))\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.OptionParser.get_option_group",
      "module": "pyfiglet",
      "signature": "(self, opt_str)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "opt_str": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def get_option_group(self, opt_str):\n        option = (self._short_opt.get(opt_str) or\n                  self._long_opt.get(opt_str))\n        if option and option.container is not self:\n            return option.container\n        return None\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.OptionParser.get_prog_name",
      "module": "pyfiglet",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def get_prog_name(self):\n        if self.prog is None:\n            return os.path.basename(sys.argv[0])\n        else:\n            return self.prog\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.OptionParser.get_usage",
      "module": "pyfiglet",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def get_usage(self):\n        if self.usage:\n            return self.formatter.format_usage(\n                self.expand_prog_name(self.usage))\n        else:\n            return \"\"\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.OptionParser.get_version",
      "module": "pyfiglet",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def get_version(self):\n        if self.version:\n            return self.expand_prog_name(self.version)\n        else:\n            return \"\"\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.OptionParser.has_option",
      "module": "pyfiglet",
      "signature": "(self, opt_str)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "opt_str": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def has_option(self, opt_str):\n        return (opt_str in self._short_opt or\n                opt_str in self._long_opt)\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.OptionParser.parse_args",
      "module": "pyfiglet",
      "signature": "(self, args=None, values=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "args": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "values": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "parse_args(args : [string] = sys.argv[1:],\n           values : Values = None)\n-> (values : Values, args : [string])\n\nParse the command-line options found in 'args' (default:\nsys.argv[1:]).  Any errors result in a call to 'error()', which\nby default prints the usage message to stderr and calls\nsys.exit() with an error message.  On success returns a pair\n(values, args) where 'values' is a Values instance (with all\nyour option values) and 'args' is the list of arguments left\nover after parsing options.",
      "source_code": "    def parse_args(self, args=None, values=None):\n        \"\"\"\n        parse_args(args : [string] = sys.argv[1:],\n                   values : Values = None)\n        -> (values : Values, args : [string])\n\n        Parse the command-line options found in 'args' (default:\n        sys.argv[1:]).  Any errors result in a call to 'error()', which\n        by default prints the usage message to stderr and calls\n        sys.exit() with an error message.  On success returns a pair\n        (values, args) where 'values' is a Values instance (with all\n        your option values) and 'args' is the list of arguments left\n        over after parsing options.\n        \"\"\"\n        rargs = self._get_args(args)\n        if values is None:\n            values = self.get_default_values()\n\n        # Store the halves of the argument list as attributes for the\n        # convenience of callbacks:\n        #   rargs\n        #     the rest of the command-line (the \"r\" stands for\n        #     \"remaining\" or \"right-hand\")\n        #   largs\n        #     the leftover arguments -- ie. what's left after removing\n        #     options and their arguments (the \"l\" stands for \"leftover\"\n        #     or \"left-hand\")\n        self.rargs = rargs\n        self.largs = largs = []\n        self.values = values\n\n        try:\n            stop = self._process_args(largs, rargs, values)\n        except (BadOptionError, OptionValueError) as err:\n            self.error(str(err))\n\n        args = largs + rargs\n        return self.check_values(values, args)\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.OptionParser.print_help",
      "module": "pyfiglet",
      "signature": "(self, file=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "file": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "print_help(file : file = stdout)\n\nPrint an extended help message, listing all options and any\nhelp text provided with them, to 'file' (default stdout).",
      "source_code": "    def print_help(self, file=None):\n        \"\"\"print_help(file : file = stdout)\n\n        Print an extended help message, listing all options and any\n        help text provided with them, to 'file' (default stdout).\n        \"\"\"\n        if file is None:\n            file = sys.stdout\n        file.write(self.format_help())\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.OptionParser.print_usage",
      "module": "pyfiglet",
      "signature": "(self, file=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "file": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "print_usage(file : file = stdout)\n\nPrint the usage message for the current program (self.usage) to\n'file' (default stdout).  Any occurrence of the string \"%prog\" in\nself.usage is replaced with the name of the current program\n(basename of sys.argv[0]).  Does nothing if self.usage is empty\nor not defined.",
      "source_code": "    def print_usage(self, file=None):\n        \"\"\"print_usage(file : file = stdout)\n\n        Print the usage message for the current program (self.usage) to\n        'file' (default stdout).  Any occurrence of the string \"%prog\" in\n        self.usage is replaced with the name of the current program\n        (basename of sys.argv[0]).  Does nothing if self.usage is empty\n        or not defined.\n        \"\"\"\n        if self.usage:\n            print(self.get_usage(), file=file)\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.OptionParser.print_version",
      "module": "pyfiglet",
      "signature": "(self, file=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "file": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "print_version(file : file = stdout)\n\nPrint the version message for this program (self.version) to\n'file' (default stdout).  As with print_usage(), any occurrence\nof \"%prog\" in self.version is replaced by the current program's\nname.  Does nothing if self.version is empty or undefined.",
      "source_code": "    def print_version(self, file=None):\n        \"\"\"print_version(file : file = stdout)\n\n        Print the version message for this program (self.version) to\n        'file' (default stdout).  As with print_usage(), any occurrence\n        of \"%prog\" in self.version is replaced by the current program's\n        name.  Does nothing if self.version is empty or undefined.\n        \"\"\"\n        if self.version:\n            print(self.get_version(), file=file)\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.OptionParser.remove_option",
      "module": "pyfiglet",
      "signature": "(self, opt_str)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "opt_str": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def remove_option(self, opt_str):\n        option = self._short_opt.get(opt_str)\n        if option is None:\n            option = self._long_opt.get(opt_str)\n        if option is None:\n            raise ValueError(\"no such option %r\" % opt_str)\n\n        for opt in option._short_opts:\n            del self._short_opt[opt]\n        for opt in option._long_opts:\n            del self._long_opt[opt]\n        option.container.option_list.remove(option)\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.OptionParser.set_conflict_handler",
      "module": "pyfiglet",
      "signature": "(self, handler)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "handler": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def set_conflict_handler(self, handler):\n        if handler not in (\"error\", \"resolve\"):\n            raise ValueError(\"invalid conflict_resolution value %r\" % handler)\n        self.conflict_handler = handler\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.OptionParser.set_default",
      "module": "pyfiglet",
      "signature": "(self, dest, value)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "dest": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "value": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def set_default(self, dest, value):\n        self.defaults[dest] = value\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.OptionParser.set_defaults",
      "module": "pyfiglet",
      "signature": "(self, **kwargs)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def set_defaults(self, **kwargs):\n        self.defaults.update(kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.OptionParser.set_description",
      "module": "pyfiglet",
      "signature": "(self, description)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "description": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def set_description(self, description):\n        self.description = description\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.OptionParser.set_process_default_values",
      "module": "pyfiglet",
      "signature": "(self, process)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "process": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def set_process_default_values(self, process):\n        self.process_default_values = process\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.OptionParser.set_usage",
      "module": "pyfiglet",
      "signature": "(self, usage)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "usage": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def set_usage(self, usage):\n        if usage is None:\n            self.usage = _(\"%prog [options]\")\n        elif usage is SUPPRESS_USAGE:\n            self.usage = None\n        # For backwards compatibility with Optik 1.3 and earlier.\n        elif usage.lower().startswith(\"usage: \"):\n            self.usage = usage[7:]\n        else:\n            self.usage = usage\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.test.Figlet.getDirection",
      "module": "pyfiglet.test",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def getDirection(self):\n        if self._direction == 'auto':\n            direction = self.Font.printDirection\n            if direction == 0:\n                return 'left-to-right'\n            elif direction == 1:\n                return 'right-to-left'\n            else:\n                return 'left-to-right'\n\n        else:\n            return self._direction\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.test.Figlet.getFonts",
      "module": "pyfiglet.test",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def getFonts(self):\n        return self.Font.getFonts()\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.test.Figlet.getJustify",
      "module": "pyfiglet.test",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def getJustify(self):\n        if self._justify == 'auto':\n            if self.direction == 'left-to-right':\n                return 'left'\n            elif self.direction == 'right-to-left':\n                return 'right'\n\n        else:\n            return self._justify\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.test.Figlet.renderText",
      "module": "pyfiglet.test",
      "signature": "(self, text)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "text": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def renderText(self, text):\n        # wrapper method to engine\n        return self.engine.render(text)\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.test.Figlet.setFont",
      "module": "pyfiglet.test",
      "signature": "(self, **kwargs)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def setFont(self, **kwargs):\n        if 'font' in kwargs:\n            self.font = kwargs['font']\n\n        self.Font = FigletFont(font=self.font)\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.test.OptionParser.add_option",
      "module": "pyfiglet.test",
      "signature": "(self, *args, **kwargs)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "add_option(Option)\nadd_option(opt_str, ..., kwarg=val, ...)",
      "source_code": "    def add_option(self, *args, **kwargs):\n        \"\"\"add_option(Option)\n           add_option(opt_str, ..., kwarg=val, ...)\n        \"\"\"\n        if isinstance(args[0], str):\n            option = self.option_class(*args, **kwargs)\n        elif len(args) == 1 and not kwargs:\n            option = args[0]\n            if not isinstance(option, Option):\n                raise TypeError(\"not an Option instance: %r\" % option)\n        else:\n            raise TypeError(\"invalid arguments\")\n\n        self._check_conflict(option)\n\n        self.option_list.append(option)\n        option.container = self\n        for opt in option._short_opts:\n            self._short_opt[opt] = option\n        for opt in option._long_opts:\n            self._long_opt[opt] = option\n\n        if option.dest is not None:     # option has a dest, we need a default\n            if option.default is not NO_DEFAULT:\n                self.defaults[option.dest] = option.default\n            elif option.dest not in self.defaults:\n                self.defaults[option.dest] = None\n\n        return option\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.test.OptionParser.add_option_group",
      "module": "pyfiglet.test",
      "signature": "(self, *args, **kwargs)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def add_option_group(self, *args, **kwargs):\n        # XXX lots of overlap with OptionContainer.add_option()\n        if isinstance(args[0], str):\n            group = OptionGroup(self, *args, **kwargs)\n        elif len(args) == 1 and not kwargs:\n            group = args[0]\n            if not isinstance(group, OptionGroup):\n                raise TypeError(\"not an OptionGroup instance: %r\" % group)\n            if group.parser is not self:\n                raise ValueError(\"invalid OptionGroup (wrong parser)\")\n        else:\n            raise TypeError(\"invalid arguments\")\n\n        self.option_groups.append(group)\n        return group\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.test.OptionParser.add_options",
      "module": "pyfiglet.test",
      "signature": "(self, option_list)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "option_list": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def add_options(self, option_list):\n        for option in option_list:\n            self.add_option(option)\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.test.OptionParser.check_values",
      "module": "pyfiglet.test",
      "signature": "(self, values, args)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "values": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "args": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "check_values(values : Values, args : [string])\n-> (values : Values, args : [string])\n\nCheck that the supplied option values and leftover arguments are\nvalid.  Returns the option values and leftover arguments\n(possibly adjusted, possibly completely new -- whatever you\nlike).  Default implementation just returns the passed-in\nvalues; subclasses may override as desired.",
      "source_code": "    def check_values(self, values, args):\n        \"\"\"\n        check_values(values : Values, args : [string])\n        -> (values : Values, args : [string])\n\n        Check that the supplied option values and leftover arguments are\n        valid.  Returns the option values and leftover arguments\n        (possibly adjusted, possibly completely new -- whatever you\n        like).  Default implementation just returns the passed-in\n        values; subclasses may override as desired.\n        \"\"\"\n        return (values, args)\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.test.OptionParser.destroy",
      "module": "pyfiglet.test",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Declare that you are done with this OptionParser.  This cleans up\nreference cycles so the OptionParser (and all objects referenced by\nit) can be garbage-collected promptly.  After calling destroy(), the\nOptionParser is unusable.",
      "source_code": "    def destroy(self):\n        \"\"\"\n        Declare that you are done with this OptionParser.  This cleans up\n        reference cycles so the OptionParser (and all objects referenced by\n        it) can be garbage-collected promptly.  After calling destroy(), the\n        OptionParser is unusable.\n        \"\"\"\n        OptionContainer.destroy(self)\n        for group in self.option_groups:\n            group.destroy()\n        del self.option_list\n        del self.option_groups\n        del self.formatter\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.test.OptionParser.disable_interspersed_args",
      "module": "pyfiglet.test",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Set parsing to stop on the first non-option. Use this if\nyou have a command processor which runs another command that\nhas options of its own and you want to make sure these options\ndon't get confused.",
      "source_code": "    def disable_interspersed_args(self):\n        \"\"\"Set parsing to stop on the first non-option. Use this if\n        you have a command processor which runs another command that\n        has options of its own and you want to make sure these options\n        don't get confused.\n        \"\"\"\n        self.allow_interspersed_args = False\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.test.OptionParser.enable_interspersed_args",
      "module": "pyfiglet.test",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Set parsing to not stop on the first non-option, allowing\ninterspersing switches with command arguments. This is the\ndefault behavior. See also disable_interspersed_args() and the\nclass documentation description of the attribute\nallow_interspersed_args.",
      "source_code": "    def enable_interspersed_args(self):\n        \"\"\"Set parsing to not stop on the first non-option, allowing\n        interspersing switches with command arguments. This is the\n        default behavior. See also disable_interspersed_args() and the\n        class documentation description of the attribute\n        allow_interspersed_args.\"\"\"\n        self.allow_interspersed_args = True\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.test.OptionParser.error",
      "module": "pyfiglet.test",
      "signature": "(self, msg)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "error(msg : string)\n\nPrint a usage message incorporating 'msg' to stderr and exit.\nIf you override this in a subclass, it should not return -- it\nshould either exit or raise an exception.",
      "source_code": "    def error(self, msg):\n        \"\"\"error(msg : string)\n\n        Print a usage message incorporating 'msg' to stderr and exit.\n        If you override this in a subclass, it should not return -- it\n        should either exit or raise an exception.\n        \"\"\"\n        self.print_usage(sys.stderr)\n        self.exit(2, \"%s: error: %s\\n\" % (self.get_prog_name(), msg))\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.test.OptionParser.exit",
      "module": "pyfiglet.test",
      "signature": "(self, status=0, msg=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "status": {
          "default": "0",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "msg": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def exit(self, status=0, msg=None):\n        if msg:\n            sys.stderr.write(msg)\n        sys.exit(status)\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.test.OptionParser.expand_prog_name",
      "module": "pyfiglet.test",
      "signature": "(self, s)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "s": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def expand_prog_name(self, s):\n        return s.replace(\"%prog\", self.get_prog_name())\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.test.OptionParser.format_description",
      "module": "pyfiglet.test",
      "signature": "(self, formatter)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "formatter": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def format_description(self, formatter):\n        return formatter.format_description(self.get_description())\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.test.OptionParser.format_epilog",
      "module": "pyfiglet.test",
      "signature": "(self, formatter)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "formatter": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def format_epilog(self, formatter):\n        return formatter.format_epilog(self.epilog)\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.test.OptionParser.format_help",
      "module": "pyfiglet.test",
      "signature": "(self, formatter=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "formatter": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def format_help(self, formatter=None):\n        if formatter is None:\n            formatter = self.formatter\n        result = []\n        if self.usage:\n            result.append(self.get_usage() + \"\\n\")\n        if self.description:\n            result.append(self.format_description(formatter) + \"\\n\")\n        result.append(self.format_option_help(formatter))\n        result.append(self.format_epilog(formatter))\n        return \"\".join(result)\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.test.OptionParser.format_option_help",
      "module": "pyfiglet.test",
      "signature": "(self, formatter=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "formatter": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def format_option_help(self, formatter=None):\n        if formatter is None:\n            formatter = self.formatter\n        formatter.store_option_strings(self)\n        result = []\n        result.append(formatter.format_heading(_(\"Options\")))\n        formatter.indent()\n        if self.option_list:\n            result.append(OptionContainer.format_option_help(self, formatter))\n            result.append(\"\\n\")\n        for group in self.option_groups:\n            result.append(group.format_help(formatter))\n            result.append(\"\\n\")\n        formatter.dedent()\n        # Drop the last \"\\n\", or the header if no options or option groups:\n        return \"\".join(result[:-1])\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.test.OptionParser.get_default_values",
      "module": "pyfiglet.test",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def get_default_values(self):\n        if not self.process_default_values:\n            # Old, pre-Optik 1.5 behaviour.\n            return Values(self.defaults)\n\n        defaults = self.defaults.copy()\n        for option in self._get_all_options():\n            default = defaults.get(option.dest)\n            if isinstance(default, str):\n                opt_str = option.get_opt_string()\n                defaults[option.dest] = option.check_value(opt_str, default)\n\n        return Values(defaults)\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.test.OptionParser.get_description",
      "module": "pyfiglet.test",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def get_description(self):\n        return self.expand_prog_name(self.description)\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.test.OptionParser.get_option",
      "module": "pyfiglet.test",
      "signature": "(self, opt_str)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "opt_str": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def get_option(self, opt_str):\n        return (self._short_opt.get(opt_str) or\n                self._long_opt.get(opt_str))\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.test.OptionParser.get_option_group",
      "module": "pyfiglet.test",
      "signature": "(self, opt_str)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "opt_str": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def get_option_group(self, opt_str):\n        option = (self._short_opt.get(opt_str) or\n                  self._long_opt.get(opt_str))\n        if option and option.container is not self:\n            return option.container\n        return None\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.test.OptionParser.get_prog_name",
      "module": "pyfiglet.test",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def get_prog_name(self):\n        if self.prog is None:\n            return os.path.basename(sys.argv[0])\n        else:\n            return self.prog\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.test.OptionParser.get_usage",
      "module": "pyfiglet.test",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def get_usage(self):\n        if self.usage:\n            return self.formatter.format_usage(\n                self.expand_prog_name(self.usage))\n        else:\n            return \"\"\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.test.OptionParser.get_version",
      "module": "pyfiglet.test",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def get_version(self):\n        if self.version:\n            return self.expand_prog_name(self.version)\n        else:\n            return \"\"\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.test.OptionParser.has_option",
      "module": "pyfiglet.test",
      "signature": "(self, opt_str)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "opt_str": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def has_option(self, opt_str):\n        return (opt_str in self._short_opt or\n                opt_str in self._long_opt)\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.test.OptionParser.parse_args",
      "module": "pyfiglet.test",
      "signature": "(self, args=None, values=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "args": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "values": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "parse_args(args : [string] = sys.argv[1:],\n           values : Values = None)\n-> (values : Values, args : [string])\n\nParse the command-line options found in 'args' (default:\nsys.argv[1:]).  Any errors result in a call to 'error()', which\nby default prints the usage message to stderr and calls\nsys.exit() with an error message.  On success returns a pair\n(values, args) where 'values' is a Values instance (with all\nyour option values) and 'args' is the list of arguments left\nover after parsing options.",
      "source_code": "    def parse_args(self, args=None, values=None):\n        \"\"\"\n        parse_args(args : [string] = sys.argv[1:],\n                   values : Values = None)\n        -> (values : Values, args : [string])\n\n        Parse the command-line options found in 'args' (default:\n        sys.argv[1:]).  Any errors result in a call to 'error()', which\n        by default prints the usage message to stderr and calls\n        sys.exit() with an error message.  On success returns a pair\n        (values, args) where 'values' is a Values instance (with all\n        your option values) and 'args' is the list of arguments left\n        over after parsing options.\n        \"\"\"\n        rargs = self._get_args(args)\n        if values is None:\n            values = self.get_default_values()\n\n        # Store the halves of the argument list as attributes for the\n        # convenience of callbacks:\n        #   rargs\n        #     the rest of the command-line (the \"r\" stands for\n        #     \"remaining\" or \"right-hand\")\n        #   largs\n        #     the leftover arguments -- ie. what's left after removing\n        #     options and their arguments (the \"l\" stands for \"leftover\"\n        #     or \"left-hand\")\n        self.rargs = rargs\n        self.largs = largs = []\n        self.values = values\n\n        try:\n            stop = self._process_args(largs, rargs, values)\n        except (BadOptionError, OptionValueError) as err:\n            self.error(str(err))\n\n        args = largs + rargs\n        return self.check_values(values, args)\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.test.OptionParser.print_help",
      "module": "pyfiglet.test",
      "signature": "(self, file=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "file": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "print_help(file : file = stdout)\n\nPrint an extended help message, listing all options and any\nhelp text provided with them, to 'file' (default stdout).",
      "source_code": "    def print_help(self, file=None):\n        \"\"\"print_help(file : file = stdout)\n\n        Print an extended help message, listing all options and any\n        help text provided with them, to 'file' (default stdout).\n        \"\"\"\n        if file is None:\n            file = sys.stdout\n        file.write(self.format_help())\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.test.OptionParser.print_usage",
      "module": "pyfiglet.test",
      "signature": "(self, file=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "file": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "print_usage(file : file = stdout)\n\nPrint the usage message for the current program (self.usage) to\n'file' (default stdout).  Any occurrence of the string \"%prog\" in\nself.usage is replaced with the name of the current program\n(basename of sys.argv[0]).  Does nothing if self.usage is empty\nor not defined.",
      "source_code": "    def print_usage(self, file=None):\n        \"\"\"print_usage(file : file = stdout)\n\n        Print the usage message for the current program (self.usage) to\n        'file' (default stdout).  Any occurrence of the string \"%prog\" in\n        self.usage is replaced with the name of the current program\n        (basename of sys.argv[0]).  Does nothing if self.usage is empty\n        or not defined.\n        \"\"\"\n        if self.usage:\n            print(self.get_usage(), file=file)\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.test.OptionParser.print_version",
      "module": "pyfiglet.test",
      "signature": "(self, file=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "file": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "print_version(file : file = stdout)\n\nPrint the version message for this program (self.version) to\n'file' (default stdout).  As with print_usage(), any occurrence\nof \"%prog\" in self.version is replaced by the current program's\nname.  Does nothing if self.version is empty or undefined.",
      "source_code": "    def print_version(self, file=None):\n        \"\"\"print_version(file : file = stdout)\n\n        Print the version message for this program (self.version) to\n        'file' (default stdout).  As with print_usage(), any occurrence\n        of \"%prog\" in self.version is replaced by the current program's\n        name.  Does nothing if self.version is empty or undefined.\n        \"\"\"\n        if self.version:\n            print(self.get_version(), file=file)\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.test.OptionParser.remove_option",
      "module": "pyfiglet.test",
      "signature": "(self, opt_str)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "opt_str": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def remove_option(self, opt_str):\n        option = self._short_opt.get(opt_str)\n        if option is None:\n            option = self._long_opt.get(opt_str)\n        if option is None:\n            raise ValueError(\"no such option %r\" % opt_str)\n\n        for opt in option._short_opts:\n            del self._short_opt[opt]\n        for opt in option._long_opts:\n            del self._long_opt[opt]\n        option.container.option_list.remove(option)\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.test.OptionParser.set_conflict_handler",
      "module": "pyfiglet.test",
      "signature": "(self, handler)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "handler": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def set_conflict_handler(self, handler):\n        if handler not in (\"error\", \"resolve\"):\n            raise ValueError(\"invalid conflict_resolution value %r\" % handler)\n        self.conflict_handler = handler\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.test.OptionParser.set_default",
      "module": "pyfiglet.test",
      "signature": "(self, dest, value)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "dest": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "value": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def set_default(self, dest, value):\n        self.defaults[dest] = value\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.test.OptionParser.set_defaults",
      "module": "pyfiglet.test",
      "signature": "(self, **kwargs)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def set_defaults(self, **kwargs):\n        self.defaults.update(kwargs)\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.test.OptionParser.set_description",
      "module": "pyfiglet.test",
      "signature": "(self, description)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "description": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def set_description(self, description):\n        self.description = description\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.test.OptionParser.set_process_default_values",
      "module": "pyfiglet.test",
      "signature": "(self, process)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "process": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def set_process_default_values(self, process):\n        self.process_default_values = process\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.test.OptionParser.set_usage",
      "module": "pyfiglet.test",
      "signature": "(self, usage)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "usage": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def set_usage(self, usage):\n        if usage is None:\n            self.usage = _(\"%prog [options]\")\n        elif usage is SUPPRESS_USAGE:\n            self.usage = None\n        # For backwards compatibility with Optik 1.3 and earlier.\n        elif usage.lower().startswith(\"usage: \"):\n            self.usage = usage[7:]\n        else:\n            self.usage = usage\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.test.Popen.communicate",
      "module": "pyfiglet.test",
      "signature": "(self, input=None, timeout=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "input": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "timeout": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Interact with process: Send data to stdin and close it.\nRead data from stdout and stderr, until end-of-file is\nreached.  Wait for process to terminate.\n\nThe optional \"input\" argument should be data to be sent to the\nchild process, or None, if no data should be sent to the child.\ncommunicate() returns a tuple (stdout, stderr).\n\nBy default, all communication is in bytes, and therefore any\n\"input\" should be bytes, and the (stdout, stderr) will be bytes.\nIf in text mode (indicated by self.text_mode), any \"input\" should\nbe a string, and (stdout, stderr) will be strings decoded\naccording to locale encoding, or by \"encoding\" if set. Text mode\nis triggered by setting any of text, encoding, errors or\nuniversal_newlines.",
      "source_code": "    def communicate(self, input=None, timeout=None):\n        \"\"\"Interact with process: Send data to stdin and close it.\n        Read data from stdout and stderr, until end-of-file is\n        reached.  Wait for process to terminate.\n\n        The optional \"input\" argument should be data to be sent to the\n        child process, or None, if no data should be sent to the child.\n        communicate() returns a tuple (stdout, stderr).\n\n        By default, all communication is in bytes, and therefore any\n        \"input\" should be bytes, and the (stdout, stderr) will be bytes.\n        If in text mode (indicated by self.text_mode), any \"input\" should\n        be a string, and (stdout, stderr) will be strings decoded\n        according to locale encoding, or by \"encoding\" if set. Text mode\n        is triggered by setting any of text, encoding, errors or\n        universal_newlines.\n        \"\"\"\n\n        if self._communication_started and input:\n            raise ValueError(\"Cannot send input after starting communication\")\n\n        # Optimization: If we are not worried about timeouts, we haven't\n        # started communicating, and we have one or zero pipes, using select()\n        # or threads is unnecessary.\n        if (timeout is None and not self._communication_started and\n            [self.stdin, self.stdout, self.stderr].count(None) >= 2):\n            stdout = None\n            stderr = None\n            if self.stdin:\n                self._stdin_write(input)\n            elif self.stdout:\n                stdout = self.stdout.read()\n                self.stdout.close()\n            elif self.stderr:\n                stderr = self.stderr.read()\n                self.stderr.close()\n            self.wait()\n        else:\n            if timeout is not None:\n                endtime = _time() + timeout\n            else:\n                endtime = None\n\n            try:\n                stdout, stderr = self._communicate(input, endtime, timeout)\n            except KeyboardInterrupt:\n                # https://bugs.python.org/issue25942\n                # See the detailed comment in .wait().\n                if timeout is not None:\n                    sigint_timeout = min(self._sigint_wait_secs,\n                                         self._remaining_time(endtime))\n                else:\n                    sigint_timeout = self._sigint_wait_secs\n                self._sigint_wait_secs = 0  # nothing else should wait.\n                try:\n                    self._wait(timeout=sigint_timeout)\n                except TimeoutExpired:\n                    pass\n                raise  # resume the KeyboardInterrupt\n\n            finally:\n                self._communication_started = True\n\n            sts = self.wait(timeout=self._remaining_time(endtime))\n\n        return (stdout, stderr)\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.test.Popen.kill",
      "module": "pyfiglet.test",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Kill the process with SIGKILL\n            ",
      "source_code": "        def kill(self):\n            \"\"\"Kill the process with SIGKILL\n            \"\"\"\n            self.send_signal(signal.SIGKILL)\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.test.Popen.poll",
      "module": "pyfiglet.test",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Check if child process has terminated. Set and return returncode\nattribute.",
      "source_code": "    def poll(self):\n        \"\"\"Check if child process has terminated. Set and return returncode\n        attribute.\"\"\"\n        return self._internal_poll()\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.test.Popen.send_signal",
      "module": "pyfiglet.test",
      "signature": "(self, sig)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "sig": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Send a signal to the process.",
      "source_code": "        def send_signal(self, sig):\n            \"\"\"Send a signal to the process.\"\"\"\n            # bpo-38630: Polling reduces the risk of sending a signal to the\n            # wrong process if the process completed, the Popen.returncode\n            # attribute is still None, and the pid has been reassigned\n            # (recycled) to a new different process. This race condition can\n            # happens in two cases.\n            #\n            # Case 1. Thread A calls Popen.poll(), thread B calls\n            # Popen.send_signal(). In thread A, waitpid() succeed and returns\n            # the exit status. Thread B calls kill() because poll() in thread A\n            # did not set returncode yet. Calling poll() in thread B prevents\n            # the race condition thanks to Popen._waitpid_lock.\n            #\n            # Case 2. waitpid(pid, 0) has been called directly, without\n            # using Popen methods: returncode is still None is this case.\n            # Calling Popen.poll() will set returncode to a default value,\n            # since waitpid() fails with ProcessLookupError.\n            self.poll()\n            if self.returncode is not None:\n                # Skip signalling a process that we know has already died.\n                return\n\n            # The race condition can still happen if the race condition\n            # described above happens between the returncode test\n            # and the kill() call.\n            try:\n                os.kill(self.pid, sig)\n            except ProcessLookupError:\n                # Suppress the race condition error; bpo-40550.\n                pass\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.test.Popen.terminate",
      "module": "pyfiglet.test",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Terminate the process with SIGTERM\n            ",
      "source_code": "        def terminate(self):\n            \"\"\"Terminate the process with SIGTERM\n            \"\"\"\n            self.send_signal(signal.SIGTERM)\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.test.Popen.wait",
      "module": "pyfiglet.test",
      "signature": "(self, timeout=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "timeout": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Wait for child process to terminate; returns self.returncode.",
      "source_code": "    def wait(self, timeout=None):\n        \"\"\"Wait for child process to terminate; returns self.returncode.\"\"\"\n        if timeout is not None:\n            endtime = _time() + timeout\n        try:\n            return self._wait(timeout=timeout)\n        except KeyboardInterrupt:\n            # https://bugs.python.org/issue25942\n            # The first keyboard interrupt waits briefly for the child to\n            # exit under the common assumption that it also received the ^C\n            # generated SIGINT and will exit rapidly.\n            if timeout is not None:\n                sigint_timeout = min(self._sigint_wait_secs,\n                                     self._remaining_time(endtime))\n            else:\n                sigint_timeout = self._sigint_wait_secs\n            self._sigint_wait_secs = 0  # nothing else should wait.\n            try:\n                self._wait(timeout=sigint_timeout)\n            except TimeoutExpired:\n                pass\n            raise  # resume the KeyboardInterrupt\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.test.Test.check_font",
      "module": "pyfiglet.test",
      "signature": "(self, text, font, use_tlf)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "text": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "font": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "use_tlf": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def check_font(self, text, font, use_tlf):\n        # Skip flagged bad fonts\n        if font in self.skip:\n            return\n\n        # Our TLF rendering isn't perfect, yet\n        fontpath = os.path.join('pyfiglet', 'fonts', font)\n        fig_file = os.path.isfile(fontpath + '.flf')\n        if not use_tlf and not fig_file:\n            return\n\n        self.f.setFont(font=font)\n        outputPyfiglet = self.f.renderText(text)\n        outputFiglet = self.outputUsingFigletorToilet(text, font, fontpath)\n        self.validate_font_output(font, outputFiglet, outputPyfiglet)\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.test.Test.check_result",
      "module": "pyfiglet.test",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def check_result(self):\n        print('OK = %d, FAIL = %d' % (self.ok, self.fail))\n        if len(self.failed) > 0:\n            print('FAILED = %s' % set(self.failed))\n\n        return self.failed, self.oked\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.test.Test.check_text",
      "module": "pyfiglet.test",
      "signature": "(self, text, use_tlf)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "text": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "use_tlf": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def check_text(self, text, use_tlf):\n        for font in self.f.getFonts():\n            self.check_font(text, font, use_tlf)\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.test.Test.outputUsingFigletorToilet",
      "module": "pyfiglet.test",
      "signature": "(self, text, font, fontpath)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "text": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "font": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "fontpath": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def outputUsingFigletorToilet(self, text, font, fontpath):\n        if os.path.isfile(fontpath + '.flf'):\n            cmd = ('figlet', '-d', 'pyfiglet/fonts', '-f', font, text)\n        elif os.path.isfile(fontpath + '.tlf'):\n            cmd = ('toilet', '-d', 'pyfiglet/fonts', '-f', font, text)\n        else:\n            raise Exception('Missing font file: {}'.format(fontpath))\n\n        p = Popen(cmd, bufsize=4096, stdout=PIPE)\n        try:\n            outputFiglet = p.communicate()[0].decode('utf8')\n        except UnicodeDecodeError as e:\n            print(\"Unicode Error handling font {}\".format(font))\n            outputFiglet = ''\n        return outputFiglet\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.test.Test.show_result",
      "module": "pyfiglet.test",
      "signature": "(self, outputFiglet, outputPyfiglet, font)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "outputFiglet": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "outputPyfiglet": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "font": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def show_result(self, outputFiglet, outputPyfiglet, font):\n        if self.opts.show is True:\n            print('[PYTHON] *** %s\\n\\n' % font)\n            dump(outputPyfiglet)\n            print('[FIGLET] *** %s\\n\\n' % font)\n            dump(outputFiglet)\n            input()\n"
    },
    {
      "type": "method",
      "qualified_name": "pyfiglet.test.Test.validate_font_output",
      "module": "pyfiglet.test",
      "signature": "(self, font, outputFiglet, outputPyfiglet)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "font": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "outputFiglet": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "outputPyfiglet": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "    def validate_font_output(self, font, outputFiglet, outputPyfiglet):\n        if outputPyfiglet == outputFiglet:\n            win('[OK] %s' % font)\n            self.ok += 1\n            self.oked.append(font)\n            return\n\n        fail('[FAIL] %s' % font)\n        self.fail += 1\n        self.failed.append(font)\n        self.show_result(outputFiglet, outputPyfiglet, font)\n"
    }
  ]
}