{
  "pytz": [
    {
      "type": "function",
      "qualified_name": "pytz.FixedOffset",
      "module": "pytz",
      "signature": "(offset, _tzinfos={})",
      "parameters": {
        "offset": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "_tzinfos": {
          "default": "{}",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [
        ">>> one = FixedOffset(-330)",
        ">>> one",
        ">>> str(one.utcoffset(datetime.datetime.now()))",
        ">>> str(one.dst(datetime.datetime.now()))",
        ">>> two = FixedOffset(1380)",
        ">>> two",
        ">>> str(two.utcoffset(datetime.datetime.now()))",
        ">>> str(two.dst(datetime.datetime.now()))",
        ">>> FixedOffset(1440)",
        ">>> FixedOffset(-1440)",
        ">>> FixedOffset(0) is UTC",
        ">>> FixedOffset(-330) is one",
        ">>> FixedOffset(1380) is two",
        ">>> import pickle",
        ">>> pickle.loads(pickle.dumps(one)) is one",
        ">>> pickle.loads(pickle.dumps(two)) is two"
      ],
      "docstring": "return a fixed-offset timezone based off a number of minutes.\n\n    >>> one = FixedOffset(-330)\n    >>> one\n    pytz.FixedOffset(-330)\n    >>> str(one.utcoffset(datetime.datetime.now()))\n    '-1 day, 18:30:00'\n    >>> str(one.dst(datetime.datetime.now()))\n    '0:00:00'\n\n    >>> two = FixedOffset(1380)\n    >>> two\n    pytz.FixedOffset(1380)\n    >>> str(two.utcoffset(datetime.datetime.now()))\n    '23:00:00'\n    >>> str(two.dst(datetime.datetime.now()))\n    '0:00:00'\n\nThe datetime.timedelta must be between the range of -1 and 1 day,\nnon-inclusive.\n\n    >>> FixedOffset(1440)\n    Traceback (most recent call last):\n    ...\n    ValueError: ('absolute offset is too large', 1440)\n\n    >>> FixedOffset(-1440)\n    Traceback (most recent call last):\n    ...\n    ValueError: ('absolute offset is too large', -1440)\n\nAn offset of 0 is special-cased to return UTC.\n\n    >>> FixedOffset(0) is UTC\n    True\n\nThere should always be only one instance of a FixedOffset per timedelta.\nThis should be true for multiple creation calls.\n\n    >>> FixedOffset(-330) is one\n    True\n    >>> FixedOffset(1380) is two\n    True\n\nIt should also be true for pickling.\n\n    >>> import pickle\n    >>> pickle.loads(pickle.dumps(one)) is one\n    True\n    >>> pickle.loads(pickle.dumps(two)) is two\n    True",
      "source_code": "def FixedOffset(offset, _tzinfos={}):\n    \"\"\"return a fixed-offset timezone based off a number of minutes.\n\n        >>> one = FixedOffset(-330)\n        >>> one\n        pytz.FixedOffset(-330)\n        >>> str(one.utcoffset(datetime.datetime.now()))\n        '-1 day, 18:30:00'\n        >>> str(one.dst(datetime.datetime.now()))\n        '0:00:00'\n\n        >>> two = FixedOffset(1380)\n        >>> two\n        pytz.FixedOffset(1380)\n        >>> str(two.utcoffset(datetime.datetime.now()))\n        '23:00:00'\n        >>> str(two.dst(datetime.datetime.now()))\n        '0:00:00'\n\n    The datetime.timedelta must be between the range of -1 and 1 day,\n    non-inclusive.\n\n        >>> FixedOffset(1440)\n        Traceback (most recent call last):\n        ...\n        ValueError: ('absolute offset is too large', 1440)\n\n        >>> FixedOffset(-1440)\n        Traceback (most recent call last):\n        ...\n        ValueError: ('absolute offset is too large', -1440)\n\n    An offset of 0 is special-cased to return UTC.\n\n        >>> FixedOffset(0) is UTC\n        True\n\n    There should always be only one instance of a FixedOffset per timedelta.\n    This should be true for multiple creation calls.\n\n        >>> FixedOffset(-330) is one\n        True\n        >>> FixedOffset(1380) is two\n        True\n\n    It should also be true for pickling.\n\n        >>> import pickle\n        >>> pickle.loads(pickle.dumps(one)) is one\n        True\n        >>> pickle.loads(pickle.dumps(two)) is two\n        True\n    \"\"\"\n    if offset == 0:\n        return UTC\n\n    info = _tzinfos.get(offset)\n    if info is None:\n        # We haven't seen this one before. we need to save it.\n\n        # Use setdefault to avoid a race condition and make sure we have\n        # only one\n        info = _tzinfos.setdefault(offset, _FixedOffset(offset))\n\n    return info\n"
    },
    {
      "type": "function",
      "qualified_name": "pytz.ascii",
      "module": "pytz",
      "signature": "(s)",
      "parameters": {
        "s": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [
        ">>> ascii('Hello')",
        ">>> ascii('\\N{TRADE MARK SIGN}') #doctest: +IGNORE_EXCEPTION_DETAIL"
      ],
      "docstring": ">>> ascii('Hello')\n'Hello'\n>>> ascii('\\N{TRADE MARK SIGN}') #doctest: +IGNORE_EXCEPTION_DETAIL\nTraceback (most recent call last):\n    ...\nUnicodeEncodeError: ...",
      "source_code": "    def ascii(s):\n        r\"\"\"\n        >>> ascii('Hello')\n        'Hello'\n        >>> ascii('\\N{TRADE MARK SIGN}') #doctest: +IGNORE_EXCEPTION_DETAIL\n        Traceback (most recent call last):\n            ...\n        UnicodeEncodeError: ...\n        \"\"\"\n        if type(s) == bytes:\n            s = s.decode('ASCII')\n        else:\n            s.encode('ASCII')  # Raise an exception if not ASCII\n        return s  # But the string - not a byte string.\n"
    },
    {
      "type": "function",
      "qualified_name": "pytz.build_tzinfo",
      "module": "pytz",
      "signature": "(zone, fp)",
      "parameters": {
        "zone": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "fp": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "def build_tzinfo(zone, fp):\n    head_fmt = '>4s c 15x 6l'\n    head_size = calcsize(head_fmt)\n    (magic, format, ttisgmtcnt, ttisstdcnt, leapcnt, timecnt,\n        typecnt, charcnt) = unpack(head_fmt, fp.read(head_size))\n\n    # Make sure it is a tzfile(5) file\n    assert magic == _byte_string('TZif'), 'Got magic %s' % repr(magic)\n\n    # Read out the transition times, localtime indices and ttinfo structures.\n    data_fmt = '>%(timecnt)dl %(timecnt)dB %(ttinfo)s %(charcnt)ds' % dict(\n        timecnt=timecnt, ttinfo='lBB' * typecnt, charcnt=charcnt)\n    data_size = calcsize(data_fmt)\n    data = unpack(data_fmt, fp.read(data_size))\n\n    # make sure we unpacked the right number of values\n    assert len(data) == 2 * timecnt + 3 * typecnt + 1\n    transitions = [memorized_datetime(trans)\n                   for trans in data[:timecnt]]\n    lindexes = list(data[timecnt:2 * timecnt])\n    ttinfo_raw = data[2 * timecnt:-1]\n    tznames_raw = data[-1]\n    del data\n\n    # Process ttinfo into separate structs\n    ttinfo = []\n    tznames = {}\n    i = 0\n    while i < len(ttinfo_raw):\n        # have we looked up this timezone name yet?\n        tzname_offset = ttinfo_raw[i + 2]\n        if tzname_offset not in tznames:\n            nul = tznames_raw.find(_NULL, tzname_offset)\n            if nul < 0:\n                nul = len(tznames_raw)\n            tznames[tzname_offset] = _std_string(\n                tznames_raw[tzname_offset:nul])\n        ttinfo.append((ttinfo_raw[i],\n                       bool(ttinfo_raw[i + 1]),\n                       tznames[tzname_offset]))\n        i += 3\n\n    # Now build the timezone object\n    if len(ttinfo) == 1 or len(transitions) == 0:\n        ttinfo[0][0], ttinfo[0][2]\n        cls = type(zone, (StaticTzInfo,), dict(\n            zone=zone,\n            _utcoffset=memorized_timedelta(ttinfo[0][0]),\n            _tzname=ttinfo[0][2]))\n    else:\n        # Early dates use the first standard time ttinfo\n        i = 0\n        while ttinfo[i][1]:\n            i += 1\n        if ttinfo[i] == ttinfo[lindexes[0]]:\n            transitions[0] = datetime.min\n        else:\n            transitions.insert(0, datetime.min)\n            lindexes.insert(0, i)\n\n        # calculate transition info\n        transition_info = []\n        for i in range(len(transitions)):\n            inf = ttinfo[lindexes[i]]\n            utcoffset = inf[0]\n            if not inf[1]:\n                dst = 0\n            else:\n                for j in range(i - 1, -1, -1):\n                    prev_inf = ttinfo[lindexes[j]]\n                    if not prev_inf[1]:\n                        break\n                dst = inf[0] - prev_inf[0]  # dst offset\n\n                # Bad dst? Look further. DST > 24 hours happens when\n                # a timzone has moved across the international dateline.\n                if dst <= 0 or dst > 3600 * 3:\n                    for j in range(i + 1, len(transitions)):\n                        stdinf = ttinfo[lindexes[j]]\n                        if not stdinf[1]:\n                            dst = inf[0] - stdinf[0]\n                            if dst > 0:\n                                break  # Found a useful std time.\n\n            tzname = inf[2]\n\n            # Round utcoffset and dst to the nearest minute or the\n            # datetime library will complain. Conversions to these timezones\n            # might be up to plus or minus 30 seconds out, but it is\n            # the best we can do.\n            utcoffset = int((utcoffset + 30) // 60) * 60\n            dst = int((dst + 30) // 60) * 60\n            transition_info.append(memorized_ttinfo(utcoffset, dst, tzname))\n\n        cls = type(zone, (DstTzInfo,), dict(\n            zone=zone,\n            _utc_transition_times=transitions,\n            _transition_info=transition_info))\n\n    return cls()\n"
    },
    {
      "type": "function",
      "qualified_name": "pytz.open_resource",
      "module": "pytz",
      "signature": "(name)",
      "parameters": {
        "name": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Open a resource from the zoneinfo subdir for reading.\n\nUses the pkg_resources module if available and no standard file\nfound at the calculated location.\n\nIt is possible to specify different location for zoneinfo\nsubdir by using the PYTZ_TZDATADIR environment variable.",
      "source_code": "def open_resource(name):\n    \"\"\"Open a resource from the zoneinfo subdir for reading.\n\n    Uses the pkg_resources module if available and no standard file\n    found at the calculated location.\n\n    It is possible to specify different location for zoneinfo\n    subdir by using the PYTZ_TZDATADIR environment variable.\n    \"\"\"\n    name_parts = name.lstrip('/').split('/')\n    for part in name_parts:\n        if part == os.path.pardir or os.sep in part:\n            raise ValueError('Bad path segment: %r' % part)\n    zoneinfo_dir = os.environ.get('PYTZ_TZDATADIR', None)\n    if zoneinfo_dir is not None:\n        filename = os.path.join(zoneinfo_dir, *name_parts)\n    else:\n        filename = os.path.join(os.path.dirname(__file__),\n                                'zoneinfo', *name_parts)\n        if not os.path.exists(filename):\n            # http://bugs.launchpad.net/bugs/383171 - we avoid using this\n            # unless absolutely necessary to help when a broken version of\n            # pkg_resources is installed.\n            try:\n                from pkg_resources import resource_stream\n            except ImportError:\n                resource_stream = None\n\n            if resource_stream is not None:\n                return resource_stream(__name__, 'zoneinfo/' + name)\n    return open(filename, 'rb')\n"
    },
    {
      "type": "function",
      "qualified_name": "pytz.resource_exists",
      "module": "pytz",
      "signature": "(name)",
      "parameters": {
        "name": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Return true if the given resource exists",
      "source_code": "def resource_exists(name):\n    \"\"\"Return true if the given resource exists\"\"\"\n    try:\n        if os.environ.get('PYTZ_SKIPEXISTSCHECK', ''):\n            # In \"standard\" distributions, we can assume that\n            # all the listed timezones are present. As an\n            # import-speed optimization, you can set the\n            # PYTZ_SKIPEXISTSCHECK flag to skip checking\n            # for the presence of the resource file on disk.\n            return True\n        open_resource(name).close()\n        return True\n    except IOError:\n        return False\n"
    },
    {
      "type": "function",
      "qualified_name": "pytz.timezone",
      "module": "pytz",
      "signature": "(zone)",
      "parameters": {
        "zone": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [
        ">>> from datetime import datetime, timedelta",
        ">>> utc = timezone('UTC')",
        ">>> eastern = timezone('US/Eastern')",
        ">>> eastern.zone",
        ">>> timezone(unicode('US/Eastern')) is eastern",
        ">>> utc_dt = datetime(2002, 10, 27, 6, 0, 0, tzinfo=utc)",
        ">>> loc_dt = utc_dt.astimezone(eastern)",
        ">>> fmt = '%Y-%m-%d %H:%M:%S %Z (%z)'",
        ">>> loc_dt.strftime(fmt)",
        ">>> (loc_dt - timedelta(minutes=10)).strftime(fmt)",
        ">>> eastern.normalize(loc_dt - timedelta(minutes=10)).strftime(fmt)",
        ">>> (loc_dt + timedelta(minutes=10)).strftime(fmt)",
        ">>> try:",
        ">>> try:"
      ],
      "docstring": "Return a datetime.tzinfo implementation for the given timezone\n\n>>> from datetime import datetime, timedelta\n>>> utc = timezone('UTC')\n>>> eastern = timezone('US/Eastern')\n>>> eastern.zone\n'US/Eastern'\n>>> timezone(unicode('US/Eastern')) is eastern\nTrue\n>>> utc_dt = datetime(2002, 10, 27, 6, 0, 0, tzinfo=utc)\n>>> loc_dt = utc_dt.astimezone(eastern)\n>>> fmt = '%Y-%m-%d %H:%M:%S %Z (%z)'\n>>> loc_dt.strftime(fmt)\n'2002-10-27 01:00:00 EST (-0500)'\n>>> (loc_dt - timedelta(minutes=10)).strftime(fmt)\n'2002-10-27 00:50:00 EST (-0500)'\n>>> eastern.normalize(loc_dt - timedelta(minutes=10)).strftime(fmt)\n'2002-10-27 01:50:00 EDT (-0400)'\n>>> (loc_dt + timedelta(minutes=10)).strftime(fmt)\n'2002-10-27 01:10:00 EST (-0500)'\n\nRaises UnknownTimeZoneError if passed an unknown zone.\n\n>>> try:\n...     timezone('Asia/Shangri-La')\n... except UnknownTimeZoneError:\n...     print('Unknown')\nUnknown\n\n>>> try:\n...     timezone(unicode('\\N{TRADE MARK SIGN}'))\n... except UnknownTimeZoneError:\n...     print('Unknown')\nUnknown",
      "source_code": "def timezone(zone):\n    r''' Return a datetime.tzinfo implementation for the given timezone\n\n    >>> from datetime import datetime, timedelta\n    >>> utc = timezone('UTC')\n    >>> eastern = timezone('US/Eastern')\n    >>> eastern.zone\n    'US/Eastern'\n    >>> timezone(unicode('US/Eastern')) is eastern\n    True\n    >>> utc_dt = datetime(2002, 10, 27, 6, 0, 0, tzinfo=utc)\n    >>> loc_dt = utc_dt.astimezone(eastern)\n    >>> fmt = '%Y-%m-%d %H:%M:%S %Z (%z)'\n    >>> loc_dt.strftime(fmt)\n    '2002-10-27 01:00:00 EST (-0500)'\n    >>> (loc_dt - timedelta(minutes=10)).strftime(fmt)\n    '2002-10-27 00:50:00 EST (-0500)'\n    >>> eastern.normalize(loc_dt - timedelta(minutes=10)).strftime(fmt)\n    '2002-10-27 01:50:00 EDT (-0400)'\n    >>> (loc_dt + timedelta(minutes=10)).strftime(fmt)\n    '2002-10-27 01:10:00 EST (-0500)'\n\n    Raises UnknownTimeZoneError if passed an unknown zone.\n\n    >>> try:\n    ...     timezone('Asia/Shangri-La')\n    ... except UnknownTimeZoneError:\n    ...     print('Unknown')\n    Unknown\n\n    >>> try:\n    ...     timezone(unicode('\\N{TRADE MARK SIGN}'))\n    ... except UnknownTimeZoneError:\n    ...     print('Unknown')\n    Unknown\n\n    '''\n    if zone is None:\n        raise UnknownTimeZoneError(None)\n\n    if zone.upper() == 'UTC':\n        return utc\n\n    try:\n        zone = ascii(zone)\n    except UnicodeEncodeError:\n        # All valid timezones are ASCII\n        raise UnknownTimeZoneError(zone)\n\n    zone = _case_insensitive_zone_lookup(_unmunge_zone(zone))\n    if zone not in _tzinfo_cache:\n        if zone in all_timezones_set:  # noqa\n            fp = open_resource(zone)\n            try:\n                _tzinfo_cache[zone] = build_tzinfo(zone, fp)\n            finally:\n                fp.close()\n        else:\n            raise UnknownTimeZoneError(zone)\n\n    return _tzinfo_cache[zone]\n"
    },
    {
      "type": "function",
      "qualified_name": "pytz.unpickler",
      "module": "pytz",
      "signature": "(zone, utcoffset=None, dstoffset=None, tzname=None)",
      "parameters": {
        "zone": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "utcoffset": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "dstoffset": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "tzname": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Factory function for unpickling pytz tzinfo instances.\n\nThis is shared for both StaticTzInfo and DstTzInfo instances, because\ndatabase changes could cause a zones implementation to switch between\nthese two base classes and we can't break pickles on a pytz version\nupgrade.",
      "source_code": "def unpickler(zone, utcoffset=None, dstoffset=None, tzname=None):\n    \"\"\"Factory function for unpickling pytz tzinfo instances.\n\n    This is shared for both StaticTzInfo and DstTzInfo instances, because\n    database changes could cause a zones implementation to switch between\n    these two base classes and we can't break pickles on a pytz version\n    upgrade.\n    \"\"\"\n    # Raises a KeyError if zone no longer exists, which should never happen\n    # and would be a bug.\n    tz = pytz.timezone(zone)\n\n    # A StaticTzInfo - just return it\n    if utcoffset is None:\n        return tz\n\n    # This pickle was created from a DstTzInfo. We need to\n    # determine which of the list of tzinfo instances for this zone\n    # to use in order to restore the state of any datetime instances using\n    # it correctly.\n    utcoffset = memorized_timedelta(utcoffset)\n    dstoffset = memorized_timedelta(dstoffset)\n    try:\n        return tz._tzinfos[(utcoffset, dstoffset, tzname)]\n    except KeyError:\n        # The particular state requested in this timezone no longer exists.\n        # This indicates a corrupt pickle, or the timezone database has been\n        # corrected violently enough to make this particular\n        # (utcoffset,dstoffset) no longer exist in the zone, or the\n        # abbreviation has been changed.\n        pass\n\n    # See if we can find an entry differing only by tzname. Abbreviations\n    # get changed from the initial guess by the database maintainers to\n    # match reality when this information is discovered.\n    for localized_tz in tz._tzinfos.values():\n        if (localized_tz._utcoffset == utcoffset and\n                localized_tz._dst == dstoffset):\n            return localized_tz\n\n    # This (utcoffset, dstoffset) information has been removed from the\n    # zone. Add it back. This might occur when the database maintainers have\n    # corrected incorrect information. datetime instances using this\n    # incorrect information will continue to do so, exactly as they were\n    # before being pickled. This is purely an overly paranoid safety net - I\n    # doubt this will ever been needed in real life.\n    inf = (utcoffset, dstoffset, tzname)\n    tz._tzinfos[inf] = tz.__class__(inf, tz._tzinfos)\n    return tz._tzinfos[inf]\n"
    },
    {
      "type": "function",
      "qualified_name": "pytz.lazy.RLock",
      "module": "pytz.lazy",
      "signature": "(*args, **kwargs)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        },
        "kwargs": {
          "default": null,
          "annotation": null,
          "kind": "VAR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Factory function that returns a new reentrant lock.\n\nA reentrant lock must be released by the thread that acquired it. Once a\nthread has acquired a reentrant lock, the same thread may acquire it again\nwithout blocking; the thread must release it once for each time it has\nacquired it.",
      "source_code": "def RLock(*args, **kwargs):\n    \"\"\"Factory function that returns a new reentrant lock.\n\n    A reentrant lock must be released by the thread that acquired it. Once a\n    thread has acquired a reentrant lock, the same thread may acquire it again\n    without blocking; the thread must release it once for each time it has\n    acquired it.\n\n    \"\"\"\n    if _CRLock is None:\n        return _PyRLock(*args, **kwargs)\n    return _CRLock(*args, **kwargs)\n"
    },
    {
      "type": "function",
      "qualified_name": "pytz.reference.first_sunday_on_or_after",
      "module": "pytz.reference",
      "signature": "(dt)",
      "parameters": {
        "dt": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "def first_sunday_on_or_after(dt):\n    days_to_go = 6 - dt.weekday()\n    if days_to_go:\n        dt += timedelta(days_to_go)\n    return dt\n"
    },
    {
      "type": "function",
      "qualified_name": "pytz.tzfile.build_tzinfo",
      "module": "pytz.tzfile",
      "signature": "(zone, fp)",
      "parameters": {
        "zone": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "fp": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "",
      "source_code": "def build_tzinfo(zone, fp):\n    head_fmt = '>4s c 15x 6l'\n    head_size = calcsize(head_fmt)\n    (magic, format, ttisgmtcnt, ttisstdcnt, leapcnt, timecnt,\n        typecnt, charcnt) = unpack(head_fmt, fp.read(head_size))\n\n    # Make sure it is a tzfile(5) file\n    assert magic == _byte_string('TZif'), 'Got magic %s' % repr(magic)\n\n    # Read out the transition times, localtime indices and ttinfo structures.\n    data_fmt = '>%(timecnt)dl %(timecnt)dB %(ttinfo)s %(charcnt)ds' % dict(\n        timecnt=timecnt, ttinfo='lBB' * typecnt, charcnt=charcnt)\n    data_size = calcsize(data_fmt)\n    data = unpack(data_fmt, fp.read(data_size))\n\n    # make sure we unpacked the right number of values\n    assert len(data) == 2 * timecnt + 3 * typecnt + 1\n    transitions = [memorized_datetime(trans)\n                   for trans in data[:timecnt]]\n    lindexes = list(data[timecnt:2 * timecnt])\n    ttinfo_raw = data[2 * timecnt:-1]\n    tznames_raw = data[-1]\n    del data\n\n    # Process ttinfo into separate structs\n    ttinfo = []\n    tznames = {}\n    i = 0\n    while i < len(ttinfo_raw):\n        # have we looked up this timezone name yet?\n        tzname_offset = ttinfo_raw[i + 2]\n        if tzname_offset not in tznames:\n            nul = tznames_raw.find(_NULL, tzname_offset)\n            if nul < 0:\n                nul = len(tznames_raw)\n            tznames[tzname_offset] = _std_string(\n                tznames_raw[tzname_offset:nul])\n        ttinfo.append((ttinfo_raw[i],\n                       bool(ttinfo_raw[i + 1]),\n                       tznames[tzname_offset]))\n        i += 3\n\n    # Now build the timezone object\n    if len(ttinfo) == 1 or len(transitions) == 0:\n        ttinfo[0][0], ttinfo[0][2]\n        cls = type(zone, (StaticTzInfo,), dict(\n            zone=zone,\n            _utcoffset=memorized_timedelta(ttinfo[0][0]),\n            _tzname=ttinfo[0][2]))\n    else:\n        # Early dates use the first standard time ttinfo\n        i = 0\n        while ttinfo[i][1]:\n            i += 1\n        if ttinfo[i] == ttinfo[lindexes[0]]:\n            transitions[0] = datetime.min\n        else:\n            transitions.insert(0, datetime.min)\n            lindexes.insert(0, i)\n\n        # calculate transition info\n        transition_info = []\n        for i in range(len(transitions)):\n            inf = ttinfo[lindexes[i]]\n            utcoffset = inf[0]\n            if not inf[1]:\n                dst = 0\n            else:\n                for j in range(i - 1, -1, -1):\n                    prev_inf = ttinfo[lindexes[j]]\n                    if not prev_inf[1]:\n                        break\n                dst = inf[0] - prev_inf[0]  # dst offset\n\n                # Bad dst? Look further. DST > 24 hours happens when\n                # a timzone has moved across the international dateline.\n                if dst <= 0 or dst > 3600 * 3:\n                    for j in range(i + 1, len(transitions)):\n                        stdinf = ttinfo[lindexes[j]]\n                        if not stdinf[1]:\n                            dst = inf[0] - stdinf[0]\n                            if dst > 0:\n                                break  # Found a useful std time.\n\n            tzname = inf[2]\n\n            # Round utcoffset and dst to the nearest minute or the\n            # datetime library will complain. Conversions to these timezones\n            # might be up to plus or minus 30 seconds out, but it is\n            # the best we can do.\n            utcoffset = int((utcoffset + 30) // 60) * 60\n            dst = int((dst + 30) // 60) * 60\n            transition_info.append(memorized_ttinfo(utcoffset, dst, tzname))\n\n        cls = type(zone, (DstTzInfo,), dict(\n            zone=zone,\n            _utc_transition_times=transitions,\n            _transition_info=transition_info))\n\n    return cls()\n"
    },
    {
      "type": "function",
      "qualified_name": "pytz.tzfile.memorized_datetime",
      "module": "pytz.tzfile",
      "signature": "(seconds)",
      "parameters": {
        "seconds": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Create only one instance of each distinct datetime",
      "source_code": "def memorized_datetime(seconds):\n    '''Create only one instance of each distinct datetime'''\n    try:\n        return _datetime_cache[seconds]\n    except KeyError:\n        # NB. We can't just do datetime.fromtimestamp(seconds, tz=timezone.utc).replace(tzinfo=None)\n        # as this fails with negative values under Windows (Bug #90096)\n        dt = _epoch + timedelta(seconds=seconds)\n        _datetime_cache[seconds] = dt\n        return dt\n"
    },
    {
      "type": "function",
      "qualified_name": "pytz.tzfile.memorized_timedelta",
      "module": "pytz.tzfile",
      "signature": "(seconds)",
      "parameters": {
        "seconds": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Create only one instance of each distinct timedelta",
      "source_code": "def memorized_timedelta(seconds):\n    '''Create only one instance of each distinct timedelta'''\n    try:\n        return _timedelta_cache[seconds]\n    except KeyError:\n        delta = timedelta(seconds=seconds)\n        _timedelta_cache[seconds] = delta\n        return delta\n"
    },
    {
      "type": "function",
      "qualified_name": "pytz.tzfile.memorized_ttinfo",
      "module": "pytz.tzfile",
      "signature": "(*args)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Create only one instance of each distinct tuple",
      "source_code": "def memorized_ttinfo(*args):\n    '''Create only one instance of each distinct tuple'''\n    try:\n        return _ttinfo_cache[args]\n    except KeyError:\n        ttinfo = (\n            memorized_timedelta(args[0]),\n            memorized_timedelta(args[1]),\n            args[2]\n        )\n        _ttinfo_cache[args] = ttinfo\n        return ttinfo\n"
    },
    {
      "type": "function",
      "qualified_name": "pytz.tzinfo.memorized_datetime",
      "module": "pytz.tzinfo",
      "signature": "(seconds)",
      "parameters": {
        "seconds": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Create only one instance of each distinct datetime",
      "source_code": "def memorized_datetime(seconds):\n    '''Create only one instance of each distinct datetime'''\n    try:\n        return _datetime_cache[seconds]\n    except KeyError:\n        # NB. We can't just do datetime.fromtimestamp(seconds, tz=timezone.utc).replace(tzinfo=None)\n        # as this fails with negative values under Windows (Bug #90096)\n        dt = _epoch + timedelta(seconds=seconds)\n        _datetime_cache[seconds] = dt\n        return dt\n"
    },
    {
      "type": "function",
      "qualified_name": "pytz.tzinfo.memorized_timedelta",
      "module": "pytz.tzinfo",
      "signature": "(seconds)",
      "parameters": {
        "seconds": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Create only one instance of each distinct timedelta",
      "source_code": "def memorized_timedelta(seconds):\n    '''Create only one instance of each distinct timedelta'''\n    try:\n        return _timedelta_cache[seconds]\n    except KeyError:\n        delta = timedelta(seconds=seconds)\n        _timedelta_cache[seconds] = delta\n        return delta\n"
    },
    {
      "type": "function",
      "qualified_name": "pytz.tzinfo.memorized_ttinfo",
      "module": "pytz.tzinfo",
      "signature": "(*args)",
      "parameters": {
        "args": {
          "default": null,
          "annotation": null,
          "kind": "VAR_POSITIONAL",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Create only one instance of each distinct tuple",
      "source_code": "def memorized_ttinfo(*args):\n    '''Create only one instance of each distinct tuple'''\n    try:\n        return _ttinfo_cache[args]\n    except KeyError:\n        ttinfo = (\n            memorized_timedelta(args[0]),\n            memorized_timedelta(args[1]),\n            args[2]\n        )\n        _ttinfo_cache[args] = ttinfo\n        return ttinfo\n"
    },
    {
      "type": "function",
      "qualified_name": "pytz.tzinfo.unpickler",
      "module": "pytz.tzinfo",
      "signature": "(zone, utcoffset=None, dstoffset=None, tzname=None)",
      "parameters": {
        "zone": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "utcoffset": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "dstoffset": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "tzname": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Factory function for unpickling pytz tzinfo instances.\n\nThis is shared for both StaticTzInfo and DstTzInfo instances, because\ndatabase changes could cause a zones implementation to switch between\nthese two base classes and we can't break pickles on a pytz version\nupgrade.",
      "source_code": "def unpickler(zone, utcoffset=None, dstoffset=None, tzname=None):\n    \"\"\"Factory function for unpickling pytz tzinfo instances.\n\n    This is shared for both StaticTzInfo and DstTzInfo instances, because\n    database changes could cause a zones implementation to switch between\n    these two base classes and we can't break pickles on a pytz version\n    upgrade.\n    \"\"\"\n    # Raises a KeyError if zone no longer exists, which should never happen\n    # and would be a bug.\n    tz = pytz.timezone(zone)\n\n    # A StaticTzInfo - just return it\n    if utcoffset is None:\n        return tz\n\n    # This pickle was created from a DstTzInfo. We need to\n    # determine which of the list of tzinfo instances for this zone\n    # to use in order to restore the state of any datetime instances using\n    # it correctly.\n    utcoffset = memorized_timedelta(utcoffset)\n    dstoffset = memorized_timedelta(dstoffset)\n    try:\n        return tz._tzinfos[(utcoffset, dstoffset, tzname)]\n    except KeyError:\n        # The particular state requested in this timezone no longer exists.\n        # This indicates a corrupt pickle, or the timezone database has been\n        # corrected violently enough to make this particular\n        # (utcoffset,dstoffset) no longer exist in the zone, or the\n        # abbreviation has been changed.\n        pass\n\n    # See if we can find an entry differing only by tzname. Abbreviations\n    # get changed from the initial guess by the database maintainers to\n    # match reality when this information is discovered.\n    for localized_tz in tz._tzinfos.values():\n        if (localized_tz._utcoffset == utcoffset and\n                localized_tz._dst == dstoffset):\n            return localized_tz\n\n    # This (utcoffset, dstoffset) information has been removed from the\n    # zone. Add it back. This might occur when the database maintainers have\n    # corrected incorrect information. datetime instances using this\n    # incorrect information will continue to do so, exactly as they were\n    # before being pickled. This is purely an overly paranoid safety net - I\n    # doubt this will ever been needed in real life.\n    inf = (utcoffset, dstoffset, tzname)\n    tz._tzinfos[inf] = tz.__class__(inf, tz._tzinfos)\n    return tz._tzinfos[inf]\n"
    },
    {
      "type": "class",
      "qualified_name": "pytz.AmbiguousTimeError",
      "module": "pytz",
      "signature": "(self, /, *args, **kwargs)",
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Exception raised when attempting to create an ambiguous wallclock time.\n\nAt the end of a DST transition period, a particular wallclock time will\noccur twice (once before the clocks are set back, once after). Both\npossibilities may be correct, unless further information is supplied.\n\nSee DstTzInfo.normalize() for more info",
      "source_code": "class AmbiguousTimeError(InvalidTimeError):\n    '''Exception raised when attempting to create an ambiguous wallclock time.\n\n    At the end of a DST transition period, a particular wallclock time will\n    occur twice (once before the clocks are set back, once after). Both\n    possibilities may be correct, unless further information is supplied.\n\n    See DstTzInfo.normalize() for more info\n    '''\n"
    },
    {
      "type": "class",
      "qualified_name": "pytz.BaseTzInfo",
      "module": "pytz",
      "signature": "(self, /, *args, **kwargs)",
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Abstract base class for time zone info objects.",
      "source_code": "class BaseTzInfo(tzinfo):\n    # Overridden in subclass\n    _utcoffset = None\n    _tzname = None\n    zone = None\n\n    def __str__(self):\n        return self.zone\n"
    },
    {
      "type": "class",
      "qualified_name": "pytz.InvalidTimeError",
      "module": "pytz",
      "signature": "(self, /, *args, **kwargs)",
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Base class for invalid time exceptions.",
      "source_code": "class InvalidTimeError(Error):\n    '''Base class for invalid time exceptions.'''\n"
    },
    {
      "type": "class",
      "qualified_name": "pytz.LazyDict",
      "module": "pytz",
      "signature": "(self, /, *args, **kwargs)",
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Dictionary populated on first use.",
      "source_code": "class LazyDict(DictMixin):\n    \"\"\"Dictionary populated on first use.\"\"\"\n    data = None\n\n    def __getitem__(self, key):\n        if self.data is None:\n            _fill_lock.acquire()\n            try:\n                if self.data is None:\n                    self._fill()\n            finally:\n                _fill_lock.release()\n        return self.data[key.upper()]\n\n    def __contains__(self, key):\n        if self.data is None:\n            _fill_lock.acquire()\n            try:\n                if self.data is None:\n                    self._fill()\n            finally:\n                _fill_lock.release()\n        return key in self.data\n\n    def __iter__(self):\n        if self.data is None:\n            _fill_lock.acquire()\n            try:\n                if self.data is None:\n                    self._fill()\n            finally:\n                _fill_lock.release()\n        return iter(self.data)\n\n    def __len__(self):\n        if self.data is None:\n            _fill_lock.acquire()\n            try:\n                if self.data is None:\n                    self._fill()\n            finally:\n                _fill_lock.release()\n        return len(self.data)\n\n    def keys(self):\n        if self.data is None:\n            _fill_lock.acquire()\n            try:\n                if self.data is None:\n                    self._fill()\n            finally:\n                _fill_lock.release()\n        return self.data.keys()\n"
    },
    {
      "type": "class",
      "qualified_name": "pytz.LazyList",
      "module": "pytz",
      "signature": "(self, /, *args, **kwargs)",
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "List populated on first use.",
      "source_code": "class LazyList(list):\n    \"\"\"List populated on first use.\"\"\"\n\n    _props = [\n        '__str__', '__repr__', '__unicode__',\n        '__hash__', '__sizeof__', '__cmp__',\n        '__lt__', '__le__', '__eq__', '__ne__', '__gt__', '__ge__',\n        'append', 'count', 'index', 'extend', 'insert', 'pop', 'remove',\n        'reverse', 'sort', '__add__', '__radd__', '__iadd__', '__mul__',\n        '__rmul__', '__imul__', '__contains__', '__len__', '__nonzero__',\n        '__getitem__', '__setitem__', '__delitem__', '__iter__',\n        '__reversed__', '__getslice__', '__setslice__', '__delslice__']\n\n    def __new__(cls, fill_iter=None):\n\n        if fill_iter is None:\n            return list()\n\n        # We need a new class as we will be dynamically messing with its\n        # methods.\n        class LazyList(list):\n            pass\n\n        fill_iter = [fill_iter]\n\n        def lazy(name):\n            def _lazy(self, *args, **kw):\n                _fill_lock.acquire()\n                try:\n                    if len(fill_iter) > 0:\n                        list.extend(self, fill_iter.pop())\n                        for method_name in cls._props:\n                            delattr(LazyList, method_name)\n                finally:\n                    _fill_lock.release()\n                return getattr(list, name)(self, *args, **kw)\n            return _lazy\n\n        for name in cls._props:\n            setattr(LazyList, name, lazy(name))\n\n        new_list = LazyList()\n        return new_list\n"
    },
    {
      "type": "class",
      "qualified_name": "pytz.LazySet",
      "module": "pytz",
      "signature": "(self, /, *args, **kwargs)",
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Set populated on first use.",
      "source_code": "class LazySet(set):\n    \"\"\"Set populated on first use.\"\"\"\n\n    _props = (\n        '__str__', '__repr__', '__unicode__',\n        '__hash__', '__sizeof__', '__cmp__',\n        '__lt__', '__le__', '__eq__', '__ne__', '__gt__', '__ge__',\n        '__contains__', '__len__', '__nonzero__',\n        '__getitem__', '__setitem__', '__delitem__', '__iter__',\n        '__sub__', '__and__', '__xor__', '__or__',\n        '__rsub__', '__rand__', '__rxor__', '__ror__',\n        '__isub__', '__iand__', '__ixor__', '__ior__',\n        'add', 'clear', 'copy', 'difference', 'difference_update',\n        'discard', 'intersection', 'intersection_update', 'isdisjoint',\n        'issubset', 'issuperset', 'pop', 'remove',\n        'symmetric_difference', 'symmetric_difference_update',\n        'union', 'update')\n\n    def __new__(cls, fill_iter=None):\n\n        if fill_iter is None:\n            return set()\n\n        class LazySet(set):\n            pass\n\n        fill_iter = [fill_iter]\n\n        def lazy(name):\n            def _lazy(self, *args, **kw):\n                _fill_lock.acquire()\n                try:\n                    if len(fill_iter) > 0:\n                        for i in fill_iter.pop():\n                            set.add(self, i)\n                        for method_name in cls._props:\n                            delattr(LazySet, method_name)\n                finally:\n                    _fill_lock.release()\n                return getattr(set, name)(self, *args, **kw)\n            return _lazy\n\n        for name in cls._props:\n            setattr(LazySet, name, lazy(name))\n\n        new_set = LazySet()\n        return new_set\n"
    },
    {
      "type": "class",
      "qualified_name": "pytz.NonExistentTimeError",
      "module": "pytz",
      "signature": "(self, /, *args, **kwargs)",
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Exception raised when attempting to create a wallclock time that\ncannot exist.\n\nAt the start of a DST transition period, the wallclock time jumps forward.\nThe instants jumped over never occur.",
      "source_code": "class NonExistentTimeError(InvalidTimeError):\n    '''Exception raised when attempting to create a wallclock time that\n    cannot exist.\n\n    At the start of a DST transition period, the wallclock time jumps forward.\n    The instants jumped over never occur.\n    '''\n"
    },
    {
      "type": "class",
      "qualified_name": "pytz.UnknownTimeZoneError",
      "module": "pytz",
      "signature": "(self, /, *args, **kwargs)",
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [
        ">>> isinstance(UnknownTimeZoneError(), LookupError)",
        ">>> isinstance(UnknownTimeZoneError(), KeyError)",
        ">>> isinstance(UnknownTimeZoneError(), Error)"
      ],
      "docstring": "Exception raised when pytz is passed an unknown timezone.\n\n>>> isinstance(UnknownTimeZoneError(), LookupError)\nTrue\n\nThis class is actually a subclass of KeyError to provide backwards\ncompatibility with code relying on the undocumented behavior of earlier\npytz releases.\n\n>>> isinstance(UnknownTimeZoneError(), KeyError)\nTrue\n\nAnd also a subclass of pytz.exceptions.Error, as are other pytz\nexceptions.\n\n>>> isinstance(UnknownTimeZoneError(), Error)\nTrue",
      "source_code": "class UnknownTimeZoneError(KeyError, Error):\n    '''Exception raised when pytz is passed an unknown timezone.\n\n    >>> isinstance(UnknownTimeZoneError(), LookupError)\n    True\n\n    This class is actually a subclass of KeyError to provide backwards\n    compatibility with code relying on the undocumented behavior of earlier\n    pytz releases.\n\n    >>> isinstance(UnknownTimeZoneError(), KeyError)\n    True\n\n    And also a subclass of pytz.exceptions.Error, as are other pytz\n    exceptions.\n\n    >>> isinstance(UnknownTimeZoneError(), Error)\n    True\n\n    '''\n    pass\n"
    },
    {
      "type": "class",
      "qualified_name": "pytz.unicode",
      "module": "pytz",
      "signature": "(self, /, *args, **kwargs)",
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "str(object='') -> str\nstr(bytes_or_buffer[, encoding[, errors]]) -> str\n\nCreate a new string object from the given object. If encoding or\nerrors is specified, then the object must expose a data buffer\nthat will be decoded using the given encoding and error handler.\nOtherwise, returns the result of object.__str__() (if defined)\nor repr(object).\nencoding defaults to sys.getdefaultencoding().\nerrors defaults to 'strict'.",
      "source_code": null
    },
    {
      "type": "class",
      "qualified_name": "pytz.exceptions.AmbiguousTimeError",
      "module": "pytz.exceptions",
      "signature": "(self, /, *args, **kwargs)",
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Exception raised when attempting to create an ambiguous wallclock time.\n\nAt the end of a DST transition period, a particular wallclock time will\noccur twice (once before the clocks are set back, once after). Both\npossibilities may be correct, unless further information is supplied.\n\nSee DstTzInfo.normalize() for more info",
      "source_code": "class AmbiguousTimeError(InvalidTimeError):\n    '''Exception raised when attempting to create an ambiguous wallclock time.\n\n    At the end of a DST transition period, a particular wallclock time will\n    occur twice (once before the clocks are set back, once after). Both\n    possibilities may be correct, unless further information is supplied.\n\n    See DstTzInfo.normalize() for more info\n    '''\n"
    },
    {
      "type": "class",
      "qualified_name": "pytz.exceptions.Error",
      "module": "pytz.exceptions",
      "signature": "(self, /, *args, **kwargs)",
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Base class for all exceptions raised by the pytz library",
      "source_code": "class Error(Exception):\n    '''Base class for all exceptions raised by the pytz library'''\n"
    },
    {
      "type": "class",
      "qualified_name": "pytz.exceptions.InvalidTimeError",
      "module": "pytz.exceptions",
      "signature": "(self, /, *args, **kwargs)",
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Base class for invalid time exceptions.",
      "source_code": "class InvalidTimeError(Error):\n    '''Base class for invalid time exceptions.'''\n"
    },
    {
      "type": "class",
      "qualified_name": "pytz.exceptions.NonExistentTimeError",
      "module": "pytz.exceptions",
      "signature": "(self, /, *args, **kwargs)",
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Exception raised when attempting to create a wallclock time that\ncannot exist.\n\nAt the start of a DST transition period, the wallclock time jumps forward.\nThe instants jumped over never occur.",
      "source_code": "class NonExistentTimeError(InvalidTimeError):\n    '''Exception raised when attempting to create a wallclock time that\n    cannot exist.\n\n    At the start of a DST transition period, the wallclock time jumps forward.\n    The instants jumped over never occur.\n    '''\n"
    },
    {
      "type": "class",
      "qualified_name": "pytz.exceptions.UnknownTimeZoneError",
      "module": "pytz.exceptions",
      "signature": "(self, /, *args, **kwargs)",
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [
        ">>> isinstance(UnknownTimeZoneError(), LookupError)",
        ">>> isinstance(UnknownTimeZoneError(), KeyError)",
        ">>> isinstance(UnknownTimeZoneError(), Error)"
      ],
      "docstring": "Exception raised when pytz is passed an unknown timezone.\n\n>>> isinstance(UnknownTimeZoneError(), LookupError)\nTrue\n\nThis class is actually a subclass of KeyError to provide backwards\ncompatibility with code relying on the undocumented behavior of earlier\npytz releases.\n\n>>> isinstance(UnknownTimeZoneError(), KeyError)\nTrue\n\nAnd also a subclass of pytz.exceptions.Error, as are other pytz\nexceptions.\n\n>>> isinstance(UnknownTimeZoneError(), Error)\nTrue",
      "source_code": "class UnknownTimeZoneError(KeyError, Error):\n    '''Exception raised when pytz is passed an unknown timezone.\n\n    >>> isinstance(UnknownTimeZoneError(), LookupError)\n    True\n\n    This class is actually a subclass of KeyError to provide backwards\n    compatibility with code relying on the undocumented behavior of earlier\n    pytz releases.\n\n    >>> isinstance(UnknownTimeZoneError(), KeyError)\n    True\n\n    And also a subclass of pytz.exceptions.Error, as are other pytz\n    exceptions.\n\n    >>> isinstance(UnknownTimeZoneError(), Error)\n    True\n\n    '''\n    pass\n"
    },
    {
      "type": "class",
      "qualified_name": "pytz.lazy.DictMixin",
      "module": "pytz.lazy",
      "signature": "(self, /, *args, **kwargs)",
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "A Mapping is a generic container for associating key/value\npairs.\n\nThis class provides concrete generic implementations of all\nmethods except for __getitem__, __iter__, and __len__.",
      "source_code": null
    },
    {
      "type": "class",
      "qualified_name": "pytz.lazy.LazyDict",
      "module": "pytz.lazy",
      "signature": "(self, /, *args, **kwargs)",
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Dictionary populated on first use.",
      "source_code": "class LazyDict(DictMixin):\n    \"\"\"Dictionary populated on first use.\"\"\"\n    data = None\n\n    def __getitem__(self, key):\n        if self.data is None:\n            _fill_lock.acquire()\n            try:\n                if self.data is None:\n                    self._fill()\n            finally:\n                _fill_lock.release()\n        return self.data[key.upper()]\n\n    def __contains__(self, key):\n        if self.data is None:\n            _fill_lock.acquire()\n            try:\n                if self.data is None:\n                    self._fill()\n            finally:\n                _fill_lock.release()\n        return key in self.data\n\n    def __iter__(self):\n        if self.data is None:\n            _fill_lock.acquire()\n            try:\n                if self.data is None:\n                    self._fill()\n            finally:\n                _fill_lock.release()\n        return iter(self.data)\n\n    def __len__(self):\n        if self.data is None:\n            _fill_lock.acquire()\n            try:\n                if self.data is None:\n                    self._fill()\n            finally:\n                _fill_lock.release()\n        return len(self.data)\n\n    def keys(self):\n        if self.data is None:\n            _fill_lock.acquire()\n            try:\n                if self.data is None:\n                    self._fill()\n            finally:\n                _fill_lock.release()\n        return self.data.keys()\n"
    },
    {
      "type": "class",
      "qualified_name": "pytz.lazy.LazyList",
      "module": "pytz.lazy",
      "signature": "(self, /, *args, **kwargs)",
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "List populated on first use.",
      "source_code": "class LazyList(list):\n    \"\"\"List populated on first use.\"\"\"\n\n    _props = [\n        '__str__', '__repr__', '__unicode__',\n        '__hash__', '__sizeof__', '__cmp__',\n        '__lt__', '__le__', '__eq__', '__ne__', '__gt__', '__ge__',\n        'append', 'count', 'index', 'extend', 'insert', 'pop', 'remove',\n        'reverse', 'sort', '__add__', '__radd__', '__iadd__', '__mul__',\n        '__rmul__', '__imul__', '__contains__', '__len__', '__nonzero__',\n        '__getitem__', '__setitem__', '__delitem__', '__iter__',\n        '__reversed__', '__getslice__', '__setslice__', '__delslice__']\n\n    def __new__(cls, fill_iter=None):\n\n        if fill_iter is None:\n            return list()\n\n        # We need a new class as we will be dynamically messing with its\n        # methods.\n        class LazyList(list):\n            pass\n\n        fill_iter = [fill_iter]\n\n        def lazy(name):\n            def _lazy(self, *args, **kw):\n                _fill_lock.acquire()\n                try:\n                    if len(fill_iter) > 0:\n                        list.extend(self, fill_iter.pop())\n                        for method_name in cls._props:\n                            delattr(LazyList, method_name)\n                finally:\n                    _fill_lock.release()\n                return getattr(list, name)(self, *args, **kw)\n            return _lazy\n\n        for name in cls._props:\n            setattr(LazyList, name, lazy(name))\n\n        new_list = LazyList()\n        return new_list\n"
    },
    {
      "type": "class",
      "qualified_name": "pytz.lazy.LazySet",
      "module": "pytz.lazy",
      "signature": "(self, /, *args, **kwargs)",
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Set populated on first use.",
      "source_code": "class LazySet(set):\n    \"\"\"Set populated on first use.\"\"\"\n\n    _props = (\n        '__str__', '__repr__', '__unicode__',\n        '__hash__', '__sizeof__', '__cmp__',\n        '__lt__', '__le__', '__eq__', '__ne__', '__gt__', '__ge__',\n        '__contains__', '__len__', '__nonzero__',\n        '__getitem__', '__setitem__', '__delitem__', '__iter__',\n        '__sub__', '__and__', '__xor__', '__or__',\n        '__rsub__', '__rand__', '__rxor__', '__ror__',\n        '__isub__', '__iand__', '__ixor__', '__ior__',\n        'add', 'clear', 'copy', 'difference', 'difference_update',\n        'discard', 'intersection', 'intersection_update', 'isdisjoint',\n        'issubset', 'issuperset', 'pop', 'remove',\n        'symmetric_difference', 'symmetric_difference_update',\n        'union', 'update')\n\n    def __new__(cls, fill_iter=None):\n\n        if fill_iter is None:\n            return set()\n\n        class LazySet(set):\n            pass\n\n        fill_iter = [fill_iter]\n\n        def lazy(name):\n            def _lazy(self, *args, **kw):\n                _fill_lock.acquire()\n                try:\n                    if len(fill_iter) > 0:\n                        for i in fill_iter.pop():\n                            set.add(self, i)\n                        for method_name in cls._props:\n                            delattr(LazySet, method_name)\n                finally:\n                    _fill_lock.release()\n                return getattr(set, name)(self, *args, **kw)\n            return _lazy\n\n        for name in cls._props:\n            setattr(LazySet, name, lazy(name))\n\n        new_set = LazySet()\n        return new_set\n"
    },
    {
      "type": "class",
      "qualified_name": "pytz.reference.FixedOffset",
      "module": "pytz.reference",
      "signature": "(self, offset, name)",
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Fixed offset in minutes east from UTC.",
      "source_code": "class FixedOffset(tzinfo):\n    \"\"\"Fixed offset in minutes east from UTC.\"\"\"\n\n    def __init__(self, offset, name):\n        self.__offset = timedelta(minutes=offset)\n        self.__name = name\n\n    def utcoffset(self, dt):\n        return self.__offset\n\n    def tzname(self, dt):\n        return self.__name\n\n    def dst(self, dt):\n        return ZERO\n"
    },
    {
      "type": "class",
      "qualified_name": "pytz.reference.LocalTimezone",
      "module": "pytz.reference",
      "signature": "(self, /, *args, **kwargs)",
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Abstract base class for time zone info objects.",
      "source_code": "class LocalTimezone(tzinfo):\n\n    def utcoffset(self, dt):\n        if self._isdst(dt):\n            return DSTOFFSET\n        else:\n            return STDOFFSET\n\n    def dst(self, dt):\n        if self._isdst(dt):\n            return DSTDIFF\n        else:\n            return ZERO\n\n    def tzname(self, dt):\n        return _time.tzname[self._isdst(dt)]\n\n    def _isdst(self, dt):\n        tt = (dt.year, dt.month, dt.day,\n              dt.hour, dt.minute, dt.second,\n              dt.weekday(), 0, -1)\n        stamp = _time.mktime(tt)\n        tt = _time.localtime(stamp)\n        return tt.tm_isdst > 0\n"
    },
    {
      "type": "class",
      "qualified_name": "pytz.reference.USTimeZone",
      "module": "pytz.reference",
      "signature": "(self, hours, reprname, stdname, dstname)",
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Abstract base class for time zone info objects.",
      "source_code": "class USTimeZone(tzinfo):\n\n    def __init__(self, hours, reprname, stdname, dstname):\n        self.stdoffset = timedelta(hours=hours)\n        self.reprname = reprname\n        self.stdname = stdname\n        self.dstname = dstname\n\n    def __repr__(self):\n        return self.reprname\n\n    def tzname(self, dt):\n        if self.dst(dt):\n            return self.dstname\n        else:\n            return self.stdname\n\n    def utcoffset(self, dt):\n        return self.stdoffset + self.dst(dt)\n\n    def dst(self, dt):\n        if dt is None or dt.tzinfo is None:\n            # An exception may be sensible here, in one or both cases.\n            # It depends on how you want to treat them.  The default\n            # fromutc() implementation (called by the default astimezone()\n            # implementation) passes a datetime with dt.tzinfo is self.\n            return ZERO\n        assert dt.tzinfo is self\n\n        # Find first Sunday in April & the last in October.\n        start = first_sunday_on_or_after(DSTSTART.replace(year=dt.year))\n        end = first_sunday_on_or_after(DSTEND.replace(year=dt.year))\n\n        # Can't compare naive to aware objects, so strip the timezone from\n        # dt first.\n        if start <= dt.replace(tzinfo=None) < end:\n            return HOUR\n        else:\n            return ZERO\n"
    },
    {
      "type": "class",
      "qualified_name": "pytz.reference.datetime",
      "module": "pytz.reference",
      "signature": "(self, /, *args, **kwargs)",
      "return_description": null,
      "raises": [],
      "decorators": [
        "property",
        "property",
        "property",
        "property",
        "property",
        "property",
        "classmethod",
        "classmethod",
        "classmethod",
        "classmethod",
        "classmethod",
        "classmethod",
        "classmethod",
        "classmethod"
      ],
      "examples": [],
      "docstring": "datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]])\n\nThe year, month and day arguments are required. tzinfo may be None, or an\ninstance of a tzinfo subclass. The remaining arguments may be ints.",
      "source_code": "class datetime(date):\n    \"\"\"datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]])\n\n    The year, month and day arguments are required. tzinfo may be None, or an\n    instance of a tzinfo subclass. The remaining arguments may be ints.\n    \"\"\"\n    __slots__ = date.__slots__ + time.__slots__\n\n    def __new__(cls, year, month=None, day=None, hour=0, minute=0, second=0,\n                microsecond=0, tzinfo=None, *, fold=0):\n        if (isinstance(year, (bytes, str)) and len(year) == 10 and\n            1 <= ord(year[2:3])&0x7F <= 12):\n            # Pickle support\n            if isinstance(year, str):\n                try:\n                    year = bytes(year, 'latin1')\n                except UnicodeEncodeError:\n                    # More informative error message.\n                    raise ValueError(\n                        \"Failed to encode latin1 string when unpickling \"\n                        \"a datetime object. \"\n                        \"pickle.load(data, encoding='latin1') is assumed.\")\n            self = object.__new__(cls)\n            self.__setstate(year, month)\n            self._hashcode = -1\n            return self\n        year, month, day = _check_date_fields(year, month, day)\n        hour, minute, second, microsecond, fold = _check_time_fields(\n            hour, minute, second, microsecond, fold)\n        _check_tzinfo_arg(tzinfo)\n        self = object.__new__(cls)\n        self._year = year\n        self._month = month\n        self._day = day\n        self._hour = hour\n        self._minute = minute\n        self._second = second\n        self._microsecond = microsecond\n        self._tzinfo = tzinfo\n        self._hashcode = -1\n        self._fold = fold\n        return self\n\n    # Read-only field accessors\n    @property\n    def hour(self):\n        \"\"\"hour (0-23)\"\"\"\n        return self._hour\n\n    @property\n    def minute(self):\n        \"\"\"minute (0-59)\"\"\"\n        return self._minute\n\n    @property\n    def second(self):\n        \"\"\"second (0-59)\"\"\"\n        return self._second\n\n    @property\n    def microsecond(self):\n        \"\"\"microsecond (0-999999)\"\"\"\n        return self._microsecond\n\n    @property\n    def tzinfo(self):\n        \"\"\"timezone info object\"\"\"\n        return self._tzinfo\n\n    @property\n    def fold(self):\n        return self._fold\n\n    @classmethod\n    def _fromtimestamp(cls, t, utc, tz):\n        \"\"\"Construct a datetime from a POSIX timestamp (like time.time()).\n\n        A timezone info object may be passed in as well.\n        \"\"\"\n        frac, t = _math.modf(t)\n        us = round(frac * 1e6)\n        if us >= 1000000:\n            t += 1\n            us -= 1000000\n        elif us < 0:\n            t -= 1\n            us += 1000000\n\n        converter = _time.gmtime if utc else _time.localtime\n        y, m, d, hh, mm, ss, weekday, jday, dst = converter(t)\n        ss = min(ss, 59)    # clamp out leap seconds if the platform has them\n        result = cls(y, m, d, hh, mm, ss, us, tz)\n        if tz is None and not utc:\n            # As of version 2015f max fold in IANA database is\n            # 23 hours at 1969-09-30 13:00:00 in Kwajalein.\n            # Let's probe 24 hours in the past to detect a transition:\n            max_fold_seconds = 24 * 3600\n\n            # On Windows localtime_s throws an OSError for negative values,\n            # thus we can't perform fold detection for values of time less\n            # than the max time fold. See comments in _datetimemodule's\n            # version of this method for more details.\n            if t < max_fold_seconds and sys.platform.startswith(\"win\"):\n                return result\n\n            y, m, d, hh, mm, ss = converter(t - max_fold_seconds)[:6]\n            probe1 = cls(y, m, d, hh, mm, ss, us, tz)\n            trans = result - probe1 - timedelta(0, max_fold_seconds)\n            if trans.days < 0:\n                y, m, d, hh, mm, ss = converter(t + trans // timedelta(0, 1))[:6]\n                probe2 = cls(y, m, d, hh, mm, ss, us, tz)\n                if probe2 == result:\n                    result._fold = 1\n        elif tz is not None:\n            result = tz.fromutc(result)\n        return result\n\n    @classmethod\n    def fromtimestamp(cls, t, tz=None):\n        \"\"\"Construct a datetime from a POSIX timestamp (like time.time()).\n\n        A timezone info object may be passed in as well.\n        \"\"\"\n        _check_tzinfo_arg(tz)\n\n        return cls._fromtimestamp(t, tz is not None, tz)\n\n    @classmethod\n    def utcfromtimestamp(cls, t):\n        \"\"\"Construct a naive UTC datetime from a POSIX timestamp.\"\"\"\n        return cls._fromtimestamp(t, True, None)\n\n    @classmethod\n    def now(cls, tz=None):\n        \"Construct a datetime from time.time() and optional time zone info.\"\n        t = _time.time()\n        return cls.fromtimestamp(t, tz)\n\n    @classmethod\n    def utcnow(cls):\n        \"Construct a UTC datetime from time.time().\"\n        t = _time.time()\n        return cls.utcfromtimestamp(t)\n\n    @classmethod\n    def combine(cls, date, time, tzinfo=True):\n        \"Construct a datetime from a given date and a given time.\"\n        if not isinstance(date, _date_class):\n            raise TypeError(\"date argument must be a date instance\")\n        if not isinstance(time, _time_class):\n            raise TypeError(\"time argument must be a time instance\")\n        if tzinfo is True:\n            tzinfo = time.tzinfo\n        return cls(date.year, date.month, date.day,\n                   time.hour, time.minute, time.second, time.microsecond,\n                   tzinfo, fold=time.fold)\n\n    @classmethod\n    def fromisoformat(cls, date_string):\n        \"\"\"Construct a datetime from a string in one of the ISO 8601 formats.\"\"\"\n        if not isinstance(date_string, str):\n            raise TypeError('fromisoformat: argument must be str')\n\n        if len(date_string) < 7:\n            raise ValueError(f'Invalid isoformat string: {date_string!r}')\n\n        # Split this at the separator\n        try:\n            separator_location = _find_isoformat_datetime_separator(date_string)\n            dstr = date_string[0:separator_location]\n            tstr = date_string[(separator_location+1):]\n\n            date_components = _parse_isoformat_date(dstr)\n        except ValueError:\n            raise ValueError(\n                f'Invalid isoformat string: {date_string!r}') from None\n\n        if tstr:\n            try:\n                time_components = _parse_isoformat_time(tstr)\n            except ValueError:\n                raise ValueError(\n                    f'Invalid isoformat string: {date_string!r}') from None\n        else:\n            time_components = [0, 0, 0, 0, None]\n\n        return cls(*(date_components + time_components))\n\n    def timetuple(self):\n        \"Return local time tuple compatible with time.localtime().\"\n        dst = self.dst()\n        if dst is None:\n            dst = -1\n        elif dst:\n            dst = 1\n        else:\n            dst = 0\n        return _build_struct_time(self.year, self.month, self.day,\n                                  self.hour, self.minute, self.second,\n                                  dst)\n\n    def _mktime(self):\n        \"\"\"Return integer POSIX timestamp.\"\"\"\n        epoch = datetime(1970, 1, 1)\n        max_fold_seconds = 24 * 3600\n        t = (self - epoch) // timedelta(0, 1)\n        def local(u):\n            y, m, d, hh, mm, ss = _time.localtime(u)[:6]\n            return (datetime(y, m, d, hh, mm, ss) - epoch) // timedelta(0, 1)\n\n        # Our goal is to solve t = local(u) for u.\n        a = local(t) - t\n        u1 = t - a\n        t1 = local(u1)\n        if t1 == t:\n            # We found one solution, but it may not be the one we need.\n            # Look for an earlier solution (if `fold` is 0), or a\n            # later one (if `fold` is 1).\n            u2 = u1 + (-max_fold_seconds, max_fold_seconds)[self.fold]\n            b = local(u2) - u2\n            if a == b:\n                return u1\n        else:\n            b = t1 - u1\n            assert a != b\n        u2 = t - b\n        t2 = local(u2)\n        if t2 == t:\n            return u2\n        if t1 == t:\n            return u1\n        # We have found both offsets a and b, but neither t - a nor t - b is\n        # a solution.  This means t is in the gap.\n        return (max, min)[self.fold](u1, u2)\n\n\n    def timestamp(self):\n        \"Return POSIX timestamp as float\"\n        if self._tzinfo is None:\n            s = self._mktime()\n            return s + self.microsecond / 1e6\n        else:\n            return (self - _EPOCH).total_seconds()\n\n    def utctimetuple(self):\n        \"Return UTC time tuple compatible with time.gmtime().\"\n        offset = self.utcoffset()\n        if offset:\n            self -= offset\n        y, m, d = self.year, self.month, self.day\n        hh, mm, ss = self.hour, self.minute, self.second\n        return _build_struct_time(y, m, d, hh, mm, ss, 0)\n\n    def date(self):\n        \"Return the date part.\"\n        return date(self._year, self._month, self._day)\n\n    def time(self):\n        \"Return the time part, with tzinfo None.\"\n        return time(self.hour, self.minute, self.second, self.microsecond, fold=self.fold)\n\n    def timetz(self):\n        \"Return the time part, with same tzinfo.\"\n        return time(self.hour, self.minute, self.second, self.microsecond,\n                    self._tzinfo, fold=self.fold)\n\n    def replace(self, year=None, month=None, day=None, hour=None,\n                minute=None, second=None, microsecond=None, tzinfo=True,\n                *, fold=None):\n        \"\"\"Return a new datetime with new values for the specified fields.\"\"\"\n        if year is None:\n            year = self.year\n        if month is None:\n            month = self.month\n        if day is None:\n            day = self.day\n        if hour is None:\n            hour = self.hour\n        if minute is None:\n            minute = self.minute\n        if second is None:\n            second = self.second\n        if microsecond is None:\n            microsecond = self.microsecond\n        if tzinfo is True:\n            tzinfo = self.tzinfo\n        if fold is None:\n            fold = self.fold\n        return type(self)(year, month, day, hour, minute, second,\n                          microsecond, tzinfo, fold=fold)\n\n    def _local_timezone(self):\n        if self.tzinfo is None:\n            ts = self._mktime()\n        else:\n            ts = (self - _EPOCH) // timedelta(seconds=1)\n        localtm = _time.localtime(ts)\n        local = datetime(*localtm[:6])\n        # Extract TZ data\n        gmtoff = localtm.tm_gmtoff\n        zone = localtm.tm_zone\n        return timezone(timedelta(seconds=gmtoff), zone)\n\n    def astimezone(self, tz=None):\n        if tz is None:\n            tz = self._local_timezone()\n        elif not isinstance(tz, tzinfo):\n            raise TypeError(\"tz argument must be an instance of tzinfo\")\n\n        mytz = self.tzinfo\n        if mytz is None:\n            mytz = self._local_timezone()\n            myoffset = mytz.utcoffset(self)\n        else:\n            myoffset = mytz.utcoffset(self)\n            if myoffset is None:\n                mytz = self.replace(tzinfo=None)._local_timezone()\n                myoffset = mytz.utcoffset(self)\n\n        if tz is mytz:\n            return self\n\n        # Convert self to UTC, and attach the new time zone object.\n        utc = (self - myoffset).replace(tzinfo=tz)\n\n        # Convert from UTC to tz's local time.\n        return tz.fromutc(utc)\n\n    # Ways to produce a string.\n\n    def ctime(self):\n        \"Return ctime() style string.\"\n        weekday = self.toordinal() % 7 or 7\n        return \"%s %s %2d %02d:%02d:%02d %04d\" % (\n            _DAYNAMES[weekday],\n            _MONTHNAMES[self._month],\n            self._day,\n            self._hour, self._minute, self._second,\n            self._year)\n\n    def isoformat(self, sep='T', timespec='auto'):\n        \"\"\"Return the time formatted according to ISO.\n\n        The full format looks like 'YYYY-MM-DD HH:MM:SS.mmmmmm'.\n        By default, the fractional part is omitted if self.microsecond == 0.\n\n        If self.tzinfo is not None, the UTC offset is also attached, giving\n        giving a full format of 'YYYY-MM-DD HH:MM:SS.mmmmmm+HH:MM'.\n\n        Optional argument sep specifies the separator between date and\n        time, default 'T'.\n\n        The optional argument timespec specifies the number of additional\n        terms of the time to include. Valid options are 'auto', 'hours',\n        'minutes', 'seconds', 'milliseconds' and 'microseconds'.\n        \"\"\"\n        s = (\"%04d-%02d-%02d%c\" % (self._year, self._month, self._day, sep) +\n             _format_time(self._hour, self._minute, self._second,\n                          self._microsecond, timespec))\n\n        off = self.utcoffset()\n        tz = _format_offset(off)\n        if tz:\n            s += tz\n\n        return s\n\n    def __repr__(self):\n        \"\"\"Convert to formal string, for repr().\"\"\"\n        L = [self._year, self._month, self._day,  # These are never zero\n             self._hour, self._minute, self._second, self._microsecond]\n        if L[-1] == 0:\n            del L[-1]\n        if L[-1] == 0:\n            del L[-1]\n        s = \"%s.%s(%s)\" % (self.__class__.__module__,\n                           self.__class__.__qualname__,\n                           \", \".join(map(str, L)))\n        if self._tzinfo is not None:\n            assert s[-1:] == \")\"\n            s = s[:-1] + \", tzinfo=%r\" % self._tzinfo + \")\"\n        if self._fold:\n            assert s[-1:] == \")\"\n            s = s[:-1] + \", fold=1)\"\n        return s\n\n    def __str__(self):\n        \"Convert to string, for str().\"\n        return self.isoformat(sep=' ')\n\n    @classmethod\n    def strptime(cls, date_string, format):\n        'string, format -> new datetime parsed from a string (like time.strptime()).'\n        import _strptime\n        return _strptime._strptime_datetime(cls, date_string, format)\n\n    def utcoffset(self):\n        \"\"\"Return the timezone offset as timedelta positive east of UTC (negative west of\n        UTC).\"\"\"\n        if self._tzinfo is None:\n            return None\n        offset = self._tzinfo.utcoffset(self)\n        _check_utc_offset(\"utcoffset\", offset)\n        return offset\n\n    def tzname(self):\n        \"\"\"Return the timezone name.\n\n        Note that the name is 100% informational -- there's no requirement that\n        it mean anything in particular. For example, \"GMT\", \"UTC\", \"-500\",\n        \"-5:00\", \"EDT\", \"US/Eastern\", \"America/New York\" are all valid replies.\n        \"\"\"\n        if self._tzinfo is None:\n            return None\n        name = self._tzinfo.tzname(self)\n        _check_tzname(name)\n        return name\n\n    def dst(self):\n        \"\"\"Return 0 if DST is not in effect, or the DST offset (as timedelta\n        positive eastward) if DST is in effect.\n\n        This is purely informational; the DST offset has already been added to\n        the UTC offset returned by utcoffset() if applicable, so there's no\n        need to consult dst() unless you're interested in displaying the DST\n        info.\n        \"\"\"\n        if self._tzinfo is None:\n            return None\n        offset = self._tzinfo.dst(self)\n        _check_utc_offset(\"dst\", offset)\n        return offset\n\n    # Comparisons of datetime objects with other.\n\n    def __eq__(self, other):\n        if isinstance(other, datetime):\n            return self._cmp(other, allow_mixed=True) == 0\n        elif not isinstance(other, date):\n            return NotImplemented\n        else:\n            return False\n\n    def __le__(self, other):\n        if isinstance(other, datetime):\n            return self._cmp(other) <= 0\n        elif not isinstance(other, date):\n            return NotImplemented\n        else:\n            _cmperror(self, other)\n\n    def __lt__(self, other):\n        if isinstance(other, datetime):\n            return self._cmp(other) < 0\n        elif not isinstance(other, date):\n            return NotImplemented\n        else:\n            _cmperror(self, other)\n\n    def __ge__(self, other):\n        if isinstance(other, datetime):\n            return self._cmp(other) >= 0\n        elif not isinstance(other, date):\n            return NotImplemented\n        else:\n            _cmperror(self, other)\n\n    def __gt__(self, other):\n        if isinstance(other, datetime):\n            return self._cmp(other) > 0\n        elif not isinstance(other, date):\n            return NotImplemented\n        else:\n            _cmperror(self, other)\n\n    def _cmp(self, other, allow_mixed=False):\n        assert isinstance(other, datetime)\n        mytz = self._tzinfo\n        ottz = other._tzinfo\n        myoff = otoff = None\n\n        if mytz is ottz:\n            base_compare = True\n        else:\n            myoff = self.utcoffset()\n            otoff = other.utcoffset()\n            # Assume that allow_mixed means that we are called from __eq__\n            if allow_mixed:\n                if myoff != self.replace(fold=not self.fold).utcoffset():\n                    return 2\n                if otoff != other.replace(fold=not other.fold).utcoffset():\n                    return 2\n            base_compare = myoff == otoff\n\n        if base_compare:\n            return _cmp((self._year, self._month, self._day,\n                         self._hour, self._minute, self._second,\n                         self._microsecond),\n                        (other._year, other._month, other._day,\n                         other._hour, other._minute, other._second,\n                         other._microsecond))\n        if myoff is None or otoff is None:\n            if allow_mixed:\n                return 2 # arbitrary non-zero value\n            else:\n                raise TypeError(\"cannot compare naive and aware datetimes\")\n        # XXX What follows could be done more efficiently...\n        diff = self - other     # this will take offsets into account\n        if diff.days < 0:\n            return -1\n        return diff and 1 or 0\n\n    def __add__(self, other):\n        \"Add a datetime and a timedelta.\"\n        if not isinstance(other, timedelta):\n            return NotImplemented\n        delta = timedelta(self.toordinal(),\n                          hours=self._hour,\n                          minutes=self._minute,\n                          seconds=self._second,\n                          microseconds=self._microsecond)\n        delta += other\n        hour, rem = divmod(delta.seconds, 3600)\n        minute, second = divmod(rem, 60)\n        if 0 < delta.days <= _MAXORDINAL:\n            return type(self).combine(date.fromordinal(delta.days),\n                                      time(hour, minute, second,\n                                           delta.microseconds,\n                                           tzinfo=self._tzinfo))\n        raise OverflowError(\"result out of range\")\n\n    __radd__ = __add__\n\n    def __sub__(self, other):\n        \"Subtract two datetimes, or a datetime and a timedelta.\"\n        if not isinstance(other, datetime):\n            if isinstance(other, timedelta):\n                return self + -other\n            return NotImplemented\n\n        days1 = self.toordinal()\n        days2 = other.toordinal()\n        secs1 = self._second + self._minute * 60 + self._hour * 3600\n        secs2 = other._second + other._minute * 60 + other._hour * 3600\n        base = timedelta(days1 - days2,\n                         secs1 - secs2,\n                         self._microsecond - other._microsecond)\n        if self._tzinfo is other._tzinfo:\n            return base\n        myoff = self.utcoffset()\n        otoff = other.utcoffset()\n        if myoff == otoff:\n            return base\n        if myoff is None or otoff is None:\n            raise TypeError(\"cannot mix naive and timezone-aware time\")\n        return base + otoff - myoff\n\n    def __hash__(self):\n        if self._hashcode == -1:\n            if self.fold:\n                t = self.replace(fold=0)\n            else:\n                t = self\n            tzoff = t.utcoffset()\n            if tzoff is None:\n                self._hashcode = hash(t._getstate()[0])\n            else:\n                days = _ymd2ord(self.year, self.month, self.day)\n                seconds = self.hour * 3600 + self.minute * 60 + self.second\n                self._hashcode = hash(timedelta(days, seconds, self.microsecond) - tzoff)\n        return self._hashcode\n\n    # Pickle support.\n\n    def _getstate(self, protocol=3):\n        yhi, ylo = divmod(self._year, 256)\n        us2, us3 = divmod(self._microsecond, 256)\n        us1, us2 = divmod(us2, 256)\n        m = self._month\n        if self._fold and protocol > 3:\n            m += 128\n        basestate = bytes([yhi, ylo, m, self._day,\n                           self._hour, self._minute, self._second,\n                           us1, us2, us3])\n        if self._tzinfo is None:\n            return (basestate,)\n        else:\n            return (basestate, self._tzinfo)\n\n    def __setstate(self, string, tzinfo):\n        if tzinfo is not None and not isinstance(tzinfo, _tzinfo_class):\n            raise TypeError(\"bad tzinfo state arg\")\n        (yhi, ylo, m, self._day, self._hour,\n         self._minute, self._second, us1, us2, us3) = string\n        if m > 127:\n            self._fold = 1\n            self._month = m - 128\n        else:\n            self._fold = 0\n            self._month = m\n        self._year = yhi * 256 + ylo\n        self._microsecond = (((us1 << 8) | us2) << 8) | us3\n        self._tzinfo = tzinfo\n\n    def __reduce_ex__(self, protocol):\n        return (self.__class__, self._getstate(protocol))\n\n    def __reduce__(self):\n        return self.__reduce_ex__(2)\n"
    },
    {
      "type": "class",
      "qualified_name": "pytz.reference.timedelta",
      "module": "pytz.reference",
      "signature": "(self, /, *args, **kwargs)",
      "return_description": null,
      "raises": [],
      "decorators": [
        "property",
        "property",
        "property"
      ],
      "examples": [],
      "docstring": "Difference between two datetime values.\n\ntimedelta(days=0, seconds=0, microseconds=0, milliseconds=0, minutes=0, hours=0, weeks=0)\n\nAll arguments are optional and default to 0.\nArguments may be integers or floats, and may be positive or negative.",
      "source_code": "class timedelta:\n    \"\"\"Represent the difference between two datetime objects.\n\n    Supported operators:\n\n    - add, subtract timedelta\n    - unary plus, minus, abs\n    - compare to timedelta\n    - multiply, divide by int\n\n    In addition, datetime supports subtraction of two datetime objects\n    returning a timedelta, and addition or subtraction of a datetime\n    and a timedelta giving a datetime.\n\n    Representation: (days, seconds, microseconds).  Why?  Because I\n    felt like it.\n    \"\"\"\n    __slots__ = '_days', '_seconds', '_microseconds', '_hashcode'\n\n    def __new__(cls, days=0, seconds=0, microseconds=0,\n                milliseconds=0, minutes=0, hours=0, weeks=0):\n        # Doing this efficiently and accurately in C is going to be difficult\n        # and error-prone, due to ubiquitous overflow possibilities, and that\n        # C double doesn't have enough bits of precision to represent\n        # microseconds over 10K years faithfully.  The code here tries to make\n        # explicit where go-fast assumptions can be relied on, in order to\n        # guide the C implementation; it's way more convoluted than speed-\n        # ignoring auto-overflow-to-long idiomatic Python could be.\n\n        # XXX Check that all inputs are ints or floats.\n\n        # Final values, all integer.\n        # s and us fit in 32-bit signed ints; d isn't bounded.\n        d = s = us = 0\n\n        # Normalize everything to days, seconds, microseconds.\n        days += weeks*7\n        seconds += minutes*60 + hours*3600\n        microseconds += milliseconds*1000\n\n        # Get rid of all fractions, and normalize s and us.\n        # Take a deep breath <wink>.\n        if isinstance(days, float):\n            dayfrac, days = _math.modf(days)\n            daysecondsfrac, daysecondswhole = _math.modf(dayfrac * (24.*3600.))\n            assert daysecondswhole == int(daysecondswhole)  # can't overflow\n            s = int(daysecondswhole)\n            assert days == int(days)\n            d = int(days)\n        else:\n            daysecondsfrac = 0.0\n            d = days\n        assert isinstance(daysecondsfrac, float)\n        assert abs(daysecondsfrac) <= 1.0\n        assert isinstance(d, int)\n        assert abs(s) <= 24 * 3600\n        # days isn't referenced again before redefinition\n\n        if isinstance(seconds, float):\n            secondsfrac, seconds = _math.modf(seconds)\n            assert seconds == int(seconds)\n            seconds = int(seconds)\n            secondsfrac += daysecondsfrac\n            assert abs(secondsfrac) <= 2.0\n        else:\n            secondsfrac = daysecondsfrac\n        # daysecondsfrac isn't referenced again\n        assert isinstance(secondsfrac, float)\n        assert abs(secondsfrac) <= 2.0\n\n        assert isinstance(seconds, int)\n        days, seconds = divmod(seconds, 24*3600)\n        d += days\n        s += int(seconds)    # can't overflow\n        assert isinstance(s, int)\n        assert abs(s) <= 2 * 24 * 3600\n        # seconds isn't referenced again before redefinition\n\n        usdouble = secondsfrac * 1e6\n        assert abs(usdouble) < 2.1e6    # exact value not critical\n        # secondsfrac isn't referenced again\n\n        if isinstance(microseconds, float):\n            microseconds = round(microseconds + usdouble)\n            seconds, microseconds = divmod(microseconds, 1000000)\n            days, seconds = divmod(seconds, 24*3600)\n            d += days\n            s += seconds\n        else:\n            microseconds = int(microseconds)\n            seconds, microseconds = divmod(microseconds, 1000000)\n            days, seconds = divmod(seconds, 24*3600)\n            d += days\n            s += seconds\n            microseconds = round(microseconds + usdouble)\n        assert isinstance(s, int)\n        assert isinstance(microseconds, int)\n        assert abs(s) <= 3 * 24 * 3600\n        assert abs(microseconds) < 3.1e6\n\n        # Just a little bit of carrying possible for microseconds and seconds.\n        seconds, us = divmod(microseconds, 1000000)\n        s += seconds\n        days, s = divmod(s, 24*3600)\n        d += days\n\n        assert isinstance(d, int)\n        assert isinstance(s, int) and 0 <= s < 24*3600\n        assert isinstance(us, int) and 0 <= us < 1000000\n\n        if abs(d) > 999999999:\n            raise OverflowError(\"timedelta # of days is too large: %d\" % d)\n\n        self = object.__new__(cls)\n        self._days = d\n        self._seconds = s\n        self._microseconds = us\n        self._hashcode = -1\n        return self\n\n    def __repr__(self):\n        args = []\n        if self._days:\n            args.append(\"days=%d\" % self._days)\n        if self._seconds:\n            args.append(\"seconds=%d\" % self._seconds)\n        if self._microseconds:\n            args.append(\"microseconds=%d\" % self._microseconds)\n        if not args:\n            args.append('0')\n        return \"%s.%s(%s)\" % (self.__class__.__module__,\n                              self.__class__.__qualname__,\n                              ', '.join(args))\n\n    def __str__(self):\n        mm, ss = divmod(self._seconds, 60)\n        hh, mm = divmod(mm, 60)\n        s = \"%d:%02d:%02d\" % (hh, mm, ss)\n        if self._days:\n            def plural(n):\n                return n, abs(n) != 1 and \"s\" or \"\"\n            s = (\"%d day%s, \" % plural(self._days)) + s\n        if self._microseconds:\n            s = s + \".%06d\" % self._microseconds\n        return s\n\n    def total_seconds(self):\n        \"\"\"Total seconds in the duration.\"\"\"\n        return ((self.days * 86400 + self.seconds) * 10**6 +\n                self.microseconds) / 10**6\n\n    # Read-only field accessors\n    @property\n    def days(self):\n        \"\"\"days\"\"\"\n        return self._days\n\n    @property\n    def seconds(self):\n        \"\"\"seconds\"\"\"\n        return self._seconds\n\n    @property\n    def microseconds(self):\n        \"\"\"microseconds\"\"\"\n        return self._microseconds\n\n    def __add__(self, other):\n        if isinstance(other, timedelta):\n            # for CPython compatibility, we cannot use\n            # our __class__ here, but need a real timedelta\n            return timedelta(self._days + other._days,\n                             self._seconds + other._seconds,\n                             self._microseconds + other._microseconds)\n        return NotImplemented\n\n    __radd__ = __add__\n\n    def __sub__(self, other):\n        if isinstance(other, timedelta):\n            # for CPython compatibility, we cannot use\n            # our __class__ here, but need a real timedelta\n            return timedelta(self._days - other._days,\n                             self._seconds - other._seconds,\n                             self._microseconds - other._microseconds)\n        return NotImplemented\n\n    def __rsub__(self, other):\n        if isinstance(other, timedelta):\n            return -self + other\n        return NotImplemented\n\n    def __neg__(self):\n        # for CPython compatibility, we cannot use\n        # our __class__ here, but need a real timedelta\n        return timedelta(-self._days,\n                         -self._seconds,\n                         -self._microseconds)\n\n    def __pos__(self):\n        return self\n\n    def __abs__(self):\n        if self._days < 0:\n            return -self\n        else:\n            return self\n\n    def __mul__(self, other):\n        if isinstance(other, int):\n            # for CPython compatibility, we cannot use\n            # our __class__ here, but need a real timedelta\n            return timedelta(self._days * other,\n                             self._seconds * other,\n                             self._microseconds * other)\n        if isinstance(other, float):\n            usec = self._to_microseconds()\n            a, b = other.as_integer_ratio()\n            return timedelta(0, 0, _divide_and_round(usec * a, b))\n        return NotImplemented\n\n    __rmul__ = __mul__\n\n    def _to_microseconds(self):\n        return ((self._days * (24*3600) + self._seconds) * 1000000 +\n                self._microseconds)\n\n    def __floordiv__(self, other):\n        if not isinstance(other, (int, timedelta)):\n            return NotImplemented\n        usec = self._to_microseconds()\n        if isinstance(other, timedelta):\n            return usec // other._to_microseconds()\n        if isinstance(other, int):\n            return timedelta(0, 0, usec // other)\n\n    def __truediv__(self, other):\n        if not isinstance(other, (int, float, timedelta)):\n            return NotImplemented\n        usec = self._to_microseconds()\n        if isinstance(other, timedelta):\n            return usec / other._to_microseconds()\n        if isinstance(other, int):\n            return timedelta(0, 0, _divide_and_round(usec, other))\n        if isinstance(other, float):\n            a, b = other.as_integer_ratio()\n            return timedelta(0, 0, _divide_and_round(b * usec, a))\n\n    def __mod__(self, other):\n        if isinstance(other, timedelta):\n            r = self._to_microseconds() % other._to_microseconds()\n            return timedelta(0, 0, r)\n        return NotImplemented\n\n    def __divmod__(self, other):\n        if isinstance(other, timedelta):\n            q, r = divmod(self._to_microseconds(),\n                          other._to_microseconds())\n            return q, timedelta(0, 0, r)\n        return NotImplemented\n\n    # Comparisons of timedelta objects with other.\n\n    def __eq__(self, other):\n        if isinstance(other, timedelta):\n            return self._cmp(other) == 0\n        else:\n            return NotImplemented\n\n    def __le__(self, other):\n        if isinstance(other, timedelta):\n            return self._cmp(other) <= 0\n        else:\n            return NotImplemented\n\n    def __lt__(self, other):\n        if isinstance(other, timedelta):\n            return self._cmp(other) < 0\n        else:\n            return NotImplemented\n\n    def __ge__(self, other):\n        if isinstance(other, timedelta):\n            return self._cmp(other) >= 0\n        else:\n            return NotImplemented\n\n    def __gt__(self, other):\n        if isinstance(other, timedelta):\n            return self._cmp(other) > 0\n        else:\n            return NotImplemented\n\n    def _cmp(self, other):\n        assert isinstance(other, timedelta)\n        return _cmp(self._getstate(), other._getstate())\n\n    def __hash__(self):\n        if self._hashcode == -1:\n            self._hashcode = hash(self._getstate())\n        return self._hashcode\n\n    def __bool__(self):\n        return (self._days != 0 or\n                self._seconds != 0 or\n                self._microseconds != 0)\n\n    # Pickle support.\n\n    def _getstate(self):\n        return (self._days, self._seconds, self._microseconds)\n\n    def __reduce__(self):\n        return (self.__class__, self._getstate())\n"
    },
    {
      "type": "class",
      "qualified_name": "pytz.reference.tzinfo",
      "module": "pytz.reference",
      "signature": "(self, /, *args, **kwargs)",
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Abstract base class for time zone info objects.",
      "source_code": "class tzinfo:\n    \"\"\"Abstract base class for time zone info classes.\n\n    Subclasses must override the name(), utcoffset() and dst() methods.\n    \"\"\"\n    __slots__ = ()\n\n    def tzname(self, dt):\n        \"datetime -> string name of time zone.\"\n        raise NotImplementedError(\"tzinfo subclass must override tzname()\")\n\n    def utcoffset(self, dt):\n        \"datetime -> timedelta, positive for east of UTC, negative for west of UTC\"\n        raise NotImplementedError(\"tzinfo subclass must override utcoffset()\")\n\n    def dst(self, dt):\n        \"\"\"datetime -> DST offset as timedelta, positive for east of UTC.\n\n        Return 0 if DST not in effect.  utcoffset() must include the DST\n        offset.\n        \"\"\"\n        raise NotImplementedError(\"tzinfo subclass must override dst()\")\n\n    def fromutc(self, dt):\n        \"datetime in UTC -> datetime in local time.\"\n\n        if not isinstance(dt, datetime):\n            raise TypeError(\"fromutc() requires a datetime argument\")\n        if dt.tzinfo is not self:\n            raise ValueError(\"dt.tzinfo is not self\")\n\n        dtoff = dt.utcoffset()\n        if dtoff is None:\n            raise ValueError(\"fromutc() requires a non-None utcoffset() \"\n                             \"result\")\n\n        # See the long comment block at the end of this file for an\n        # explanation of this algorithm.\n        dtdst = dt.dst()\n        if dtdst is None:\n            raise ValueError(\"fromutc() requires a non-None dst() result\")\n        delta = dtoff - dtdst\n        if delta:\n            dt += delta\n            dtdst = dt.dst()\n            if dtdst is None:\n                raise ValueError(\"fromutc(): dt.dst gave inconsistent \"\n                                 \"results; cannot convert\")\n        return dt + dtdst\n\n    # Pickle support.\n\n    def __reduce__(self):\n        getinitargs = getattr(self, \"__getinitargs__\", None)\n        if getinitargs:\n            args = getinitargs()\n        else:\n            args = ()\n        return (self.__class__, args, self.__getstate__())\n"
    },
    {
      "type": "class",
      "qualified_name": "pytz.tzfile.DstTzInfo",
      "module": "pytz.tzfile",
      "signature": "(self, _inf=None, _tzinfos=None)",
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "A timezone that has a variable offset from UTC\n\nThe offset might change if daylight saving time comes into effect,\nor at a point in history when the region decides to change their\ntimezone definition.",
      "source_code": "class DstTzInfo(BaseTzInfo):\n    '''A timezone that has a variable offset from UTC\n\n    The offset might change if daylight saving time comes into effect,\n    or at a point in history when the region decides to change their\n    timezone definition.\n    '''\n    # Overridden in subclass\n\n    # Sorted list of DST transition times, UTC\n    _utc_transition_times = None\n\n    # [(utcoffset, dstoffset, tzname)] corresponding to\n    # _utc_transition_times entries\n    _transition_info = None\n\n    zone = None\n\n    # Set in __init__\n\n    _tzinfos = None\n    _dst = None  # DST offset\n\n    def __init__(self, _inf=None, _tzinfos=None):\n        if _inf:\n            self._tzinfos = _tzinfos\n            self._utcoffset, self._dst, self._tzname = _inf\n        else:\n            _tzinfos = {}\n            self._tzinfos = _tzinfos\n            self._utcoffset, self._dst, self._tzname = (\n                self._transition_info[0])\n            _tzinfos[self._transition_info[0]] = self\n            for inf in self._transition_info[1:]:\n                if inf not in _tzinfos:\n                    _tzinfos[inf] = self.__class__(inf, _tzinfos)\n\n    def fromutc(self, dt):\n        '''See datetime.tzinfo.fromutc'''\n        if (dt.tzinfo is not None and\n                getattr(dt.tzinfo, '_tzinfos', None) is not self._tzinfos):\n            raise ValueError('fromutc: dt.tzinfo is not self')\n        dt = dt.replace(tzinfo=None)\n        idx = max(0, bisect_right(self._utc_transition_times, dt) - 1)\n        inf = self._transition_info[idx]\n        return (dt + inf[0]).replace(tzinfo=self._tzinfos[inf])\n\n    def normalize(self, dt):\n        '''Correct the timezone information on the given datetime\n\n        If date arithmetic crosses DST boundaries, the tzinfo\n        is not magically adjusted. This method normalizes the\n        tzinfo to the correct one.\n\n        To test, first we need to do some setup\n\n        >>> from pytz import timezone\n        >>> utc = timezone('UTC')\n        >>> eastern = timezone('US/Eastern')\n        >>> fmt = '%Y-%m-%d %H:%M:%S %Z (%z)'\n\n        We next create a datetime right on an end-of-DST transition point,\n        the instant when the wallclocks are wound back one hour.\n\n        >>> utc_dt = datetime(2002, 10, 27, 6, 0, 0, tzinfo=utc)\n        >>> loc_dt = utc_dt.astimezone(eastern)\n        >>> loc_dt.strftime(fmt)\n        '2002-10-27 01:00:00 EST (-0500)'\n\n        Now, if we subtract a few minutes from it, note that the timezone\n        information has not changed.\n\n        >>> before = loc_dt - timedelta(minutes=10)\n        >>> before.strftime(fmt)\n        '2002-10-27 00:50:00 EST (-0500)'\n\n        But we can fix that by calling the normalize method\n\n        >>> before = eastern.normalize(before)\n        >>> before.strftime(fmt)\n        '2002-10-27 01:50:00 EDT (-0400)'\n\n        The supported method of converting between timezones is to use\n        datetime.astimezone(). Currently, normalize() also works:\n\n        >>> th = timezone('Asia/Bangkok')\n        >>> am = timezone('Europe/Amsterdam')\n        >>> dt = th.localize(datetime(2011, 5, 7, 1, 2, 3))\n        >>> fmt = '%Y-%m-%d %H:%M:%S %Z (%z)'\n        >>> am.normalize(dt).strftime(fmt)\n        '2011-05-06 20:02:03 CEST (+0200)'\n        '''\n        if dt.tzinfo is None:\n            raise ValueError('Naive time - no tzinfo set')\n\n        # Convert dt in localtime to UTC\n        offset = dt.tzinfo._utcoffset\n        dt = dt.replace(tzinfo=None)\n        dt = dt - offset\n        # convert it back, and return it\n        return self.fromutc(dt)\n\n    def localize(self, dt, is_dst=False):\n        '''Convert naive time to local time.\n\n        This method should be used to construct localtimes, rather\n        than passing a tzinfo argument to a datetime constructor.\n\n        is_dst is used to determine the correct timezone in the ambigous\n        period at the end of daylight saving time.\n\n        >>> from pytz import timezone\n        >>> fmt = '%Y-%m-%d %H:%M:%S %Z (%z)'\n        >>> amdam = timezone('Europe/Amsterdam')\n        >>> dt  = datetime(2004, 10, 31, 2, 0, 0)\n        >>> loc_dt1 = amdam.localize(dt, is_dst=True)\n        >>> loc_dt2 = amdam.localize(dt, is_dst=False)\n        >>> loc_dt1.strftime(fmt)\n        '2004-10-31 02:00:00 CEST (+0200)'\n        >>> loc_dt2.strftime(fmt)\n        '2004-10-31 02:00:00 CET (+0100)'\n        >>> str(loc_dt2 - loc_dt1)\n        '1:00:00'\n\n        Use is_dst=None to raise an AmbiguousTimeError for ambiguous\n        times at the end of daylight saving time\n\n        >>> try:\n        ...     loc_dt1 = amdam.localize(dt, is_dst=None)\n        ... except AmbiguousTimeError:\n        ...     print('Ambiguous')\n        Ambiguous\n\n        is_dst defaults to False\n\n        >>> amdam.localize(dt) == amdam.localize(dt, False)\n        True\n\n        is_dst is also used to determine the correct timezone in the\n        wallclock times jumped over at the start of daylight saving time.\n\n        >>> pacific = timezone('US/Pacific')\n        >>> dt = datetime(2008, 3, 9, 2, 0, 0)\n        >>> ploc_dt1 = pacific.localize(dt, is_dst=True)\n        >>> ploc_dt2 = pacific.localize(dt, is_dst=False)\n        >>> ploc_dt1.strftime(fmt)\n        '2008-03-09 02:00:00 PDT (-0700)'\n        >>> ploc_dt2.strftime(fmt)\n        '2008-03-09 02:00:00 PST (-0800)'\n        >>> str(ploc_dt2 - ploc_dt1)\n        '1:00:00'\n\n        Use is_dst=None to raise a NonExistentTimeError for these skipped\n        times.\n\n        >>> try:\n        ...     loc_dt1 = pacific.localize(dt, is_dst=None)\n        ... except NonExistentTimeError:\n        ...     print('Non-existent')\n        Non-existent\n        '''\n        if dt.tzinfo is not None:\n            raise ValueError('Not naive datetime (tzinfo is already set)')\n\n        # Find the two best possibilities.\n        possible_loc_dt = set()\n        for delta in [timedelta(days=-1), timedelta(days=1)]:\n            loc_dt = dt + delta\n            idx = max(0, bisect_right(\n                self._utc_transition_times, loc_dt) - 1)\n            inf = self._transition_info[idx]\n            tzinfo = self._tzinfos[inf]\n            loc_dt = tzinfo.normalize(dt.replace(tzinfo=tzinfo))\n            if loc_dt.replace(tzinfo=None) == dt:\n                possible_loc_dt.add(loc_dt)\n\n        if len(possible_loc_dt) == 1:\n            return possible_loc_dt.pop()\n\n        # If there are no possibly correct timezones, we are attempting\n        # to convert a time that never happened - the time period jumped\n        # during the start-of-DST transition period.\n        if len(possible_loc_dt) == 0:\n            # If we refuse to guess, raise an exception.\n            if is_dst is None:\n                raise NonExistentTimeError(dt)\n\n            # If we are forcing the pre-DST side of the DST transition, we\n            # obtain the correct timezone by winding the clock forward a few\n            # hours.\n            elif is_dst:\n                return self.localize(\n                    dt + timedelta(hours=6), is_dst=True) - timedelta(hours=6)\n\n            # If we are forcing the post-DST side of the DST transition, we\n            # obtain the correct timezone by winding the clock back.\n            else:\n                return self.localize(\n                    dt - timedelta(hours=6),\n                    is_dst=False) + timedelta(hours=6)\n\n        # If we get this far, we have multiple possible timezones - this\n        # is an ambiguous case occurring during the end-of-DST transition.\n\n        # If told to be strict, raise an exception since we have an\n        # ambiguous case\n        if is_dst is None:\n            raise AmbiguousTimeError(dt)\n\n        # Filter out the possiblilities that don't match the requested\n        # is_dst\n        filtered_possible_loc_dt = [\n            p for p in possible_loc_dt if bool(p.tzinfo._dst) == is_dst\n        ]\n\n        # Hopefully we only have one possibility left. Return it.\n        if len(filtered_possible_loc_dt) == 1:\n            return filtered_possible_loc_dt[0]\n\n        if len(filtered_possible_loc_dt) == 0:\n            filtered_possible_loc_dt = list(possible_loc_dt)\n\n        # If we get this far, we have in a wierd timezone transition\n        # where the clocks have been wound back but is_dst is the same\n        # in both (eg. Europe/Warsaw 1915 when they switched to CET).\n        # At this point, we just have to guess unless we allow more\n        # hints to be passed in (such as the UTC offset or abbreviation),\n        # but that is just getting silly.\n        #\n        # Choose the earliest (by UTC) applicable timezone if is_dst=True\n        # Choose the latest (by UTC) applicable timezone if is_dst=False\n        # i.e., behave like end-of-DST transition\n        dates = {}  # utc -> local\n        for local_dt in filtered_possible_loc_dt:\n            utc_time = (\n                local_dt.replace(tzinfo=None) - local_dt.tzinfo._utcoffset)\n            assert utc_time not in dates\n            dates[utc_time] = local_dt\n        return dates[[min, max][not is_dst](dates)]\n\n    def utcoffset(self, dt, is_dst=None):\n        '''See datetime.tzinfo.utcoffset\n\n        The is_dst parameter may be used to remove ambiguity during DST\n        transitions.\n\n        >>> from pytz import timezone\n        >>> tz = timezone('America/St_Johns')\n        >>> ambiguous = datetime(2009, 10, 31, 23, 30)\n\n        >>> str(tz.utcoffset(ambiguous, is_dst=False))\n        '-1 day, 20:30:00'\n\n        >>> str(tz.utcoffset(ambiguous, is_dst=True))\n        '-1 day, 21:30:00'\n\n        >>> try:\n        ...     tz.utcoffset(ambiguous)\n        ... except AmbiguousTimeError:\n        ...     print('Ambiguous')\n        Ambiguous\n\n        '''\n        if dt is None:\n            return None\n        elif dt.tzinfo is not self:\n            dt = self.localize(dt, is_dst)\n            return dt.tzinfo._utcoffset\n        else:\n            return self._utcoffset\n\n    def dst(self, dt, is_dst=None):\n        '''See datetime.tzinfo.dst\n\n        The is_dst parameter may be used to remove ambiguity during DST\n        transitions.\n\n        >>> from pytz import timezone\n        >>> tz = timezone('America/St_Johns')\n\n        >>> normal = datetime(2009, 9, 1)\n\n        >>> str(tz.dst(normal))\n        '1:00:00'\n        >>> str(tz.dst(normal, is_dst=False))\n        '1:00:00'\n        >>> str(tz.dst(normal, is_dst=True))\n        '1:00:00'\n\n        >>> ambiguous = datetime(2009, 10, 31, 23, 30)\n\n        >>> str(tz.dst(ambiguous, is_dst=False))\n        '0:00:00'\n        >>> str(tz.dst(ambiguous, is_dst=True))\n        '1:00:00'\n        >>> try:\n        ...     tz.dst(ambiguous)\n        ... except AmbiguousTimeError:\n        ...     print('Ambiguous')\n        Ambiguous\n\n        '''\n        if dt is None:\n            return None\n        elif dt.tzinfo is not self:\n            dt = self.localize(dt, is_dst)\n            return dt.tzinfo._dst\n        else:\n            return self._dst\n\n    def tzname(self, dt, is_dst=None):\n        '''See datetime.tzinfo.tzname\n\n        The is_dst parameter may be used to remove ambiguity during DST\n        transitions.\n\n        >>> from pytz import timezone\n        >>> tz = timezone('America/St_Johns')\n\n        >>> normal = datetime(2009, 9, 1)\n\n        >>> tz.tzname(normal)\n        'NDT'\n        >>> tz.tzname(normal, is_dst=False)\n        'NDT'\n        >>> tz.tzname(normal, is_dst=True)\n        'NDT'\n\n        >>> ambiguous = datetime(2009, 10, 31, 23, 30)\n\n        >>> tz.tzname(ambiguous, is_dst=False)\n        'NST'\n        >>> tz.tzname(ambiguous, is_dst=True)\n        'NDT'\n        >>> try:\n        ...     tz.tzname(ambiguous)\n        ... except AmbiguousTimeError:\n        ...     print('Ambiguous')\n        Ambiguous\n        '''\n        if dt is None:\n            return self.zone\n        elif dt.tzinfo is not self:\n            dt = self.localize(dt, is_dst)\n            return dt.tzinfo._tzname\n        else:\n            return self._tzname\n\n    def __repr__(self):\n        if self._dst:\n            dst = 'DST'\n        else:\n            dst = 'STD'\n        if self._utcoffset > _notime:\n            return '<DstTzInfo %r %s+%s %s>' % (\n                self.zone, self._tzname, self._utcoffset, dst\n            )\n        else:\n            return '<DstTzInfo %r %s%s %s>' % (\n                self.zone, self._tzname, self._utcoffset, dst\n            )\n\n    def __reduce__(self):\n        # Special pickle to zone remains a singleton and to cope with\n        # database changes.\n        return pytz._p, (\n            self.zone,\n            _to_seconds(self._utcoffset),\n            _to_seconds(self._dst),\n            self._tzname\n        )\n"
    },
    {
      "type": "class",
      "qualified_name": "pytz.tzfile.StaticTzInfo",
      "module": "pytz.tzfile",
      "signature": "(self, /, *args, **kwargs)",
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "A timezone that has a constant offset from UTC\n\nThese timezones are rare, as most locations have changed their\noffset at some point in their history",
      "source_code": "class StaticTzInfo(BaseTzInfo):\n    '''A timezone that has a constant offset from UTC\n\n    These timezones are rare, as most locations have changed their\n    offset at some point in their history\n    '''\n    def fromutc(self, dt):\n        '''See datetime.tzinfo.fromutc'''\n        if dt.tzinfo is not None and dt.tzinfo is not self:\n            raise ValueError('fromutc: dt.tzinfo is not self')\n        return (dt + self._utcoffset).replace(tzinfo=self)\n\n    def utcoffset(self, dt, is_dst=None):\n        '''See datetime.tzinfo.utcoffset\n\n        is_dst is ignored for StaticTzInfo, and exists only to\n        retain compatibility with DstTzInfo.\n        '''\n        return self._utcoffset\n\n    def dst(self, dt, is_dst=None):\n        '''See datetime.tzinfo.dst\n\n        is_dst is ignored for StaticTzInfo, and exists only to\n        retain compatibility with DstTzInfo.\n        '''\n        return _notime\n\n    def tzname(self, dt, is_dst=None):\n        '''See datetime.tzinfo.tzname\n\n        is_dst is ignored for StaticTzInfo, and exists only to\n        retain compatibility with DstTzInfo.\n        '''\n        return self._tzname\n\n    def localize(self, dt, is_dst=False):\n        '''Convert naive time to local time'''\n        if dt.tzinfo is not None:\n            raise ValueError('Not naive datetime (tzinfo is already set)')\n        return dt.replace(tzinfo=self)\n\n    def normalize(self, dt, is_dst=False):\n        '''Correct the timezone information on the given datetime.\n\n        This is normally a no-op, as StaticTzInfo timezones never have\n        ambiguous cases to correct:\n\n        >>> from pytz import timezone\n        >>> gmt = timezone('GMT')\n        >>> isinstance(gmt, StaticTzInfo)\n        True\n        >>> dt = datetime(2011, 5, 8, 1, 2, 3, tzinfo=gmt)\n        >>> gmt.normalize(dt) is dt\n        True\n\n        The supported method of converting between timezones is to use\n        datetime.astimezone(). Currently normalize() also works:\n\n        >>> la = timezone('America/Los_Angeles')\n        >>> dt = la.localize(datetime(2011, 5, 7, 1, 2, 3))\n        >>> fmt = '%Y-%m-%d %H:%M:%S %Z (%z)'\n        >>> gmt.normalize(dt).strftime(fmt)\n        '2011-05-07 08:02:03 GMT (+0000)'\n        '''\n        if dt.tzinfo is self:\n            return dt\n        if dt.tzinfo is None:\n            raise ValueError('Naive time - no tzinfo set')\n        return dt.astimezone(self)\n\n    def __repr__(self):\n        return '<StaticTzInfo %r>' % (self.zone,)\n\n    def __reduce__(self):\n        # Special pickle to zone remains a singleton and to cope with\n        # database changes.\n        return pytz._p, (self.zone,)\n"
    },
    {
      "type": "class",
      "qualified_name": "pytz.tzfile.datetime",
      "module": "pytz.tzfile",
      "signature": "(self, /, *args, **kwargs)",
      "return_description": null,
      "raises": [],
      "decorators": [
        "property",
        "property",
        "property",
        "property",
        "property",
        "property",
        "classmethod",
        "classmethod",
        "classmethod",
        "classmethod",
        "classmethod",
        "classmethod",
        "classmethod",
        "classmethod"
      ],
      "examples": [],
      "docstring": "datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]])\n\nThe year, month and day arguments are required. tzinfo may be None, or an\ninstance of a tzinfo subclass. The remaining arguments may be ints.",
      "source_code": "class datetime(date):\n    \"\"\"datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]])\n\n    The year, month and day arguments are required. tzinfo may be None, or an\n    instance of a tzinfo subclass. The remaining arguments may be ints.\n    \"\"\"\n    __slots__ = date.__slots__ + time.__slots__\n\n    def __new__(cls, year, month=None, day=None, hour=0, minute=0, second=0,\n                microsecond=0, tzinfo=None, *, fold=0):\n        if (isinstance(year, (bytes, str)) and len(year) == 10 and\n            1 <= ord(year[2:3])&0x7F <= 12):\n            # Pickle support\n            if isinstance(year, str):\n                try:\n                    year = bytes(year, 'latin1')\n                except UnicodeEncodeError:\n                    # More informative error message.\n                    raise ValueError(\n                        \"Failed to encode latin1 string when unpickling \"\n                        \"a datetime object. \"\n                        \"pickle.load(data, encoding='latin1') is assumed.\")\n            self = object.__new__(cls)\n            self.__setstate(year, month)\n            self._hashcode = -1\n            return self\n        year, month, day = _check_date_fields(year, month, day)\n        hour, minute, second, microsecond, fold = _check_time_fields(\n            hour, minute, second, microsecond, fold)\n        _check_tzinfo_arg(tzinfo)\n        self = object.__new__(cls)\n        self._year = year\n        self._month = month\n        self._day = day\n        self._hour = hour\n        self._minute = minute\n        self._second = second\n        self._microsecond = microsecond\n        self._tzinfo = tzinfo\n        self._hashcode = -1\n        self._fold = fold\n        return self\n\n    # Read-only field accessors\n    @property\n    def hour(self):\n        \"\"\"hour (0-23)\"\"\"\n        return self._hour\n\n    @property\n    def minute(self):\n        \"\"\"minute (0-59)\"\"\"\n        return self._minute\n\n    @property\n    def second(self):\n        \"\"\"second (0-59)\"\"\"\n        return self._second\n\n    @property\n    def microsecond(self):\n        \"\"\"microsecond (0-999999)\"\"\"\n        return self._microsecond\n\n    @property\n    def tzinfo(self):\n        \"\"\"timezone info object\"\"\"\n        return self._tzinfo\n\n    @property\n    def fold(self):\n        return self._fold\n\n    @classmethod\n    def _fromtimestamp(cls, t, utc, tz):\n        \"\"\"Construct a datetime from a POSIX timestamp (like time.time()).\n\n        A timezone info object may be passed in as well.\n        \"\"\"\n        frac, t = _math.modf(t)\n        us = round(frac * 1e6)\n        if us >= 1000000:\n            t += 1\n            us -= 1000000\n        elif us < 0:\n            t -= 1\n            us += 1000000\n\n        converter = _time.gmtime if utc else _time.localtime\n        y, m, d, hh, mm, ss, weekday, jday, dst = converter(t)\n        ss = min(ss, 59)    # clamp out leap seconds if the platform has them\n        result = cls(y, m, d, hh, mm, ss, us, tz)\n        if tz is None and not utc:\n            # As of version 2015f max fold in IANA database is\n            # 23 hours at 1969-09-30 13:00:00 in Kwajalein.\n            # Let's probe 24 hours in the past to detect a transition:\n            max_fold_seconds = 24 * 3600\n\n            # On Windows localtime_s throws an OSError for negative values,\n            # thus we can't perform fold detection for values of time less\n            # than the max time fold. See comments in _datetimemodule's\n            # version of this method for more details.\n            if t < max_fold_seconds and sys.platform.startswith(\"win\"):\n                return result\n\n            y, m, d, hh, mm, ss = converter(t - max_fold_seconds)[:6]\n            probe1 = cls(y, m, d, hh, mm, ss, us, tz)\n            trans = result - probe1 - timedelta(0, max_fold_seconds)\n            if trans.days < 0:\n                y, m, d, hh, mm, ss = converter(t + trans // timedelta(0, 1))[:6]\n                probe2 = cls(y, m, d, hh, mm, ss, us, tz)\n                if probe2 == result:\n                    result._fold = 1\n        elif tz is not None:\n            result = tz.fromutc(result)\n        return result\n\n    @classmethod\n    def fromtimestamp(cls, t, tz=None):\n        \"\"\"Construct a datetime from a POSIX timestamp (like time.time()).\n\n        A timezone info object may be passed in as well.\n        \"\"\"\n        _check_tzinfo_arg(tz)\n\n        return cls._fromtimestamp(t, tz is not None, tz)\n\n    @classmethod\n    def utcfromtimestamp(cls, t):\n        \"\"\"Construct a naive UTC datetime from a POSIX timestamp.\"\"\"\n        return cls._fromtimestamp(t, True, None)\n\n    @classmethod\n    def now(cls, tz=None):\n        \"Construct a datetime from time.time() and optional time zone info.\"\n        t = _time.time()\n        return cls.fromtimestamp(t, tz)\n\n    @classmethod\n    def utcnow(cls):\n        \"Construct a UTC datetime from time.time().\"\n        t = _time.time()\n        return cls.utcfromtimestamp(t)\n\n    @classmethod\n    def combine(cls, date, time, tzinfo=True):\n        \"Construct a datetime from a given date and a given time.\"\n        if not isinstance(date, _date_class):\n            raise TypeError(\"date argument must be a date instance\")\n        if not isinstance(time, _time_class):\n            raise TypeError(\"time argument must be a time instance\")\n        if tzinfo is True:\n            tzinfo = time.tzinfo\n        return cls(date.year, date.month, date.day,\n                   time.hour, time.minute, time.second, time.microsecond,\n                   tzinfo, fold=time.fold)\n\n    @classmethod\n    def fromisoformat(cls, date_string):\n        \"\"\"Construct a datetime from a string in one of the ISO 8601 formats.\"\"\"\n        if not isinstance(date_string, str):\n            raise TypeError('fromisoformat: argument must be str')\n\n        if len(date_string) < 7:\n            raise ValueError(f'Invalid isoformat string: {date_string!r}')\n\n        # Split this at the separator\n        try:\n            separator_location = _find_isoformat_datetime_separator(date_string)\n            dstr = date_string[0:separator_location]\n            tstr = date_string[(separator_location+1):]\n\n            date_components = _parse_isoformat_date(dstr)\n        except ValueError:\n            raise ValueError(\n                f'Invalid isoformat string: {date_string!r}') from None\n\n        if tstr:\n            try:\n                time_components = _parse_isoformat_time(tstr)\n            except ValueError:\n                raise ValueError(\n                    f'Invalid isoformat string: {date_string!r}') from None\n        else:\n            time_components = [0, 0, 0, 0, None]\n\n        return cls(*(date_components + time_components))\n\n    def timetuple(self):\n        \"Return local time tuple compatible with time.localtime().\"\n        dst = self.dst()\n        if dst is None:\n            dst = -1\n        elif dst:\n            dst = 1\n        else:\n            dst = 0\n        return _build_struct_time(self.year, self.month, self.day,\n                                  self.hour, self.minute, self.second,\n                                  dst)\n\n    def _mktime(self):\n        \"\"\"Return integer POSIX timestamp.\"\"\"\n        epoch = datetime(1970, 1, 1)\n        max_fold_seconds = 24 * 3600\n        t = (self - epoch) // timedelta(0, 1)\n        def local(u):\n            y, m, d, hh, mm, ss = _time.localtime(u)[:6]\n            return (datetime(y, m, d, hh, mm, ss) - epoch) // timedelta(0, 1)\n\n        # Our goal is to solve t = local(u) for u.\n        a = local(t) - t\n        u1 = t - a\n        t1 = local(u1)\n        if t1 == t:\n            # We found one solution, but it may not be the one we need.\n            # Look for an earlier solution (if `fold` is 0), or a\n            # later one (if `fold` is 1).\n            u2 = u1 + (-max_fold_seconds, max_fold_seconds)[self.fold]\n            b = local(u2) - u2\n            if a == b:\n                return u1\n        else:\n            b = t1 - u1\n            assert a != b\n        u2 = t - b\n        t2 = local(u2)\n        if t2 == t:\n            return u2\n        if t1 == t:\n            return u1\n        # We have found both offsets a and b, but neither t - a nor t - b is\n        # a solution.  This means t is in the gap.\n        return (max, min)[self.fold](u1, u2)\n\n\n    def timestamp(self):\n        \"Return POSIX timestamp as float\"\n        if self._tzinfo is None:\n            s = self._mktime()\n            return s + self.microsecond / 1e6\n        else:\n            return (self - _EPOCH).total_seconds()\n\n    def utctimetuple(self):\n        \"Return UTC time tuple compatible with time.gmtime().\"\n        offset = self.utcoffset()\n        if offset:\n            self -= offset\n        y, m, d = self.year, self.month, self.day\n        hh, mm, ss = self.hour, self.minute, self.second\n        return _build_struct_time(y, m, d, hh, mm, ss, 0)\n\n    def date(self):\n        \"Return the date part.\"\n        return date(self._year, self._month, self._day)\n\n    def time(self):\n        \"Return the time part, with tzinfo None.\"\n        return time(self.hour, self.minute, self.second, self.microsecond, fold=self.fold)\n\n    def timetz(self):\n        \"Return the time part, with same tzinfo.\"\n        return time(self.hour, self.minute, self.second, self.microsecond,\n                    self._tzinfo, fold=self.fold)\n\n    def replace(self, year=None, month=None, day=None, hour=None,\n                minute=None, second=None, microsecond=None, tzinfo=True,\n                *, fold=None):\n        \"\"\"Return a new datetime with new values for the specified fields.\"\"\"\n        if year is None:\n            year = self.year\n        if month is None:\n            month = self.month\n        if day is None:\n            day = self.day\n        if hour is None:\n            hour = self.hour\n        if minute is None:\n            minute = self.minute\n        if second is None:\n            second = self.second\n        if microsecond is None:\n            microsecond = self.microsecond\n        if tzinfo is True:\n            tzinfo = self.tzinfo\n        if fold is None:\n            fold = self.fold\n        return type(self)(year, month, day, hour, minute, second,\n                          microsecond, tzinfo, fold=fold)\n\n    def _local_timezone(self):\n        if self.tzinfo is None:\n            ts = self._mktime()\n        else:\n            ts = (self - _EPOCH) // timedelta(seconds=1)\n        localtm = _time.localtime(ts)\n        local = datetime(*localtm[:6])\n        # Extract TZ data\n        gmtoff = localtm.tm_gmtoff\n        zone = localtm.tm_zone\n        return timezone(timedelta(seconds=gmtoff), zone)\n\n    def astimezone(self, tz=None):\n        if tz is None:\n            tz = self._local_timezone()\n        elif not isinstance(tz, tzinfo):\n            raise TypeError(\"tz argument must be an instance of tzinfo\")\n\n        mytz = self.tzinfo\n        if mytz is None:\n            mytz = self._local_timezone()\n            myoffset = mytz.utcoffset(self)\n        else:\n            myoffset = mytz.utcoffset(self)\n            if myoffset is None:\n                mytz = self.replace(tzinfo=None)._local_timezone()\n                myoffset = mytz.utcoffset(self)\n\n        if tz is mytz:\n            return self\n\n        # Convert self to UTC, and attach the new time zone object.\n        utc = (self - myoffset).replace(tzinfo=tz)\n\n        # Convert from UTC to tz's local time.\n        return tz.fromutc(utc)\n\n    # Ways to produce a string.\n\n    def ctime(self):\n        \"Return ctime() style string.\"\n        weekday = self.toordinal() % 7 or 7\n        return \"%s %s %2d %02d:%02d:%02d %04d\" % (\n            _DAYNAMES[weekday],\n            _MONTHNAMES[self._month],\n            self._day,\n            self._hour, self._minute, self._second,\n            self._year)\n\n    def isoformat(self, sep='T', timespec='auto'):\n        \"\"\"Return the time formatted according to ISO.\n\n        The full format looks like 'YYYY-MM-DD HH:MM:SS.mmmmmm'.\n        By default, the fractional part is omitted if self.microsecond == 0.\n\n        If self.tzinfo is not None, the UTC offset is also attached, giving\n        giving a full format of 'YYYY-MM-DD HH:MM:SS.mmmmmm+HH:MM'.\n\n        Optional argument sep specifies the separator between date and\n        time, default 'T'.\n\n        The optional argument timespec specifies the number of additional\n        terms of the time to include. Valid options are 'auto', 'hours',\n        'minutes', 'seconds', 'milliseconds' and 'microseconds'.\n        \"\"\"\n        s = (\"%04d-%02d-%02d%c\" % (self._year, self._month, self._day, sep) +\n             _format_time(self._hour, self._minute, self._second,\n                          self._microsecond, timespec))\n\n        off = self.utcoffset()\n        tz = _format_offset(off)\n        if tz:\n            s += tz\n\n        return s\n\n    def __repr__(self):\n        \"\"\"Convert to formal string, for repr().\"\"\"\n        L = [self._year, self._month, self._day,  # These are never zero\n             self._hour, self._minute, self._second, self._microsecond]\n        if L[-1] == 0:\n            del L[-1]\n        if L[-1] == 0:\n            del L[-1]\n        s = \"%s.%s(%s)\" % (self.__class__.__module__,\n                           self.__class__.__qualname__,\n                           \", \".join(map(str, L)))\n        if self._tzinfo is not None:\n            assert s[-1:] == \")\"\n            s = s[:-1] + \", tzinfo=%r\" % self._tzinfo + \")\"\n        if self._fold:\n            assert s[-1:] == \")\"\n            s = s[:-1] + \", fold=1)\"\n        return s\n\n    def __str__(self):\n        \"Convert to string, for str().\"\n        return self.isoformat(sep=' ')\n\n    @classmethod\n    def strptime(cls, date_string, format):\n        'string, format -> new datetime parsed from a string (like time.strptime()).'\n        import _strptime\n        return _strptime._strptime_datetime(cls, date_string, format)\n\n    def utcoffset(self):\n        \"\"\"Return the timezone offset as timedelta positive east of UTC (negative west of\n        UTC).\"\"\"\n        if self._tzinfo is None:\n            return None\n        offset = self._tzinfo.utcoffset(self)\n        _check_utc_offset(\"utcoffset\", offset)\n        return offset\n\n    def tzname(self):\n        \"\"\"Return the timezone name.\n\n        Note that the name is 100% informational -- there's no requirement that\n        it mean anything in particular. For example, \"GMT\", \"UTC\", \"-500\",\n        \"-5:00\", \"EDT\", \"US/Eastern\", \"America/New York\" are all valid replies.\n        \"\"\"\n        if self._tzinfo is None:\n            return None\n        name = self._tzinfo.tzname(self)\n        _check_tzname(name)\n        return name\n\n    def dst(self):\n        \"\"\"Return 0 if DST is not in effect, or the DST offset (as timedelta\n        positive eastward) if DST is in effect.\n\n        This is purely informational; the DST offset has already been added to\n        the UTC offset returned by utcoffset() if applicable, so there's no\n        need to consult dst() unless you're interested in displaying the DST\n        info.\n        \"\"\"\n        if self._tzinfo is None:\n            return None\n        offset = self._tzinfo.dst(self)\n        _check_utc_offset(\"dst\", offset)\n        return offset\n\n    # Comparisons of datetime objects with other.\n\n    def __eq__(self, other):\n        if isinstance(other, datetime):\n            return self._cmp(other, allow_mixed=True) == 0\n        elif not isinstance(other, date):\n            return NotImplemented\n        else:\n            return False\n\n    def __le__(self, other):\n        if isinstance(other, datetime):\n            return self._cmp(other) <= 0\n        elif not isinstance(other, date):\n            return NotImplemented\n        else:\n            _cmperror(self, other)\n\n    def __lt__(self, other):\n        if isinstance(other, datetime):\n            return self._cmp(other) < 0\n        elif not isinstance(other, date):\n            return NotImplemented\n        else:\n            _cmperror(self, other)\n\n    def __ge__(self, other):\n        if isinstance(other, datetime):\n            return self._cmp(other) >= 0\n        elif not isinstance(other, date):\n            return NotImplemented\n        else:\n            _cmperror(self, other)\n\n    def __gt__(self, other):\n        if isinstance(other, datetime):\n            return self._cmp(other) > 0\n        elif not isinstance(other, date):\n            return NotImplemented\n        else:\n            _cmperror(self, other)\n\n    def _cmp(self, other, allow_mixed=False):\n        assert isinstance(other, datetime)\n        mytz = self._tzinfo\n        ottz = other._tzinfo\n        myoff = otoff = None\n\n        if mytz is ottz:\n            base_compare = True\n        else:\n            myoff = self.utcoffset()\n            otoff = other.utcoffset()\n            # Assume that allow_mixed means that we are called from __eq__\n            if allow_mixed:\n                if myoff != self.replace(fold=not self.fold).utcoffset():\n                    return 2\n                if otoff != other.replace(fold=not other.fold).utcoffset():\n                    return 2\n            base_compare = myoff == otoff\n\n        if base_compare:\n            return _cmp((self._year, self._month, self._day,\n                         self._hour, self._minute, self._second,\n                         self._microsecond),\n                        (other._year, other._month, other._day,\n                         other._hour, other._minute, other._second,\n                         other._microsecond))\n        if myoff is None or otoff is None:\n            if allow_mixed:\n                return 2 # arbitrary non-zero value\n            else:\n                raise TypeError(\"cannot compare naive and aware datetimes\")\n        # XXX What follows could be done more efficiently...\n        diff = self - other     # this will take offsets into account\n        if diff.days < 0:\n            return -1\n        return diff and 1 or 0\n\n    def __add__(self, other):\n        \"Add a datetime and a timedelta.\"\n        if not isinstance(other, timedelta):\n            return NotImplemented\n        delta = timedelta(self.toordinal(),\n                          hours=self._hour,\n                          minutes=self._minute,\n                          seconds=self._second,\n                          microseconds=self._microsecond)\n        delta += other\n        hour, rem = divmod(delta.seconds, 3600)\n        minute, second = divmod(rem, 60)\n        if 0 < delta.days <= _MAXORDINAL:\n            return type(self).combine(date.fromordinal(delta.days),\n                                      time(hour, minute, second,\n                                           delta.microseconds,\n                                           tzinfo=self._tzinfo))\n        raise OverflowError(\"result out of range\")\n\n    __radd__ = __add__\n\n    def __sub__(self, other):\n        \"Subtract two datetimes, or a datetime and a timedelta.\"\n        if not isinstance(other, datetime):\n            if isinstance(other, timedelta):\n                return self + -other\n            return NotImplemented\n\n        days1 = self.toordinal()\n        days2 = other.toordinal()\n        secs1 = self._second + self._minute * 60 + self._hour * 3600\n        secs2 = other._second + other._minute * 60 + other._hour * 3600\n        base = timedelta(days1 - days2,\n                         secs1 - secs2,\n                         self._microsecond - other._microsecond)\n        if self._tzinfo is other._tzinfo:\n            return base\n        myoff = self.utcoffset()\n        otoff = other.utcoffset()\n        if myoff == otoff:\n            return base\n        if myoff is None or otoff is None:\n            raise TypeError(\"cannot mix naive and timezone-aware time\")\n        return base + otoff - myoff\n\n    def __hash__(self):\n        if self._hashcode == -1:\n            if self.fold:\n                t = self.replace(fold=0)\n            else:\n                t = self\n            tzoff = t.utcoffset()\n            if tzoff is None:\n                self._hashcode = hash(t._getstate()[0])\n            else:\n                days = _ymd2ord(self.year, self.month, self.day)\n                seconds = self.hour * 3600 + self.minute * 60 + self.second\n                self._hashcode = hash(timedelta(days, seconds, self.microsecond) - tzoff)\n        return self._hashcode\n\n    # Pickle support.\n\n    def _getstate(self, protocol=3):\n        yhi, ylo = divmod(self._year, 256)\n        us2, us3 = divmod(self._microsecond, 256)\n        us1, us2 = divmod(us2, 256)\n        m = self._month\n        if self._fold and protocol > 3:\n            m += 128\n        basestate = bytes([yhi, ylo, m, self._day,\n                           self._hour, self._minute, self._second,\n                           us1, us2, us3])\n        if self._tzinfo is None:\n            return (basestate,)\n        else:\n            return (basestate, self._tzinfo)\n\n    def __setstate(self, string, tzinfo):\n        if tzinfo is not None and not isinstance(tzinfo, _tzinfo_class):\n            raise TypeError(\"bad tzinfo state arg\")\n        (yhi, ylo, m, self._day, self._hour,\n         self._minute, self._second, us1, us2, us3) = string\n        if m > 127:\n            self._fold = 1\n            self._month = m - 128\n        else:\n            self._fold = 0\n            self._month = m\n        self._year = yhi * 256 + ylo\n        self._microsecond = (((us1 << 8) | us2) << 8) | us3\n        self._tzinfo = tzinfo\n\n    def __reduce_ex__(self, protocol):\n        return (self.__class__, self._getstate(protocol))\n\n    def __reduce__(self):\n        return self.__reduce_ex__(2)\n"
    },
    {
      "type": "class",
      "qualified_name": "pytz.tzinfo.AmbiguousTimeError",
      "module": "pytz.tzinfo",
      "signature": "(self, /, *args, **kwargs)",
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Exception raised when attempting to create an ambiguous wallclock time.\n\nAt the end of a DST transition period, a particular wallclock time will\noccur twice (once before the clocks are set back, once after). Both\npossibilities may be correct, unless further information is supplied.\n\nSee DstTzInfo.normalize() for more info",
      "source_code": "class AmbiguousTimeError(InvalidTimeError):\n    '''Exception raised when attempting to create an ambiguous wallclock time.\n\n    At the end of a DST transition period, a particular wallclock time will\n    occur twice (once before the clocks are set back, once after). Both\n    possibilities may be correct, unless further information is supplied.\n\n    See DstTzInfo.normalize() for more info\n    '''\n"
    },
    {
      "type": "class",
      "qualified_name": "pytz.tzinfo.BaseTzInfo",
      "module": "pytz.tzinfo",
      "signature": "(self, /, *args, **kwargs)",
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Abstract base class for time zone info objects.",
      "source_code": "class BaseTzInfo(tzinfo):\n    # Overridden in subclass\n    _utcoffset = None\n    _tzname = None\n    zone = None\n\n    def __str__(self):\n        return self.zone\n"
    },
    {
      "type": "class",
      "qualified_name": "pytz.tzinfo.DstTzInfo",
      "module": "pytz.tzinfo",
      "signature": "(self, _inf=None, _tzinfos=None)",
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "A timezone that has a variable offset from UTC\n\nThe offset might change if daylight saving time comes into effect,\nor at a point in history when the region decides to change their\ntimezone definition.",
      "source_code": "class DstTzInfo(BaseTzInfo):\n    '''A timezone that has a variable offset from UTC\n\n    The offset might change if daylight saving time comes into effect,\n    or at a point in history when the region decides to change their\n    timezone definition.\n    '''\n    # Overridden in subclass\n\n    # Sorted list of DST transition times, UTC\n    _utc_transition_times = None\n\n    # [(utcoffset, dstoffset, tzname)] corresponding to\n    # _utc_transition_times entries\n    _transition_info = None\n\n    zone = None\n\n    # Set in __init__\n\n    _tzinfos = None\n    _dst = None  # DST offset\n\n    def __init__(self, _inf=None, _tzinfos=None):\n        if _inf:\n            self._tzinfos = _tzinfos\n            self._utcoffset, self._dst, self._tzname = _inf\n        else:\n            _tzinfos = {}\n            self._tzinfos = _tzinfos\n            self._utcoffset, self._dst, self._tzname = (\n                self._transition_info[0])\n            _tzinfos[self._transition_info[0]] = self\n            for inf in self._transition_info[1:]:\n                if inf not in _tzinfos:\n                    _tzinfos[inf] = self.__class__(inf, _tzinfos)\n\n    def fromutc(self, dt):\n        '''See datetime.tzinfo.fromutc'''\n        if (dt.tzinfo is not None and\n                getattr(dt.tzinfo, '_tzinfos', None) is not self._tzinfos):\n            raise ValueError('fromutc: dt.tzinfo is not self')\n        dt = dt.replace(tzinfo=None)\n        idx = max(0, bisect_right(self._utc_transition_times, dt) - 1)\n        inf = self._transition_info[idx]\n        return (dt + inf[0]).replace(tzinfo=self._tzinfos[inf])\n\n    def normalize(self, dt):\n        '''Correct the timezone information on the given datetime\n\n        If date arithmetic crosses DST boundaries, the tzinfo\n        is not magically adjusted. This method normalizes the\n        tzinfo to the correct one.\n\n        To test, first we need to do some setup\n\n        >>> from pytz import timezone\n        >>> utc = timezone('UTC')\n        >>> eastern = timezone('US/Eastern')\n        >>> fmt = '%Y-%m-%d %H:%M:%S %Z (%z)'\n\n        We next create a datetime right on an end-of-DST transition point,\n        the instant when the wallclocks are wound back one hour.\n\n        >>> utc_dt = datetime(2002, 10, 27, 6, 0, 0, tzinfo=utc)\n        >>> loc_dt = utc_dt.astimezone(eastern)\n        >>> loc_dt.strftime(fmt)\n        '2002-10-27 01:00:00 EST (-0500)'\n\n        Now, if we subtract a few minutes from it, note that the timezone\n        information has not changed.\n\n        >>> before = loc_dt - timedelta(minutes=10)\n        >>> before.strftime(fmt)\n        '2002-10-27 00:50:00 EST (-0500)'\n\n        But we can fix that by calling the normalize method\n\n        >>> before = eastern.normalize(before)\n        >>> before.strftime(fmt)\n        '2002-10-27 01:50:00 EDT (-0400)'\n\n        The supported method of converting between timezones is to use\n        datetime.astimezone(). Currently, normalize() also works:\n\n        >>> th = timezone('Asia/Bangkok')\n        >>> am = timezone('Europe/Amsterdam')\n        >>> dt = th.localize(datetime(2011, 5, 7, 1, 2, 3))\n        >>> fmt = '%Y-%m-%d %H:%M:%S %Z (%z)'\n        >>> am.normalize(dt).strftime(fmt)\n        '2011-05-06 20:02:03 CEST (+0200)'\n        '''\n        if dt.tzinfo is None:\n            raise ValueError('Naive time - no tzinfo set')\n\n        # Convert dt in localtime to UTC\n        offset = dt.tzinfo._utcoffset\n        dt = dt.replace(tzinfo=None)\n        dt = dt - offset\n        # convert it back, and return it\n        return self.fromutc(dt)\n\n    def localize(self, dt, is_dst=False):\n        '''Convert naive time to local time.\n\n        This method should be used to construct localtimes, rather\n        than passing a tzinfo argument to a datetime constructor.\n\n        is_dst is used to determine the correct timezone in the ambigous\n        period at the end of daylight saving time.\n\n        >>> from pytz import timezone\n        >>> fmt = '%Y-%m-%d %H:%M:%S %Z (%z)'\n        >>> amdam = timezone('Europe/Amsterdam')\n        >>> dt  = datetime(2004, 10, 31, 2, 0, 0)\n        >>> loc_dt1 = amdam.localize(dt, is_dst=True)\n        >>> loc_dt2 = amdam.localize(dt, is_dst=False)\n        >>> loc_dt1.strftime(fmt)\n        '2004-10-31 02:00:00 CEST (+0200)'\n        >>> loc_dt2.strftime(fmt)\n        '2004-10-31 02:00:00 CET (+0100)'\n        >>> str(loc_dt2 - loc_dt1)\n        '1:00:00'\n\n        Use is_dst=None to raise an AmbiguousTimeError for ambiguous\n        times at the end of daylight saving time\n\n        >>> try:\n        ...     loc_dt1 = amdam.localize(dt, is_dst=None)\n        ... except AmbiguousTimeError:\n        ...     print('Ambiguous')\n        Ambiguous\n\n        is_dst defaults to False\n\n        >>> amdam.localize(dt) == amdam.localize(dt, False)\n        True\n\n        is_dst is also used to determine the correct timezone in the\n        wallclock times jumped over at the start of daylight saving time.\n\n        >>> pacific = timezone('US/Pacific')\n        >>> dt = datetime(2008, 3, 9, 2, 0, 0)\n        >>> ploc_dt1 = pacific.localize(dt, is_dst=True)\n        >>> ploc_dt2 = pacific.localize(dt, is_dst=False)\n        >>> ploc_dt1.strftime(fmt)\n        '2008-03-09 02:00:00 PDT (-0700)'\n        >>> ploc_dt2.strftime(fmt)\n        '2008-03-09 02:00:00 PST (-0800)'\n        >>> str(ploc_dt2 - ploc_dt1)\n        '1:00:00'\n\n        Use is_dst=None to raise a NonExistentTimeError for these skipped\n        times.\n\n        >>> try:\n        ...     loc_dt1 = pacific.localize(dt, is_dst=None)\n        ... except NonExistentTimeError:\n        ...     print('Non-existent')\n        Non-existent\n        '''\n        if dt.tzinfo is not None:\n            raise ValueError('Not naive datetime (tzinfo is already set)')\n\n        # Find the two best possibilities.\n        possible_loc_dt = set()\n        for delta in [timedelta(days=-1), timedelta(days=1)]:\n            loc_dt = dt + delta\n            idx = max(0, bisect_right(\n                self._utc_transition_times, loc_dt) - 1)\n            inf = self._transition_info[idx]\n            tzinfo = self._tzinfos[inf]\n            loc_dt = tzinfo.normalize(dt.replace(tzinfo=tzinfo))\n            if loc_dt.replace(tzinfo=None) == dt:\n                possible_loc_dt.add(loc_dt)\n\n        if len(possible_loc_dt) == 1:\n            return possible_loc_dt.pop()\n\n        # If there are no possibly correct timezones, we are attempting\n        # to convert a time that never happened - the time period jumped\n        # during the start-of-DST transition period.\n        if len(possible_loc_dt) == 0:\n            # If we refuse to guess, raise an exception.\n            if is_dst is None:\n                raise NonExistentTimeError(dt)\n\n            # If we are forcing the pre-DST side of the DST transition, we\n            # obtain the correct timezone by winding the clock forward a few\n            # hours.\n            elif is_dst:\n                return self.localize(\n                    dt + timedelta(hours=6), is_dst=True) - timedelta(hours=6)\n\n            # If we are forcing the post-DST side of the DST transition, we\n            # obtain the correct timezone by winding the clock back.\n            else:\n                return self.localize(\n                    dt - timedelta(hours=6),\n                    is_dst=False) + timedelta(hours=6)\n\n        # If we get this far, we have multiple possible timezones - this\n        # is an ambiguous case occurring during the end-of-DST transition.\n\n        # If told to be strict, raise an exception since we have an\n        # ambiguous case\n        if is_dst is None:\n            raise AmbiguousTimeError(dt)\n\n        # Filter out the possiblilities that don't match the requested\n        # is_dst\n        filtered_possible_loc_dt = [\n            p for p in possible_loc_dt if bool(p.tzinfo._dst) == is_dst\n        ]\n\n        # Hopefully we only have one possibility left. Return it.\n        if len(filtered_possible_loc_dt) == 1:\n            return filtered_possible_loc_dt[0]\n\n        if len(filtered_possible_loc_dt) == 0:\n            filtered_possible_loc_dt = list(possible_loc_dt)\n\n        # If we get this far, we have in a wierd timezone transition\n        # where the clocks have been wound back but is_dst is the same\n        # in both (eg. Europe/Warsaw 1915 when they switched to CET).\n        # At this point, we just have to guess unless we allow more\n        # hints to be passed in (such as the UTC offset or abbreviation),\n        # but that is just getting silly.\n        #\n        # Choose the earliest (by UTC) applicable timezone if is_dst=True\n        # Choose the latest (by UTC) applicable timezone if is_dst=False\n        # i.e., behave like end-of-DST transition\n        dates = {}  # utc -> local\n        for local_dt in filtered_possible_loc_dt:\n            utc_time = (\n                local_dt.replace(tzinfo=None) - local_dt.tzinfo._utcoffset)\n            assert utc_time not in dates\n            dates[utc_time] = local_dt\n        return dates[[min, max][not is_dst](dates)]\n\n    def utcoffset(self, dt, is_dst=None):\n        '''See datetime.tzinfo.utcoffset\n\n        The is_dst parameter may be used to remove ambiguity during DST\n        transitions.\n\n        >>> from pytz import timezone\n        >>> tz = timezone('America/St_Johns')\n        >>> ambiguous = datetime(2009, 10, 31, 23, 30)\n\n        >>> str(tz.utcoffset(ambiguous, is_dst=False))\n        '-1 day, 20:30:00'\n\n        >>> str(tz.utcoffset(ambiguous, is_dst=True))\n        '-1 day, 21:30:00'\n\n        >>> try:\n        ...     tz.utcoffset(ambiguous)\n        ... except AmbiguousTimeError:\n        ...     print('Ambiguous')\n        Ambiguous\n\n        '''\n        if dt is None:\n            return None\n        elif dt.tzinfo is not self:\n            dt = self.localize(dt, is_dst)\n            return dt.tzinfo._utcoffset\n        else:\n            return self._utcoffset\n\n    def dst(self, dt, is_dst=None):\n        '''See datetime.tzinfo.dst\n\n        The is_dst parameter may be used to remove ambiguity during DST\n        transitions.\n\n        >>> from pytz import timezone\n        >>> tz = timezone('America/St_Johns')\n\n        >>> normal = datetime(2009, 9, 1)\n\n        >>> str(tz.dst(normal))\n        '1:00:00'\n        >>> str(tz.dst(normal, is_dst=False))\n        '1:00:00'\n        >>> str(tz.dst(normal, is_dst=True))\n        '1:00:00'\n\n        >>> ambiguous = datetime(2009, 10, 31, 23, 30)\n\n        >>> str(tz.dst(ambiguous, is_dst=False))\n        '0:00:00'\n        >>> str(tz.dst(ambiguous, is_dst=True))\n        '1:00:00'\n        >>> try:\n        ...     tz.dst(ambiguous)\n        ... except AmbiguousTimeError:\n        ...     print('Ambiguous')\n        Ambiguous\n\n        '''\n        if dt is None:\n            return None\n        elif dt.tzinfo is not self:\n            dt = self.localize(dt, is_dst)\n            return dt.tzinfo._dst\n        else:\n            return self._dst\n\n    def tzname(self, dt, is_dst=None):\n        '''See datetime.tzinfo.tzname\n\n        The is_dst parameter may be used to remove ambiguity during DST\n        transitions.\n\n        >>> from pytz import timezone\n        >>> tz = timezone('America/St_Johns')\n\n        >>> normal = datetime(2009, 9, 1)\n\n        >>> tz.tzname(normal)\n        'NDT'\n        >>> tz.tzname(normal, is_dst=False)\n        'NDT'\n        >>> tz.tzname(normal, is_dst=True)\n        'NDT'\n\n        >>> ambiguous = datetime(2009, 10, 31, 23, 30)\n\n        >>> tz.tzname(ambiguous, is_dst=False)\n        'NST'\n        >>> tz.tzname(ambiguous, is_dst=True)\n        'NDT'\n        >>> try:\n        ...     tz.tzname(ambiguous)\n        ... except AmbiguousTimeError:\n        ...     print('Ambiguous')\n        Ambiguous\n        '''\n        if dt is None:\n            return self.zone\n        elif dt.tzinfo is not self:\n            dt = self.localize(dt, is_dst)\n            return dt.tzinfo._tzname\n        else:\n            return self._tzname\n\n    def __repr__(self):\n        if self._dst:\n            dst = 'DST'\n        else:\n            dst = 'STD'\n        if self._utcoffset > _notime:\n            return '<DstTzInfo %r %s+%s %s>' % (\n                self.zone, self._tzname, self._utcoffset, dst\n            )\n        else:\n            return '<DstTzInfo %r %s%s %s>' % (\n                self.zone, self._tzname, self._utcoffset, dst\n            )\n\n    def __reduce__(self):\n        # Special pickle to zone remains a singleton and to cope with\n        # database changes.\n        return pytz._p, (\n            self.zone,\n            _to_seconds(self._utcoffset),\n            _to_seconds(self._dst),\n            self._tzname\n        )\n"
    },
    {
      "type": "class",
      "qualified_name": "pytz.tzinfo.NonExistentTimeError",
      "module": "pytz.tzinfo",
      "signature": "(self, /, *args, **kwargs)",
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Exception raised when attempting to create a wallclock time that\ncannot exist.\n\nAt the start of a DST transition period, the wallclock time jumps forward.\nThe instants jumped over never occur.",
      "source_code": "class NonExistentTimeError(InvalidTimeError):\n    '''Exception raised when attempting to create a wallclock time that\n    cannot exist.\n\n    At the start of a DST transition period, the wallclock time jumps forward.\n    The instants jumped over never occur.\n    '''\n"
    },
    {
      "type": "class",
      "qualified_name": "pytz.tzinfo.StaticTzInfo",
      "module": "pytz.tzinfo",
      "signature": "(self, /, *args, **kwargs)",
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "A timezone that has a constant offset from UTC\n\nThese timezones are rare, as most locations have changed their\noffset at some point in their history",
      "source_code": "class StaticTzInfo(BaseTzInfo):\n    '''A timezone that has a constant offset from UTC\n\n    These timezones are rare, as most locations have changed their\n    offset at some point in their history\n    '''\n    def fromutc(self, dt):\n        '''See datetime.tzinfo.fromutc'''\n        if dt.tzinfo is not None and dt.tzinfo is not self:\n            raise ValueError('fromutc: dt.tzinfo is not self')\n        return (dt + self._utcoffset).replace(tzinfo=self)\n\n    def utcoffset(self, dt, is_dst=None):\n        '''See datetime.tzinfo.utcoffset\n\n        is_dst is ignored for StaticTzInfo, and exists only to\n        retain compatibility with DstTzInfo.\n        '''\n        return self._utcoffset\n\n    def dst(self, dt, is_dst=None):\n        '''See datetime.tzinfo.dst\n\n        is_dst is ignored for StaticTzInfo, and exists only to\n        retain compatibility with DstTzInfo.\n        '''\n        return _notime\n\n    def tzname(self, dt, is_dst=None):\n        '''See datetime.tzinfo.tzname\n\n        is_dst is ignored for StaticTzInfo, and exists only to\n        retain compatibility with DstTzInfo.\n        '''\n        return self._tzname\n\n    def localize(self, dt, is_dst=False):\n        '''Convert naive time to local time'''\n        if dt.tzinfo is not None:\n            raise ValueError('Not naive datetime (tzinfo is already set)')\n        return dt.replace(tzinfo=self)\n\n    def normalize(self, dt, is_dst=False):\n        '''Correct the timezone information on the given datetime.\n\n        This is normally a no-op, as StaticTzInfo timezones never have\n        ambiguous cases to correct:\n\n        >>> from pytz import timezone\n        >>> gmt = timezone('GMT')\n        >>> isinstance(gmt, StaticTzInfo)\n        True\n        >>> dt = datetime(2011, 5, 8, 1, 2, 3, tzinfo=gmt)\n        >>> gmt.normalize(dt) is dt\n        True\n\n        The supported method of converting between timezones is to use\n        datetime.astimezone(). Currently normalize() also works:\n\n        >>> la = timezone('America/Los_Angeles')\n        >>> dt = la.localize(datetime(2011, 5, 7, 1, 2, 3))\n        >>> fmt = '%Y-%m-%d %H:%M:%S %Z (%z)'\n        >>> gmt.normalize(dt).strftime(fmt)\n        '2011-05-07 08:02:03 GMT (+0000)'\n        '''\n        if dt.tzinfo is self:\n            return dt\n        if dt.tzinfo is None:\n            raise ValueError('Naive time - no tzinfo set')\n        return dt.astimezone(self)\n\n    def __repr__(self):\n        return '<StaticTzInfo %r>' % (self.zone,)\n\n    def __reduce__(self):\n        # Special pickle to zone remains a singleton and to cope with\n        # database changes.\n        return pytz._p, (self.zone,)\n"
    },
    {
      "type": "class",
      "qualified_name": "pytz.tzinfo.datetime",
      "module": "pytz.tzinfo",
      "signature": "(self, /, *args, **kwargs)",
      "return_description": null,
      "raises": [],
      "decorators": [
        "property",
        "property",
        "property",
        "property",
        "property",
        "property",
        "classmethod",
        "classmethod",
        "classmethod",
        "classmethod",
        "classmethod",
        "classmethod",
        "classmethod",
        "classmethod"
      ],
      "examples": [],
      "docstring": "datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]])\n\nThe year, month and day arguments are required. tzinfo may be None, or an\ninstance of a tzinfo subclass. The remaining arguments may be ints.",
      "source_code": "class datetime(date):\n    \"\"\"datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]])\n\n    The year, month and day arguments are required. tzinfo may be None, or an\n    instance of a tzinfo subclass. The remaining arguments may be ints.\n    \"\"\"\n    __slots__ = date.__slots__ + time.__slots__\n\n    def __new__(cls, year, month=None, day=None, hour=0, minute=0, second=0,\n                microsecond=0, tzinfo=None, *, fold=0):\n        if (isinstance(year, (bytes, str)) and len(year) == 10 and\n            1 <= ord(year[2:3])&0x7F <= 12):\n            # Pickle support\n            if isinstance(year, str):\n                try:\n                    year = bytes(year, 'latin1')\n                except UnicodeEncodeError:\n                    # More informative error message.\n                    raise ValueError(\n                        \"Failed to encode latin1 string when unpickling \"\n                        \"a datetime object. \"\n                        \"pickle.load(data, encoding='latin1') is assumed.\")\n            self = object.__new__(cls)\n            self.__setstate(year, month)\n            self._hashcode = -1\n            return self\n        year, month, day = _check_date_fields(year, month, day)\n        hour, minute, second, microsecond, fold = _check_time_fields(\n            hour, minute, second, microsecond, fold)\n        _check_tzinfo_arg(tzinfo)\n        self = object.__new__(cls)\n        self._year = year\n        self._month = month\n        self._day = day\n        self._hour = hour\n        self._minute = minute\n        self._second = second\n        self._microsecond = microsecond\n        self._tzinfo = tzinfo\n        self._hashcode = -1\n        self._fold = fold\n        return self\n\n    # Read-only field accessors\n    @property\n    def hour(self):\n        \"\"\"hour (0-23)\"\"\"\n        return self._hour\n\n    @property\n    def minute(self):\n        \"\"\"minute (0-59)\"\"\"\n        return self._minute\n\n    @property\n    def second(self):\n        \"\"\"second (0-59)\"\"\"\n        return self._second\n\n    @property\n    def microsecond(self):\n        \"\"\"microsecond (0-999999)\"\"\"\n        return self._microsecond\n\n    @property\n    def tzinfo(self):\n        \"\"\"timezone info object\"\"\"\n        return self._tzinfo\n\n    @property\n    def fold(self):\n        return self._fold\n\n    @classmethod\n    def _fromtimestamp(cls, t, utc, tz):\n        \"\"\"Construct a datetime from a POSIX timestamp (like time.time()).\n\n        A timezone info object may be passed in as well.\n        \"\"\"\n        frac, t = _math.modf(t)\n        us = round(frac * 1e6)\n        if us >= 1000000:\n            t += 1\n            us -= 1000000\n        elif us < 0:\n            t -= 1\n            us += 1000000\n\n        converter = _time.gmtime if utc else _time.localtime\n        y, m, d, hh, mm, ss, weekday, jday, dst = converter(t)\n        ss = min(ss, 59)    # clamp out leap seconds if the platform has them\n        result = cls(y, m, d, hh, mm, ss, us, tz)\n        if tz is None and not utc:\n            # As of version 2015f max fold in IANA database is\n            # 23 hours at 1969-09-30 13:00:00 in Kwajalein.\n            # Let's probe 24 hours in the past to detect a transition:\n            max_fold_seconds = 24 * 3600\n\n            # On Windows localtime_s throws an OSError for negative values,\n            # thus we can't perform fold detection for values of time less\n            # than the max time fold. See comments in _datetimemodule's\n            # version of this method for more details.\n            if t < max_fold_seconds and sys.platform.startswith(\"win\"):\n                return result\n\n            y, m, d, hh, mm, ss = converter(t - max_fold_seconds)[:6]\n            probe1 = cls(y, m, d, hh, mm, ss, us, tz)\n            trans = result - probe1 - timedelta(0, max_fold_seconds)\n            if trans.days < 0:\n                y, m, d, hh, mm, ss = converter(t + trans // timedelta(0, 1))[:6]\n                probe2 = cls(y, m, d, hh, mm, ss, us, tz)\n                if probe2 == result:\n                    result._fold = 1\n        elif tz is not None:\n            result = tz.fromutc(result)\n        return result\n\n    @classmethod\n    def fromtimestamp(cls, t, tz=None):\n        \"\"\"Construct a datetime from a POSIX timestamp (like time.time()).\n\n        A timezone info object may be passed in as well.\n        \"\"\"\n        _check_tzinfo_arg(tz)\n\n        return cls._fromtimestamp(t, tz is not None, tz)\n\n    @classmethod\n    def utcfromtimestamp(cls, t):\n        \"\"\"Construct a naive UTC datetime from a POSIX timestamp.\"\"\"\n        return cls._fromtimestamp(t, True, None)\n\n    @classmethod\n    def now(cls, tz=None):\n        \"Construct a datetime from time.time() and optional time zone info.\"\n        t = _time.time()\n        return cls.fromtimestamp(t, tz)\n\n    @classmethod\n    def utcnow(cls):\n        \"Construct a UTC datetime from time.time().\"\n        t = _time.time()\n        return cls.utcfromtimestamp(t)\n\n    @classmethod\n    def combine(cls, date, time, tzinfo=True):\n        \"Construct a datetime from a given date and a given time.\"\n        if not isinstance(date, _date_class):\n            raise TypeError(\"date argument must be a date instance\")\n        if not isinstance(time, _time_class):\n            raise TypeError(\"time argument must be a time instance\")\n        if tzinfo is True:\n            tzinfo = time.tzinfo\n        return cls(date.year, date.month, date.day,\n                   time.hour, time.minute, time.second, time.microsecond,\n                   tzinfo, fold=time.fold)\n\n    @classmethod\n    def fromisoformat(cls, date_string):\n        \"\"\"Construct a datetime from a string in one of the ISO 8601 formats.\"\"\"\n        if not isinstance(date_string, str):\n            raise TypeError('fromisoformat: argument must be str')\n\n        if len(date_string) < 7:\n            raise ValueError(f'Invalid isoformat string: {date_string!r}')\n\n        # Split this at the separator\n        try:\n            separator_location = _find_isoformat_datetime_separator(date_string)\n            dstr = date_string[0:separator_location]\n            tstr = date_string[(separator_location+1):]\n\n            date_components = _parse_isoformat_date(dstr)\n        except ValueError:\n            raise ValueError(\n                f'Invalid isoformat string: {date_string!r}') from None\n\n        if tstr:\n            try:\n                time_components = _parse_isoformat_time(tstr)\n            except ValueError:\n                raise ValueError(\n                    f'Invalid isoformat string: {date_string!r}') from None\n        else:\n            time_components = [0, 0, 0, 0, None]\n\n        return cls(*(date_components + time_components))\n\n    def timetuple(self):\n        \"Return local time tuple compatible with time.localtime().\"\n        dst = self.dst()\n        if dst is None:\n            dst = -1\n        elif dst:\n            dst = 1\n        else:\n            dst = 0\n        return _build_struct_time(self.year, self.month, self.day,\n                                  self.hour, self.minute, self.second,\n                                  dst)\n\n    def _mktime(self):\n        \"\"\"Return integer POSIX timestamp.\"\"\"\n        epoch = datetime(1970, 1, 1)\n        max_fold_seconds = 24 * 3600\n        t = (self - epoch) // timedelta(0, 1)\n        def local(u):\n            y, m, d, hh, mm, ss = _time.localtime(u)[:6]\n            return (datetime(y, m, d, hh, mm, ss) - epoch) // timedelta(0, 1)\n\n        # Our goal is to solve t = local(u) for u.\n        a = local(t) - t\n        u1 = t - a\n        t1 = local(u1)\n        if t1 == t:\n            # We found one solution, but it may not be the one we need.\n            # Look for an earlier solution (if `fold` is 0), or a\n            # later one (if `fold` is 1).\n            u2 = u1 + (-max_fold_seconds, max_fold_seconds)[self.fold]\n            b = local(u2) - u2\n            if a == b:\n                return u1\n        else:\n            b = t1 - u1\n            assert a != b\n        u2 = t - b\n        t2 = local(u2)\n        if t2 == t:\n            return u2\n        if t1 == t:\n            return u1\n        # We have found both offsets a and b, but neither t - a nor t - b is\n        # a solution.  This means t is in the gap.\n        return (max, min)[self.fold](u1, u2)\n\n\n    def timestamp(self):\n        \"Return POSIX timestamp as float\"\n        if self._tzinfo is None:\n            s = self._mktime()\n            return s + self.microsecond / 1e6\n        else:\n            return (self - _EPOCH).total_seconds()\n\n    def utctimetuple(self):\n        \"Return UTC time tuple compatible with time.gmtime().\"\n        offset = self.utcoffset()\n        if offset:\n            self -= offset\n        y, m, d = self.year, self.month, self.day\n        hh, mm, ss = self.hour, self.minute, self.second\n        return _build_struct_time(y, m, d, hh, mm, ss, 0)\n\n    def date(self):\n        \"Return the date part.\"\n        return date(self._year, self._month, self._day)\n\n    def time(self):\n        \"Return the time part, with tzinfo None.\"\n        return time(self.hour, self.minute, self.second, self.microsecond, fold=self.fold)\n\n    def timetz(self):\n        \"Return the time part, with same tzinfo.\"\n        return time(self.hour, self.minute, self.second, self.microsecond,\n                    self._tzinfo, fold=self.fold)\n\n    def replace(self, year=None, month=None, day=None, hour=None,\n                minute=None, second=None, microsecond=None, tzinfo=True,\n                *, fold=None):\n        \"\"\"Return a new datetime with new values for the specified fields.\"\"\"\n        if year is None:\n            year = self.year\n        if month is None:\n            month = self.month\n        if day is None:\n            day = self.day\n        if hour is None:\n            hour = self.hour\n        if minute is None:\n            minute = self.minute\n        if second is None:\n            second = self.second\n        if microsecond is None:\n            microsecond = self.microsecond\n        if tzinfo is True:\n            tzinfo = self.tzinfo\n        if fold is None:\n            fold = self.fold\n        return type(self)(year, month, day, hour, minute, second,\n                          microsecond, tzinfo, fold=fold)\n\n    def _local_timezone(self):\n        if self.tzinfo is None:\n            ts = self._mktime()\n        else:\n            ts = (self - _EPOCH) // timedelta(seconds=1)\n        localtm = _time.localtime(ts)\n        local = datetime(*localtm[:6])\n        # Extract TZ data\n        gmtoff = localtm.tm_gmtoff\n        zone = localtm.tm_zone\n        return timezone(timedelta(seconds=gmtoff), zone)\n\n    def astimezone(self, tz=None):\n        if tz is None:\n            tz = self._local_timezone()\n        elif not isinstance(tz, tzinfo):\n            raise TypeError(\"tz argument must be an instance of tzinfo\")\n\n        mytz = self.tzinfo\n        if mytz is None:\n            mytz = self._local_timezone()\n            myoffset = mytz.utcoffset(self)\n        else:\n            myoffset = mytz.utcoffset(self)\n            if myoffset is None:\n                mytz = self.replace(tzinfo=None)._local_timezone()\n                myoffset = mytz.utcoffset(self)\n\n        if tz is mytz:\n            return self\n\n        # Convert self to UTC, and attach the new time zone object.\n        utc = (self - myoffset).replace(tzinfo=tz)\n\n        # Convert from UTC to tz's local time.\n        return tz.fromutc(utc)\n\n    # Ways to produce a string.\n\n    def ctime(self):\n        \"Return ctime() style string.\"\n        weekday = self.toordinal() % 7 or 7\n        return \"%s %s %2d %02d:%02d:%02d %04d\" % (\n            _DAYNAMES[weekday],\n            _MONTHNAMES[self._month],\n            self._day,\n            self._hour, self._minute, self._second,\n            self._year)\n\n    def isoformat(self, sep='T', timespec='auto'):\n        \"\"\"Return the time formatted according to ISO.\n\n        The full format looks like 'YYYY-MM-DD HH:MM:SS.mmmmmm'.\n        By default, the fractional part is omitted if self.microsecond == 0.\n\n        If self.tzinfo is not None, the UTC offset is also attached, giving\n        giving a full format of 'YYYY-MM-DD HH:MM:SS.mmmmmm+HH:MM'.\n\n        Optional argument sep specifies the separator between date and\n        time, default 'T'.\n\n        The optional argument timespec specifies the number of additional\n        terms of the time to include. Valid options are 'auto', 'hours',\n        'minutes', 'seconds', 'milliseconds' and 'microseconds'.\n        \"\"\"\n        s = (\"%04d-%02d-%02d%c\" % (self._year, self._month, self._day, sep) +\n             _format_time(self._hour, self._minute, self._second,\n                          self._microsecond, timespec))\n\n        off = self.utcoffset()\n        tz = _format_offset(off)\n        if tz:\n            s += tz\n\n        return s\n\n    def __repr__(self):\n        \"\"\"Convert to formal string, for repr().\"\"\"\n        L = [self._year, self._month, self._day,  # These are never zero\n             self._hour, self._minute, self._second, self._microsecond]\n        if L[-1] == 0:\n            del L[-1]\n        if L[-1] == 0:\n            del L[-1]\n        s = \"%s.%s(%s)\" % (self.__class__.__module__,\n                           self.__class__.__qualname__,\n                           \", \".join(map(str, L)))\n        if self._tzinfo is not None:\n            assert s[-1:] == \")\"\n            s = s[:-1] + \", tzinfo=%r\" % self._tzinfo + \")\"\n        if self._fold:\n            assert s[-1:] == \")\"\n            s = s[:-1] + \", fold=1)\"\n        return s\n\n    def __str__(self):\n        \"Convert to string, for str().\"\n        return self.isoformat(sep=' ')\n\n    @classmethod\n    def strptime(cls, date_string, format):\n        'string, format -> new datetime parsed from a string (like time.strptime()).'\n        import _strptime\n        return _strptime._strptime_datetime(cls, date_string, format)\n\n    def utcoffset(self):\n        \"\"\"Return the timezone offset as timedelta positive east of UTC (negative west of\n        UTC).\"\"\"\n        if self._tzinfo is None:\n            return None\n        offset = self._tzinfo.utcoffset(self)\n        _check_utc_offset(\"utcoffset\", offset)\n        return offset\n\n    def tzname(self):\n        \"\"\"Return the timezone name.\n\n        Note that the name is 100% informational -- there's no requirement that\n        it mean anything in particular. For example, \"GMT\", \"UTC\", \"-500\",\n        \"-5:00\", \"EDT\", \"US/Eastern\", \"America/New York\" are all valid replies.\n        \"\"\"\n        if self._tzinfo is None:\n            return None\n        name = self._tzinfo.tzname(self)\n        _check_tzname(name)\n        return name\n\n    def dst(self):\n        \"\"\"Return 0 if DST is not in effect, or the DST offset (as timedelta\n        positive eastward) if DST is in effect.\n\n        This is purely informational; the DST offset has already been added to\n        the UTC offset returned by utcoffset() if applicable, so there's no\n        need to consult dst() unless you're interested in displaying the DST\n        info.\n        \"\"\"\n        if self._tzinfo is None:\n            return None\n        offset = self._tzinfo.dst(self)\n        _check_utc_offset(\"dst\", offset)\n        return offset\n\n    # Comparisons of datetime objects with other.\n\n    def __eq__(self, other):\n        if isinstance(other, datetime):\n            return self._cmp(other, allow_mixed=True) == 0\n        elif not isinstance(other, date):\n            return NotImplemented\n        else:\n            return False\n\n    def __le__(self, other):\n        if isinstance(other, datetime):\n            return self._cmp(other) <= 0\n        elif not isinstance(other, date):\n            return NotImplemented\n        else:\n            _cmperror(self, other)\n\n    def __lt__(self, other):\n        if isinstance(other, datetime):\n            return self._cmp(other) < 0\n        elif not isinstance(other, date):\n            return NotImplemented\n        else:\n            _cmperror(self, other)\n\n    def __ge__(self, other):\n        if isinstance(other, datetime):\n            return self._cmp(other) >= 0\n        elif not isinstance(other, date):\n            return NotImplemented\n        else:\n            _cmperror(self, other)\n\n    def __gt__(self, other):\n        if isinstance(other, datetime):\n            return self._cmp(other) > 0\n        elif not isinstance(other, date):\n            return NotImplemented\n        else:\n            _cmperror(self, other)\n\n    def _cmp(self, other, allow_mixed=False):\n        assert isinstance(other, datetime)\n        mytz = self._tzinfo\n        ottz = other._tzinfo\n        myoff = otoff = None\n\n        if mytz is ottz:\n            base_compare = True\n        else:\n            myoff = self.utcoffset()\n            otoff = other.utcoffset()\n            # Assume that allow_mixed means that we are called from __eq__\n            if allow_mixed:\n                if myoff != self.replace(fold=not self.fold).utcoffset():\n                    return 2\n                if otoff != other.replace(fold=not other.fold).utcoffset():\n                    return 2\n            base_compare = myoff == otoff\n\n        if base_compare:\n            return _cmp((self._year, self._month, self._day,\n                         self._hour, self._minute, self._second,\n                         self._microsecond),\n                        (other._year, other._month, other._day,\n                         other._hour, other._minute, other._second,\n                         other._microsecond))\n        if myoff is None or otoff is None:\n            if allow_mixed:\n                return 2 # arbitrary non-zero value\n            else:\n                raise TypeError(\"cannot compare naive and aware datetimes\")\n        # XXX What follows could be done more efficiently...\n        diff = self - other     # this will take offsets into account\n        if diff.days < 0:\n            return -1\n        return diff and 1 or 0\n\n    def __add__(self, other):\n        \"Add a datetime and a timedelta.\"\n        if not isinstance(other, timedelta):\n            return NotImplemented\n        delta = timedelta(self.toordinal(),\n                          hours=self._hour,\n                          minutes=self._minute,\n                          seconds=self._second,\n                          microseconds=self._microsecond)\n        delta += other\n        hour, rem = divmod(delta.seconds, 3600)\n        minute, second = divmod(rem, 60)\n        if 0 < delta.days <= _MAXORDINAL:\n            return type(self).combine(date.fromordinal(delta.days),\n                                      time(hour, minute, second,\n                                           delta.microseconds,\n                                           tzinfo=self._tzinfo))\n        raise OverflowError(\"result out of range\")\n\n    __radd__ = __add__\n\n    def __sub__(self, other):\n        \"Subtract two datetimes, or a datetime and a timedelta.\"\n        if not isinstance(other, datetime):\n            if isinstance(other, timedelta):\n                return self + -other\n            return NotImplemented\n\n        days1 = self.toordinal()\n        days2 = other.toordinal()\n        secs1 = self._second + self._minute * 60 + self._hour * 3600\n        secs2 = other._second + other._minute * 60 + other._hour * 3600\n        base = timedelta(days1 - days2,\n                         secs1 - secs2,\n                         self._microsecond - other._microsecond)\n        if self._tzinfo is other._tzinfo:\n            return base\n        myoff = self.utcoffset()\n        otoff = other.utcoffset()\n        if myoff == otoff:\n            return base\n        if myoff is None or otoff is None:\n            raise TypeError(\"cannot mix naive and timezone-aware time\")\n        return base + otoff - myoff\n\n    def __hash__(self):\n        if self._hashcode == -1:\n            if self.fold:\n                t = self.replace(fold=0)\n            else:\n                t = self\n            tzoff = t.utcoffset()\n            if tzoff is None:\n                self._hashcode = hash(t._getstate()[0])\n            else:\n                days = _ymd2ord(self.year, self.month, self.day)\n                seconds = self.hour * 3600 + self.minute * 60 + self.second\n                self._hashcode = hash(timedelta(days, seconds, self.microsecond) - tzoff)\n        return self._hashcode\n\n    # Pickle support.\n\n    def _getstate(self, protocol=3):\n        yhi, ylo = divmod(self._year, 256)\n        us2, us3 = divmod(self._microsecond, 256)\n        us1, us2 = divmod(us2, 256)\n        m = self._month\n        if self._fold and protocol > 3:\n            m += 128\n        basestate = bytes([yhi, ylo, m, self._day,\n                           self._hour, self._minute, self._second,\n                           us1, us2, us3])\n        if self._tzinfo is None:\n            return (basestate,)\n        else:\n            return (basestate, self._tzinfo)\n\n    def __setstate(self, string, tzinfo):\n        if tzinfo is not None and not isinstance(tzinfo, _tzinfo_class):\n            raise TypeError(\"bad tzinfo state arg\")\n        (yhi, ylo, m, self._day, self._hour,\n         self._minute, self._second, us1, us2, us3) = string\n        if m > 127:\n            self._fold = 1\n            self._month = m - 128\n        else:\n            self._fold = 0\n            self._month = m\n        self._year = yhi * 256 + ylo\n        self._microsecond = (((us1 << 8) | us2) << 8) | us3\n        self._tzinfo = tzinfo\n\n    def __reduce_ex__(self, protocol):\n        return (self.__class__, self._getstate(protocol))\n\n    def __reduce__(self):\n        return self.__reduce_ex__(2)\n"
    },
    {
      "type": "class",
      "qualified_name": "pytz.tzinfo.timedelta",
      "module": "pytz.tzinfo",
      "signature": "(self, /, *args, **kwargs)",
      "return_description": null,
      "raises": [],
      "decorators": [
        "property",
        "property",
        "property"
      ],
      "examples": [],
      "docstring": "Difference between two datetime values.\n\ntimedelta(days=0, seconds=0, microseconds=0, milliseconds=0, minutes=0, hours=0, weeks=0)\n\nAll arguments are optional and default to 0.\nArguments may be integers or floats, and may be positive or negative.",
      "source_code": "class timedelta:\n    \"\"\"Represent the difference between two datetime objects.\n\n    Supported operators:\n\n    - add, subtract timedelta\n    - unary plus, minus, abs\n    - compare to timedelta\n    - multiply, divide by int\n\n    In addition, datetime supports subtraction of two datetime objects\n    returning a timedelta, and addition or subtraction of a datetime\n    and a timedelta giving a datetime.\n\n    Representation: (days, seconds, microseconds).  Why?  Because I\n    felt like it.\n    \"\"\"\n    __slots__ = '_days', '_seconds', '_microseconds', '_hashcode'\n\n    def __new__(cls, days=0, seconds=0, microseconds=0,\n                milliseconds=0, minutes=0, hours=0, weeks=0):\n        # Doing this efficiently and accurately in C is going to be difficult\n        # and error-prone, due to ubiquitous overflow possibilities, and that\n        # C double doesn't have enough bits of precision to represent\n        # microseconds over 10K years faithfully.  The code here tries to make\n        # explicit where go-fast assumptions can be relied on, in order to\n        # guide the C implementation; it's way more convoluted than speed-\n        # ignoring auto-overflow-to-long idiomatic Python could be.\n\n        # XXX Check that all inputs are ints or floats.\n\n        # Final values, all integer.\n        # s and us fit in 32-bit signed ints; d isn't bounded.\n        d = s = us = 0\n\n        # Normalize everything to days, seconds, microseconds.\n        days += weeks*7\n        seconds += minutes*60 + hours*3600\n        microseconds += milliseconds*1000\n\n        # Get rid of all fractions, and normalize s and us.\n        # Take a deep breath <wink>.\n        if isinstance(days, float):\n            dayfrac, days = _math.modf(days)\n            daysecondsfrac, daysecondswhole = _math.modf(dayfrac * (24.*3600.))\n            assert daysecondswhole == int(daysecondswhole)  # can't overflow\n            s = int(daysecondswhole)\n            assert days == int(days)\n            d = int(days)\n        else:\n            daysecondsfrac = 0.0\n            d = days\n        assert isinstance(daysecondsfrac, float)\n        assert abs(daysecondsfrac) <= 1.0\n        assert isinstance(d, int)\n        assert abs(s) <= 24 * 3600\n        # days isn't referenced again before redefinition\n\n        if isinstance(seconds, float):\n            secondsfrac, seconds = _math.modf(seconds)\n            assert seconds == int(seconds)\n            seconds = int(seconds)\n            secondsfrac += daysecondsfrac\n            assert abs(secondsfrac) <= 2.0\n        else:\n            secondsfrac = daysecondsfrac\n        # daysecondsfrac isn't referenced again\n        assert isinstance(secondsfrac, float)\n        assert abs(secondsfrac) <= 2.0\n\n        assert isinstance(seconds, int)\n        days, seconds = divmod(seconds, 24*3600)\n        d += days\n        s += int(seconds)    # can't overflow\n        assert isinstance(s, int)\n        assert abs(s) <= 2 * 24 * 3600\n        # seconds isn't referenced again before redefinition\n\n        usdouble = secondsfrac * 1e6\n        assert abs(usdouble) < 2.1e6    # exact value not critical\n        # secondsfrac isn't referenced again\n\n        if isinstance(microseconds, float):\n            microseconds = round(microseconds + usdouble)\n            seconds, microseconds = divmod(microseconds, 1000000)\n            days, seconds = divmod(seconds, 24*3600)\n            d += days\n            s += seconds\n        else:\n            microseconds = int(microseconds)\n            seconds, microseconds = divmod(microseconds, 1000000)\n            days, seconds = divmod(seconds, 24*3600)\n            d += days\n            s += seconds\n            microseconds = round(microseconds + usdouble)\n        assert isinstance(s, int)\n        assert isinstance(microseconds, int)\n        assert abs(s) <= 3 * 24 * 3600\n        assert abs(microseconds) < 3.1e6\n\n        # Just a little bit of carrying possible for microseconds and seconds.\n        seconds, us = divmod(microseconds, 1000000)\n        s += seconds\n        days, s = divmod(s, 24*3600)\n        d += days\n\n        assert isinstance(d, int)\n        assert isinstance(s, int) and 0 <= s < 24*3600\n        assert isinstance(us, int) and 0 <= us < 1000000\n\n        if abs(d) > 999999999:\n            raise OverflowError(\"timedelta # of days is too large: %d\" % d)\n\n        self = object.__new__(cls)\n        self._days = d\n        self._seconds = s\n        self._microseconds = us\n        self._hashcode = -1\n        return self\n\n    def __repr__(self):\n        args = []\n        if self._days:\n            args.append(\"days=%d\" % self._days)\n        if self._seconds:\n            args.append(\"seconds=%d\" % self._seconds)\n        if self._microseconds:\n            args.append(\"microseconds=%d\" % self._microseconds)\n        if not args:\n            args.append('0')\n        return \"%s.%s(%s)\" % (self.__class__.__module__,\n                              self.__class__.__qualname__,\n                              ', '.join(args))\n\n    def __str__(self):\n        mm, ss = divmod(self._seconds, 60)\n        hh, mm = divmod(mm, 60)\n        s = \"%d:%02d:%02d\" % (hh, mm, ss)\n        if self._days:\n            def plural(n):\n                return n, abs(n) != 1 and \"s\" or \"\"\n            s = (\"%d day%s, \" % plural(self._days)) + s\n        if self._microseconds:\n            s = s + \".%06d\" % self._microseconds\n        return s\n\n    def total_seconds(self):\n        \"\"\"Total seconds in the duration.\"\"\"\n        return ((self.days * 86400 + self.seconds) * 10**6 +\n                self.microseconds) / 10**6\n\n    # Read-only field accessors\n    @property\n    def days(self):\n        \"\"\"days\"\"\"\n        return self._days\n\n    @property\n    def seconds(self):\n        \"\"\"seconds\"\"\"\n        return self._seconds\n\n    @property\n    def microseconds(self):\n        \"\"\"microseconds\"\"\"\n        return self._microseconds\n\n    def __add__(self, other):\n        if isinstance(other, timedelta):\n            # for CPython compatibility, we cannot use\n            # our __class__ here, but need a real timedelta\n            return timedelta(self._days + other._days,\n                             self._seconds + other._seconds,\n                             self._microseconds + other._microseconds)\n        return NotImplemented\n\n    __radd__ = __add__\n\n    def __sub__(self, other):\n        if isinstance(other, timedelta):\n            # for CPython compatibility, we cannot use\n            # our __class__ here, but need a real timedelta\n            return timedelta(self._days - other._days,\n                             self._seconds - other._seconds,\n                             self._microseconds - other._microseconds)\n        return NotImplemented\n\n    def __rsub__(self, other):\n        if isinstance(other, timedelta):\n            return -self + other\n        return NotImplemented\n\n    def __neg__(self):\n        # for CPython compatibility, we cannot use\n        # our __class__ here, but need a real timedelta\n        return timedelta(-self._days,\n                         -self._seconds,\n                         -self._microseconds)\n\n    def __pos__(self):\n        return self\n\n    def __abs__(self):\n        if self._days < 0:\n            return -self\n        else:\n            return self\n\n    def __mul__(self, other):\n        if isinstance(other, int):\n            # for CPython compatibility, we cannot use\n            # our __class__ here, but need a real timedelta\n            return timedelta(self._days * other,\n                             self._seconds * other,\n                             self._microseconds * other)\n        if isinstance(other, float):\n            usec = self._to_microseconds()\n            a, b = other.as_integer_ratio()\n            return timedelta(0, 0, _divide_and_round(usec * a, b))\n        return NotImplemented\n\n    __rmul__ = __mul__\n\n    def _to_microseconds(self):\n        return ((self._days * (24*3600) + self._seconds) * 1000000 +\n                self._microseconds)\n\n    def __floordiv__(self, other):\n        if not isinstance(other, (int, timedelta)):\n            return NotImplemented\n        usec = self._to_microseconds()\n        if isinstance(other, timedelta):\n            return usec // other._to_microseconds()\n        if isinstance(other, int):\n            return timedelta(0, 0, usec // other)\n\n    def __truediv__(self, other):\n        if not isinstance(other, (int, float, timedelta)):\n            return NotImplemented\n        usec = self._to_microseconds()\n        if isinstance(other, timedelta):\n            return usec / other._to_microseconds()\n        if isinstance(other, int):\n            return timedelta(0, 0, _divide_and_round(usec, other))\n        if isinstance(other, float):\n            a, b = other.as_integer_ratio()\n            return timedelta(0, 0, _divide_and_round(b * usec, a))\n\n    def __mod__(self, other):\n        if isinstance(other, timedelta):\n            r = self._to_microseconds() % other._to_microseconds()\n            return timedelta(0, 0, r)\n        return NotImplemented\n\n    def __divmod__(self, other):\n        if isinstance(other, timedelta):\n            q, r = divmod(self._to_microseconds(),\n                          other._to_microseconds())\n            return q, timedelta(0, 0, r)\n        return NotImplemented\n\n    # Comparisons of timedelta objects with other.\n\n    def __eq__(self, other):\n        if isinstance(other, timedelta):\n            return self._cmp(other) == 0\n        else:\n            return NotImplemented\n\n    def __le__(self, other):\n        if isinstance(other, timedelta):\n            return self._cmp(other) <= 0\n        else:\n            return NotImplemented\n\n    def __lt__(self, other):\n        if isinstance(other, timedelta):\n            return self._cmp(other) < 0\n        else:\n            return NotImplemented\n\n    def __ge__(self, other):\n        if isinstance(other, timedelta):\n            return self._cmp(other) >= 0\n        else:\n            return NotImplemented\n\n    def __gt__(self, other):\n        if isinstance(other, timedelta):\n            return self._cmp(other) > 0\n        else:\n            return NotImplemented\n\n    def _cmp(self, other):\n        assert isinstance(other, timedelta)\n        return _cmp(self._getstate(), other._getstate())\n\n    def __hash__(self):\n        if self._hashcode == -1:\n            self._hashcode = hash(self._getstate())\n        return self._hashcode\n\n    def __bool__(self):\n        return (self._days != 0 or\n                self._seconds != 0 or\n                self._microseconds != 0)\n\n    # Pickle support.\n\n    def _getstate(self):\n        return (self._days, self._seconds, self._microseconds)\n\n    def __reduce__(self):\n        return (self.__class__, self._getstate())\n"
    },
    {
      "type": "class",
      "qualified_name": "pytz.tzinfo.tzinfo",
      "module": "pytz.tzinfo",
      "signature": "(self, /, *args, **kwargs)",
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Abstract base class for time zone info objects.",
      "source_code": "class tzinfo:\n    \"\"\"Abstract base class for time zone info classes.\n\n    Subclasses must override the name(), utcoffset() and dst() methods.\n    \"\"\"\n    __slots__ = ()\n\n    def tzname(self, dt):\n        \"datetime -> string name of time zone.\"\n        raise NotImplementedError(\"tzinfo subclass must override tzname()\")\n\n    def utcoffset(self, dt):\n        \"datetime -> timedelta, positive for east of UTC, negative for west of UTC\"\n        raise NotImplementedError(\"tzinfo subclass must override utcoffset()\")\n\n    def dst(self, dt):\n        \"\"\"datetime -> DST offset as timedelta, positive for east of UTC.\n\n        Return 0 if DST not in effect.  utcoffset() must include the DST\n        offset.\n        \"\"\"\n        raise NotImplementedError(\"tzinfo subclass must override dst()\")\n\n    def fromutc(self, dt):\n        \"datetime in UTC -> datetime in local time.\"\n\n        if not isinstance(dt, datetime):\n            raise TypeError(\"fromutc() requires a datetime argument\")\n        if dt.tzinfo is not self:\n            raise ValueError(\"dt.tzinfo is not self\")\n\n        dtoff = dt.utcoffset()\n        if dtoff is None:\n            raise ValueError(\"fromutc() requires a non-None utcoffset() \"\n                             \"result\")\n\n        # See the long comment block at the end of this file for an\n        # explanation of this algorithm.\n        dtdst = dt.dst()\n        if dtdst is None:\n            raise ValueError(\"fromutc() requires a non-None dst() result\")\n        delta = dtoff - dtdst\n        if delta:\n            dt += delta\n            dtdst = dt.dst()\n            if dtdst is None:\n                raise ValueError(\"fromutc(): dt.dst gave inconsistent \"\n                                 \"results; cannot convert\")\n        return dt + dtdst\n\n    # Pickle support.\n\n    def __reduce__(self):\n        getinitargs = getattr(self, \"__getinitargs__\", None)\n        if getinitargs:\n            args = getinitargs()\n        else:\n            args = ()\n        return (self.__class__, args, self.__getstate__())\n"
    },
    {
      "type": "method",
      "qualified_name": "pytz.LazyDict.get",
      "module": "pytz",
      "signature": "(self, key, default=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "key": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "default": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "D.get(k[,d]) -> D[k] if k in D, else d.  d defaults to None.",
      "source_code": null
    },
    {
      "type": "method",
      "qualified_name": "pytz.LazyDict.items",
      "module": "pytz",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "D.items() -> a set-like object providing a view on D's items",
      "source_code": null
    },
    {
      "type": "method",
      "qualified_name": "pytz.LazyDict.keys",
      "module": "pytz",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "D.keys() -> a set-like object providing a view on D's keys",
      "source_code": "    def keys(self):\n        if self.data is None:\n            _fill_lock.acquire()\n            try:\n                if self.data is None:\n                    self._fill()\n            finally:\n                _fill_lock.release()\n        return self.data.keys()\n"
    },
    {
      "type": "method",
      "qualified_name": "pytz.LazyDict.values",
      "module": "pytz",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "D.values() -> an object providing a view on D's values",
      "source_code": null
    },
    {
      "type": "method",
      "qualified_name": "pytz.lazy.DictMixin.get",
      "module": "pytz.lazy",
      "signature": "(self, key, default=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "key": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "default": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "D.get(k[,d]) -> D[k] if k in D, else d.  d defaults to None.",
      "source_code": null
    },
    {
      "type": "method",
      "qualified_name": "pytz.lazy.DictMixin.items",
      "module": "pytz.lazy",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "D.items() -> a set-like object providing a view on D's items",
      "source_code": null
    },
    {
      "type": "method",
      "qualified_name": "pytz.lazy.DictMixin.keys",
      "module": "pytz.lazy",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "D.keys() -> a set-like object providing a view on D's keys",
      "source_code": null
    },
    {
      "type": "method",
      "qualified_name": "pytz.lazy.DictMixin.values",
      "module": "pytz.lazy",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "D.values() -> an object providing a view on D's values",
      "source_code": null
    },
    {
      "type": "method",
      "qualified_name": "pytz.lazy.LazyDict.get",
      "module": "pytz.lazy",
      "signature": "(self, key, default=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "key": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "default": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "D.get(k[,d]) -> D[k] if k in D, else d.  d defaults to None.",
      "source_code": null
    },
    {
      "type": "method",
      "qualified_name": "pytz.lazy.LazyDict.items",
      "module": "pytz.lazy",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "D.items() -> a set-like object providing a view on D's items",
      "source_code": null
    },
    {
      "type": "method",
      "qualified_name": "pytz.lazy.LazyDict.keys",
      "module": "pytz.lazy",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "D.keys() -> a set-like object providing a view on D's keys",
      "source_code": "    def keys(self):\n        if self.data is None:\n            _fill_lock.acquire()\n            try:\n                if self.data is None:\n                    self._fill()\n            finally:\n                _fill_lock.release()\n        return self.data.keys()\n"
    },
    {
      "type": "method",
      "qualified_name": "pytz.lazy.LazyDict.values",
      "module": "pytz.lazy",
      "signature": "(self)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "D.values() -> an object providing a view on D's values",
      "source_code": null
    },
    {
      "type": "method",
      "qualified_name": "pytz.reference.FixedOffset.dst",
      "module": "pytz.reference",
      "signature": "(self, dt)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "dt": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "datetime -> DST offset as timedelta positive east of UTC.",
      "source_code": "    def dst(self, dt):\n        return ZERO\n"
    },
    {
      "type": "method",
      "qualified_name": "pytz.reference.FixedOffset.tzname",
      "module": "pytz.reference",
      "signature": "(self, dt)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "dt": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "datetime -> string name of time zone.",
      "source_code": "    def tzname(self, dt):\n        return self.__name\n"
    },
    {
      "type": "method",
      "qualified_name": "pytz.reference.FixedOffset.utcoffset",
      "module": "pytz.reference",
      "signature": "(self, dt)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "dt": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "datetime -> timedelta showing offset from UTC, negative values indicating West of UTC",
      "source_code": "    def utcoffset(self, dt):\n        return self.__offset\n"
    },
    {
      "type": "method",
      "qualified_name": "pytz.reference.LocalTimezone.dst",
      "module": "pytz.reference",
      "signature": "(self, dt)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "dt": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "datetime -> DST offset as timedelta positive east of UTC.",
      "source_code": "    def dst(self, dt):\n        if self._isdst(dt):\n            return DSTDIFF\n        else:\n            return ZERO\n"
    },
    {
      "type": "method",
      "qualified_name": "pytz.reference.LocalTimezone.tzname",
      "module": "pytz.reference",
      "signature": "(self, dt)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "dt": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "datetime -> string name of time zone.",
      "source_code": "    def tzname(self, dt):\n        return _time.tzname[self._isdst(dt)]\n"
    },
    {
      "type": "method",
      "qualified_name": "pytz.reference.LocalTimezone.utcoffset",
      "module": "pytz.reference",
      "signature": "(self, dt)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "dt": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "datetime -> timedelta showing offset from UTC, negative values indicating West of UTC",
      "source_code": "    def utcoffset(self, dt):\n        if self._isdst(dt):\n            return DSTOFFSET\n        else:\n            return STDOFFSET\n"
    },
    {
      "type": "method",
      "qualified_name": "pytz.reference.USTimeZone.dst",
      "module": "pytz.reference",
      "signature": "(self, dt)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "dt": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "datetime -> DST offset as timedelta positive east of UTC.",
      "source_code": "    def dst(self, dt):\n        if dt is None or dt.tzinfo is None:\n            # An exception may be sensible here, in one or both cases.\n            # It depends on how you want to treat them.  The default\n            # fromutc() implementation (called by the default astimezone()\n            # implementation) passes a datetime with dt.tzinfo is self.\n            return ZERO\n        assert dt.tzinfo is self\n\n        # Find first Sunday in April & the last in October.\n        start = first_sunday_on_or_after(DSTSTART.replace(year=dt.year))\n        end = first_sunday_on_or_after(DSTEND.replace(year=dt.year))\n\n        # Can't compare naive to aware objects, so strip the timezone from\n        # dt first.\n        if start <= dt.replace(tzinfo=None) < end:\n            return HOUR\n        else:\n            return ZERO\n"
    },
    {
      "type": "method",
      "qualified_name": "pytz.reference.USTimeZone.tzname",
      "module": "pytz.reference",
      "signature": "(self, dt)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "dt": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "datetime -> string name of time zone.",
      "source_code": "    def tzname(self, dt):\n        if self.dst(dt):\n            return self.dstname\n        else:\n            return self.stdname\n"
    },
    {
      "type": "method",
      "qualified_name": "pytz.reference.USTimeZone.utcoffset",
      "module": "pytz.reference",
      "signature": "(self, dt)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "dt": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "datetime -> timedelta showing offset from UTC, negative values indicating West of UTC",
      "source_code": "    def utcoffset(self, dt):\n        return self.stdoffset + self.dst(dt)\n"
    },
    {
      "type": "method",
      "qualified_name": "pytz.tzfile.DstTzInfo.dst",
      "module": "pytz.tzfile",
      "signature": "(self, dt, is_dst=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "dt": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "is_dst": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [
        ">>> from pytz import timezone",
        ">>> tz = timezone('America/St_Johns')",
        ">>> normal = datetime(2009, 9, 1)",
        ">>> str(tz.dst(normal))",
        ">>> str(tz.dst(normal, is_dst=False))",
        ">>> str(tz.dst(normal, is_dst=True))",
        ">>> ambiguous = datetime(2009, 10, 31, 23, 30)",
        ">>> str(tz.dst(ambiguous, is_dst=False))",
        ">>> str(tz.dst(ambiguous, is_dst=True))",
        ">>> try:"
      ],
      "docstring": "See datetime.tzinfo.dst\n\nThe is_dst parameter may be used to remove ambiguity during DST\ntransitions.\n\n>>> from pytz import timezone\n>>> tz = timezone('America/St_Johns')\n\n>>> normal = datetime(2009, 9, 1)\n\n>>> str(tz.dst(normal))\n'1:00:00'\n>>> str(tz.dst(normal, is_dst=False))\n'1:00:00'\n>>> str(tz.dst(normal, is_dst=True))\n'1:00:00'\n\n>>> ambiguous = datetime(2009, 10, 31, 23, 30)\n\n>>> str(tz.dst(ambiguous, is_dst=False))\n'0:00:00'\n>>> str(tz.dst(ambiguous, is_dst=True))\n'1:00:00'\n>>> try:\n...     tz.dst(ambiguous)\n... except AmbiguousTimeError:\n...     print('Ambiguous')\nAmbiguous",
      "source_code": "    def dst(self, dt, is_dst=None):\n        '''See datetime.tzinfo.dst\n\n        The is_dst parameter may be used to remove ambiguity during DST\n        transitions.\n\n        >>> from pytz import timezone\n        >>> tz = timezone('America/St_Johns')\n\n        >>> normal = datetime(2009, 9, 1)\n\n        >>> str(tz.dst(normal))\n        '1:00:00'\n        >>> str(tz.dst(normal, is_dst=False))\n        '1:00:00'\n        >>> str(tz.dst(normal, is_dst=True))\n        '1:00:00'\n\n        >>> ambiguous = datetime(2009, 10, 31, 23, 30)\n\n        >>> str(tz.dst(ambiguous, is_dst=False))\n        '0:00:00'\n        >>> str(tz.dst(ambiguous, is_dst=True))\n        '1:00:00'\n        >>> try:\n        ...     tz.dst(ambiguous)\n        ... except AmbiguousTimeError:\n        ...     print('Ambiguous')\n        Ambiguous\n\n        '''\n        if dt is None:\n            return None\n        elif dt.tzinfo is not self:\n            dt = self.localize(dt, is_dst)\n            return dt.tzinfo._dst\n        else:\n            return self._dst\n"
    },
    {
      "type": "method",
      "qualified_name": "pytz.tzfile.DstTzInfo.fromutc",
      "module": "pytz.tzfile",
      "signature": "(self, dt)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "dt": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "See datetime.tzinfo.fromutc",
      "source_code": "    def fromutc(self, dt):\n        '''See datetime.tzinfo.fromutc'''\n        if (dt.tzinfo is not None and\n                getattr(dt.tzinfo, '_tzinfos', None) is not self._tzinfos):\n            raise ValueError('fromutc: dt.tzinfo is not self')\n        dt = dt.replace(tzinfo=None)\n        idx = max(0, bisect_right(self._utc_transition_times, dt) - 1)\n        inf = self._transition_info[idx]\n        return (dt + inf[0]).replace(tzinfo=self._tzinfos[inf])\n"
    },
    {
      "type": "method",
      "qualified_name": "pytz.tzfile.DstTzInfo.localize",
      "module": "pytz.tzfile",
      "signature": "(self, dt, is_dst=False)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "dt": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "is_dst": {
          "default": "False",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [
        ">>> from pytz import timezone",
        ">>> fmt = '%Y-%m-%d %H:%M:%S %Z (%z)'",
        ">>> amdam = timezone('Europe/Amsterdam')",
        ">>> dt  = datetime(2004, 10, 31, 2, 0, 0)",
        ">>> loc_dt1 = amdam.localize(dt, is_dst=True)",
        ">>> loc_dt2 = amdam.localize(dt, is_dst=False)",
        ">>> loc_dt1.strftime(fmt)",
        ">>> loc_dt2.strftime(fmt)",
        ">>> str(loc_dt2 - loc_dt1)",
        ">>> try:",
        ">>> amdam.localize(dt) == amdam.localize(dt, False)",
        ">>> pacific = timezone('US/Pacific')",
        ">>> dt = datetime(2008, 3, 9, 2, 0, 0)",
        ">>> ploc_dt1 = pacific.localize(dt, is_dst=True)",
        ">>> ploc_dt2 = pacific.localize(dt, is_dst=False)",
        ">>> ploc_dt1.strftime(fmt)",
        ">>> ploc_dt2.strftime(fmt)",
        ">>> str(ploc_dt2 - ploc_dt1)",
        ">>> try:"
      ],
      "docstring": "Convert naive time to local time.\n\nThis method should be used to construct localtimes, rather\nthan passing a tzinfo argument to a datetime constructor.\n\nis_dst is used to determine the correct timezone in the ambigous\nperiod at the end of daylight saving time.\n\n>>> from pytz import timezone\n>>> fmt = '%Y-%m-%d %H:%M:%S %Z (%z)'\n>>> amdam = timezone('Europe/Amsterdam')\n>>> dt  = datetime(2004, 10, 31, 2, 0, 0)\n>>> loc_dt1 = amdam.localize(dt, is_dst=True)\n>>> loc_dt2 = amdam.localize(dt, is_dst=False)\n>>> loc_dt1.strftime(fmt)\n'2004-10-31 02:00:00 CEST (+0200)'\n>>> loc_dt2.strftime(fmt)\n'2004-10-31 02:00:00 CET (+0100)'\n>>> str(loc_dt2 - loc_dt1)\n'1:00:00'\n\nUse is_dst=None to raise an AmbiguousTimeError for ambiguous\ntimes at the end of daylight saving time\n\n>>> try:\n...     loc_dt1 = amdam.localize(dt, is_dst=None)\n... except AmbiguousTimeError:\n...     print('Ambiguous')\nAmbiguous\n\nis_dst defaults to False\n\n>>> amdam.localize(dt) == amdam.localize(dt, False)\nTrue\n\nis_dst is also used to determine the correct timezone in the\nwallclock times jumped over at the start of daylight saving time.\n\n>>> pacific = timezone('US/Pacific')\n>>> dt = datetime(2008, 3, 9, 2, 0, 0)\n>>> ploc_dt1 = pacific.localize(dt, is_dst=True)\n>>> ploc_dt2 = pacific.localize(dt, is_dst=False)\n>>> ploc_dt1.strftime(fmt)\n'2008-03-09 02:00:00 PDT (-0700)'\n>>> ploc_dt2.strftime(fmt)\n'2008-03-09 02:00:00 PST (-0800)'\n>>> str(ploc_dt2 - ploc_dt1)\n'1:00:00'\n\nUse is_dst=None to raise a NonExistentTimeError for these skipped\ntimes.\n\n>>> try:\n...     loc_dt1 = pacific.localize(dt, is_dst=None)\n... except NonExistentTimeError:\n...     print('Non-existent')\nNon-existent",
      "source_code": "    def localize(self, dt, is_dst=False):\n        '''Convert naive time to local time.\n\n        This method should be used to construct localtimes, rather\n        than passing a tzinfo argument to a datetime constructor.\n\n        is_dst is used to determine the correct timezone in the ambigous\n        period at the end of daylight saving time.\n\n        >>> from pytz import timezone\n        >>> fmt = '%Y-%m-%d %H:%M:%S %Z (%z)'\n        >>> amdam = timezone('Europe/Amsterdam')\n        >>> dt  = datetime(2004, 10, 31, 2, 0, 0)\n        >>> loc_dt1 = amdam.localize(dt, is_dst=True)\n        >>> loc_dt2 = amdam.localize(dt, is_dst=False)\n        >>> loc_dt1.strftime(fmt)\n        '2004-10-31 02:00:00 CEST (+0200)'\n        >>> loc_dt2.strftime(fmt)\n        '2004-10-31 02:00:00 CET (+0100)'\n        >>> str(loc_dt2 - loc_dt1)\n        '1:00:00'\n\n        Use is_dst=None to raise an AmbiguousTimeError for ambiguous\n        times at the end of daylight saving time\n\n        >>> try:\n        ...     loc_dt1 = amdam.localize(dt, is_dst=None)\n        ... except AmbiguousTimeError:\n        ...     print('Ambiguous')\n        Ambiguous\n\n        is_dst defaults to False\n\n        >>> amdam.localize(dt) == amdam.localize(dt, False)\n        True\n\n        is_dst is also used to determine the correct timezone in the\n        wallclock times jumped over at the start of daylight saving time.\n\n        >>> pacific = timezone('US/Pacific')\n        >>> dt = datetime(2008, 3, 9, 2, 0, 0)\n        >>> ploc_dt1 = pacific.localize(dt, is_dst=True)\n        >>> ploc_dt2 = pacific.localize(dt, is_dst=False)\n        >>> ploc_dt1.strftime(fmt)\n        '2008-03-09 02:00:00 PDT (-0700)'\n        >>> ploc_dt2.strftime(fmt)\n        '2008-03-09 02:00:00 PST (-0800)'\n        >>> str(ploc_dt2 - ploc_dt1)\n        '1:00:00'\n\n        Use is_dst=None to raise a NonExistentTimeError for these skipped\n        times.\n\n        >>> try:\n        ...     loc_dt1 = pacific.localize(dt, is_dst=None)\n        ... except NonExistentTimeError:\n        ...     print('Non-existent')\n        Non-existent\n        '''\n        if dt.tzinfo is not None:\n            raise ValueError('Not naive datetime (tzinfo is already set)')\n\n        # Find the two best possibilities.\n        possible_loc_dt = set()\n        for delta in [timedelta(days=-1), timedelta(days=1)]:\n            loc_dt = dt + delta\n            idx = max(0, bisect_right(\n                self._utc_transition_times, loc_dt) - 1)\n            inf = self._transition_info[idx]\n            tzinfo = self._tzinfos[inf]\n            loc_dt = tzinfo.normalize(dt.replace(tzinfo=tzinfo))\n            if loc_dt.replace(tzinfo=None) == dt:\n                possible_loc_dt.add(loc_dt)\n\n        if len(possible_loc_dt) == 1:\n            return possible_loc_dt.pop()\n\n        # If there are no possibly correct timezones, we are attempting\n        # to convert a time that never happened - the time period jumped\n        # during the start-of-DST transition period.\n        if len(possible_loc_dt) == 0:\n            # If we refuse to guess, raise an exception.\n            if is_dst is None:\n                raise NonExistentTimeError(dt)\n\n            # If we are forcing the pre-DST side of the DST transition, we\n            # obtain the correct timezone by winding the clock forward a few\n            # hours.\n            elif is_dst:\n                return self.localize(\n                    dt + timedelta(hours=6), is_dst=True) - timedelta(hours=6)\n\n            # If we are forcing the post-DST side of the DST transition, we\n            # obtain the correct timezone by winding the clock back.\n            else:\n                return self.localize(\n                    dt - timedelta(hours=6),\n                    is_dst=False) + timedelta(hours=6)\n\n        # If we get this far, we have multiple possible timezones - this\n        # is an ambiguous case occurring during the end-of-DST transition.\n\n        # If told to be strict, raise an exception since we have an\n        # ambiguous case\n        if is_dst is None:\n            raise AmbiguousTimeError(dt)\n\n        # Filter out the possiblilities that don't match the requested\n        # is_dst\n        filtered_possible_loc_dt = [\n            p for p in possible_loc_dt if bool(p.tzinfo._dst) == is_dst\n        ]\n\n        # Hopefully we only have one possibility left. Return it.\n        if len(filtered_possible_loc_dt) == 1:\n            return filtered_possible_loc_dt[0]\n\n        if len(filtered_possible_loc_dt) == 0:\n            filtered_possible_loc_dt = list(possible_loc_dt)\n\n        # If we get this far, we have in a wierd timezone transition\n        # where the clocks have been wound back but is_dst is the same\n        # in both (eg. Europe/Warsaw 1915 when they switched to CET).\n        # At this point, we just have to guess unless we allow more\n        # hints to be passed in (such as the UTC offset or abbreviation),\n        # but that is just getting silly.\n        #\n        # Choose the earliest (by UTC) applicable timezone if is_dst=True\n        # Choose the latest (by UTC) applicable timezone if is_dst=False\n        # i.e., behave like end-of-DST transition\n        dates = {}  # utc -> local\n        for local_dt in filtered_possible_loc_dt:\n            utc_time = (\n                local_dt.replace(tzinfo=None) - local_dt.tzinfo._utcoffset)\n            assert utc_time not in dates\n            dates[utc_time] = local_dt\n        return dates[[min, max][not is_dst](dates)]\n"
    },
    {
      "type": "method",
      "qualified_name": "pytz.tzfile.DstTzInfo.normalize",
      "module": "pytz.tzfile",
      "signature": "(self, dt)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "dt": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [
        ">>> from pytz import timezone",
        ">>> utc = timezone('UTC')",
        ">>> eastern = timezone('US/Eastern')",
        ">>> fmt = '%Y-%m-%d %H:%M:%S %Z (%z)'",
        ">>> utc_dt = datetime(2002, 10, 27, 6, 0, 0, tzinfo=utc)",
        ">>> loc_dt = utc_dt.astimezone(eastern)",
        ">>> loc_dt.strftime(fmt)",
        ">>> before = loc_dt - timedelta(minutes=10)",
        ">>> before.strftime(fmt)",
        ">>> before = eastern.normalize(before)",
        ">>> before.strftime(fmt)",
        ">>> th = timezone('Asia/Bangkok')",
        ">>> am = timezone('Europe/Amsterdam')",
        ">>> dt = th.localize(datetime(2011, 5, 7, 1, 2, 3))",
        ">>> fmt = '%Y-%m-%d %H:%M:%S %Z (%z)'",
        ">>> am.normalize(dt).strftime(fmt)"
      ],
      "docstring": "Correct the timezone information on the given datetime\n\nIf date arithmetic crosses DST boundaries, the tzinfo\nis not magically adjusted. This method normalizes the\ntzinfo to the correct one.\n\nTo test, first we need to do some setup\n\n>>> from pytz import timezone\n>>> utc = timezone('UTC')\n>>> eastern = timezone('US/Eastern')\n>>> fmt = '%Y-%m-%d %H:%M:%S %Z (%z)'\n\nWe next create a datetime right on an end-of-DST transition point,\nthe instant when the wallclocks are wound back one hour.\n\n>>> utc_dt = datetime(2002, 10, 27, 6, 0, 0, tzinfo=utc)\n>>> loc_dt = utc_dt.astimezone(eastern)\n>>> loc_dt.strftime(fmt)\n'2002-10-27 01:00:00 EST (-0500)'\n\nNow, if we subtract a few minutes from it, note that the timezone\ninformation has not changed.\n\n>>> before = loc_dt - timedelta(minutes=10)\n>>> before.strftime(fmt)\n'2002-10-27 00:50:00 EST (-0500)'\n\nBut we can fix that by calling the normalize method\n\n>>> before = eastern.normalize(before)\n>>> before.strftime(fmt)\n'2002-10-27 01:50:00 EDT (-0400)'\n\nThe supported method of converting between timezones is to use\ndatetime.astimezone(). Currently, normalize() also works:\n\n>>> th = timezone('Asia/Bangkok')\n>>> am = timezone('Europe/Amsterdam')\n>>> dt = th.localize(datetime(2011, 5, 7, 1, 2, 3))\n>>> fmt = '%Y-%m-%d %H:%M:%S %Z (%z)'\n>>> am.normalize(dt).strftime(fmt)\n'2011-05-06 20:02:03 CEST (+0200)'",
      "source_code": "    def normalize(self, dt):\n        '''Correct the timezone information on the given datetime\n\n        If date arithmetic crosses DST boundaries, the tzinfo\n        is not magically adjusted. This method normalizes the\n        tzinfo to the correct one.\n\n        To test, first we need to do some setup\n\n        >>> from pytz import timezone\n        >>> utc = timezone('UTC')\n        >>> eastern = timezone('US/Eastern')\n        >>> fmt = '%Y-%m-%d %H:%M:%S %Z (%z)'\n\n        We next create a datetime right on an end-of-DST transition point,\n        the instant when the wallclocks are wound back one hour.\n\n        >>> utc_dt = datetime(2002, 10, 27, 6, 0, 0, tzinfo=utc)\n        >>> loc_dt = utc_dt.astimezone(eastern)\n        >>> loc_dt.strftime(fmt)\n        '2002-10-27 01:00:00 EST (-0500)'\n\n        Now, if we subtract a few minutes from it, note that the timezone\n        information has not changed.\n\n        >>> before = loc_dt - timedelta(minutes=10)\n        >>> before.strftime(fmt)\n        '2002-10-27 00:50:00 EST (-0500)'\n\n        But we can fix that by calling the normalize method\n\n        >>> before = eastern.normalize(before)\n        >>> before.strftime(fmt)\n        '2002-10-27 01:50:00 EDT (-0400)'\n\n        The supported method of converting between timezones is to use\n        datetime.astimezone(). Currently, normalize() also works:\n\n        >>> th = timezone('Asia/Bangkok')\n        >>> am = timezone('Europe/Amsterdam')\n        >>> dt = th.localize(datetime(2011, 5, 7, 1, 2, 3))\n        >>> fmt = '%Y-%m-%d %H:%M:%S %Z (%z)'\n        >>> am.normalize(dt).strftime(fmt)\n        '2011-05-06 20:02:03 CEST (+0200)'\n        '''\n        if dt.tzinfo is None:\n            raise ValueError('Naive time - no tzinfo set')\n\n        # Convert dt in localtime to UTC\n        offset = dt.tzinfo._utcoffset\n        dt = dt.replace(tzinfo=None)\n        dt = dt - offset\n        # convert it back, and return it\n        return self.fromutc(dt)\n"
    },
    {
      "type": "method",
      "qualified_name": "pytz.tzfile.DstTzInfo.tzname",
      "module": "pytz.tzfile",
      "signature": "(self, dt, is_dst=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "dt": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "is_dst": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [
        ">>> from pytz import timezone",
        ">>> tz = timezone('America/St_Johns')",
        ">>> normal = datetime(2009, 9, 1)",
        ">>> tz.tzname(normal)",
        ">>> tz.tzname(normal, is_dst=False)",
        ">>> tz.tzname(normal, is_dst=True)",
        ">>> ambiguous = datetime(2009, 10, 31, 23, 30)",
        ">>> tz.tzname(ambiguous, is_dst=False)",
        ">>> tz.tzname(ambiguous, is_dst=True)",
        ">>> try:"
      ],
      "docstring": "See datetime.tzinfo.tzname\n\nThe is_dst parameter may be used to remove ambiguity during DST\ntransitions.\n\n>>> from pytz import timezone\n>>> tz = timezone('America/St_Johns')\n\n>>> normal = datetime(2009, 9, 1)\n\n>>> tz.tzname(normal)\n'NDT'\n>>> tz.tzname(normal, is_dst=False)\n'NDT'\n>>> tz.tzname(normal, is_dst=True)\n'NDT'\n\n>>> ambiguous = datetime(2009, 10, 31, 23, 30)\n\n>>> tz.tzname(ambiguous, is_dst=False)\n'NST'\n>>> tz.tzname(ambiguous, is_dst=True)\n'NDT'\n>>> try:\n...     tz.tzname(ambiguous)\n... except AmbiguousTimeError:\n...     print('Ambiguous')\nAmbiguous",
      "source_code": "    def tzname(self, dt, is_dst=None):\n        '''See datetime.tzinfo.tzname\n\n        The is_dst parameter may be used to remove ambiguity during DST\n        transitions.\n\n        >>> from pytz import timezone\n        >>> tz = timezone('America/St_Johns')\n\n        >>> normal = datetime(2009, 9, 1)\n\n        >>> tz.tzname(normal)\n        'NDT'\n        >>> tz.tzname(normal, is_dst=False)\n        'NDT'\n        >>> tz.tzname(normal, is_dst=True)\n        'NDT'\n\n        >>> ambiguous = datetime(2009, 10, 31, 23, 30)\n\n        >>> tz.tzname(ambiguous, is_dst=False)\n        'NST'\n        >>> tz.tzname(ambiguous, is_dst=True)\n        'NDT'\n        >>> try:\n        ...     tz.tzname(ambiguous)\n        ... except AmbiguousTimeError:\n        ...     print('Ambiguous')\n        Ambiguous\n        '''\n        if dt is None:\n            return self.zone\n        elif dt.tzinfo is not self:\n            dt = self.localize(dt, is_dst)\n            return dt.tzinfo._tzname\n        else:\n            return self._tzname\n"
    },
    {
      "type": "method",
      "qualified_name": "pytz.tzfile.DstTzInfo.utcoffset",
      "module": "pytz.tzfile",
      "signature": "(self, dt, is_dst=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "dt": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "is_dst": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [
        ">>> from pytz import timezone",
        ">>> tz = timezone('America/St_Johns')",
        ">>> ambiguous = datetime(2009, 10, 31, 23, 30)",
        ">>> str(tz.utcoffset(ambiguous, is_dst=False))",
        ">>> str(tz.utcoffset(ambiguous, is_dst=True))",
        ">>> try:"
      ],
      "docstring": "See datetime.tzinfo.utcoffset\n\nThe is_dst parameter may be used to remove ambiguity during DST\ntransitions.\n\n>>> from pytz import timezone\n>>> tz = timezone('America/St_Johns')\n>>> ambiguous = datetime(2009, 10, 31, 23, 30)\n\n>>> str(tz.utcoffset(ambiguous, is_dst=False))\n'-1 day, 20:30:00'\n\n>>> str(tz.utcoffset(ambiguous, is_dst=True))\n'-1 day, 21:30:00'\n\n>>> try:\n...     tz.utcoffset(ambiguous)\n... except AmbiguousTimeError:\n...     print('Ambiguous')\nAmbiguous",
      "source_code": "    def utcoffset(self, dt, is_dst=None):\n        '''See datetime.tzinfo.utcoffset\n\n        The is_dst parameter may be used to remove ambiguity during DST\n        transitions.\n\n        >>> from pytz import timezone\n        >>> tz = timezone('America/St_Johns')\n        >>> ambiguous = datetime(2009, 10, 31, 23, 30)\n\n        >>> str(tz.utcoffset(ambiguous, is_dst=False))\n        '-1 day, 20:30:00'\n\n        >>> str(tz.utcoffset(ambiguous, is_dst=True))\n        '-1 day, 21:30:00'\n\n        >>> try:\n        ...     tz.utcoffset(ambiguous)\n        ... except AmbiguousTimeError:\n        ...     print('Ambiguous')\n        Ambiguous\n\n        '''\n        if dt is None:\n            return None\n        elif dt.tzinfo is not self:\n            dt = self.localize(dt, is_dst)\n            return dt.tzinfo._utcoffset\n        else:\n            return self._utcoffset\n"
    },
    {
      "type": "method",
      "qualified_name": "pytz.tzfile.StaticTzInfo.dst",
      "module": "pytz.tzfile",
      "signature": "(self, dt, is_dst=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "dt": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "is_dst": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "See datetime.tzinfo.dst\n\nis_dst is ignored for StaticTzInfo, and exists only to\nretain compatibility with DstTzInfo.",
      "source_code": "    def dst(self, dt, is_dst=None):\n        '''See datetime.tzinfo.dst\n\n        is_dst is ignored for StaticTzInfo, and exists only to\n        retain compatibility with DstTzInfo.\n        '''\n        return _notime\n"
    },
    {
      "type": "method",
      "qualified_name": "pytz.tzfile.StaticTzInfo.fromutc",
      "module": "pytz.tzfile",
      "signature": "(self, dt)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "dt": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "See datetime.tzinfo.fromutc",
      "source_code": "    def fromutc(self, dt):\n        '''See datetime.tzinfo.fromutc'''\n        if dt.tzinfo is not None and dt.tzinfo is not self:\n            raise ValueError('fromutc: dt.tzinfo is not self')\n        return (dt + self._utcoffset).replace(tzinfo=self)\n"
    },
    {
      "type": "method",
      "qualified_name": "pytz.tzfile.StaticTzInfo.localize",
      "module": "pytz.tzfile",
      "signature": "(self, dt, is_dst=False)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "dt": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "is_dst": {
          "default": "False",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Convert naive time to local time",
      "source_code": "    def localize(self, dt, is_dst=False):\n        '''Convert naive time to local time'''\n        if dt.tzinfo is not None:\n            raise ValueError('Not naive datetime (tzinfo is already set)')\n        return dt.replace(tzinfo=self)\n"
    },
    {
      "type": "method",
      "qualified_name": "pytz.tzfile.StaticTzInfo.normalize",
      "module": "pytz.tzfile",
      "signature": "(self, dt, is_dst=False)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "dt": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "is_dst": {
          "default": "False",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [
        ">>> from pytz import timezone",
        ">>> gmt = timezone('GMT')",
        ">>> isinstance(gmt, StaticTzInfo)",
        ">>> dt = datetime(2011, 5, 8, 1, 2, 3, tzinfo=gmt)",
        ">>> gmt.normalize(dt) is dt",
        ">>> la = timezone('America/Los_Angeles')",
        ">>> dt = la.localize(datetime(2011, 5, 7, 1, 2, 3))",
        ">>> fmt = '%Y-%m-%d %H:%M:%S %Z (%z)'",
        ">>> gmt.normalize(dt).strftime(fmt)"
      ],
      "docstring": "Correct the timezone information on the given datetime.\n\nThis is normally a no-op, as StaticTzInfo timezones never have\nambiguous cases to correct:\n\n>>> from pytz import timezone\n>>> gmt = timezone('GMT')\n>>> isinstance(gmt, StaticTzInfo)\nTrue\n>>> dt = datetime(2011, 5, 8, 1, 2, 3, tzinfo=gmt)\n>>> gmt.normalize(dt) is dt\nTrue\n\nThe supported method of converting between timezones is to use\ndatetime.astimezone(). Currently normalize() also works:\n\n>>> la = timezone('America/Los_Angeles')\n>>> dt = la.localize(datetime(2011, 5, 7, 1, 2, 3))\n>>> fmt = '%Y-%m-%d %H:%M:%S %Z (%z)'\n>>> gmt.normalize(dt).strftime(fmt)\n'2011-05-07 08:02:03 GMT (+0000)'",
      "source_code": "    def normalize(self, dt, is_dst=False):\n        '''Correct the timezone information on the given datetime.\n\n        This is normally a no-op, as StaticTzInfo timezones never have\n        ambiguous cases to correct:\n\n        >>> from pytz import timezone\n        >>> gmt = timezone('GMT')\n        >>> isinstance(gmt, StaticTzInfo)\n        True\n        >>> dt = datetime(2011, 5, 8, 1, 2, 3, tzinfo=gmt)\n        >>> gmt.normalize(dt) is dt\n        True\n\n        The supported method of converting between timezones is to use\n        datetime.astimezone(). Currently normalize() also works:\n\n        >>> la = timezone('America/Los_Angeles')\n        >>> dt = la.localize(datetime(2011, 5, 7, 1, 2, 3))\n        >>> fmt = '%Y-%m-%d %H:%M:%S %Z (%z)'\n        >>> gmt.normalize(dt).strftime(fmt)\n        '2011-05-07 08:02:03 GMT (+0000)'\n        '''\n        if dt.tzinfo is self:\n            return dt\n        if dt.tzinfo is None:\n            raise ValueError('Naive time - no tzinfo set')\n        return dt.astimezone(self)\n"
    },
    {
      "type": "method",
      "qualified_name": "pytz.tzfile.StaticTzInfo.tzname",
      "module": "pytz.tzfile",
      "signature": "(self, dt, is_dst=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "dt": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "is_dst": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "See datetime.tzinfo.tzname\n\nis_dst is ignored for StaticTzInfo, and exists only to\nretain compatibility with DstTzInfo.",
      "source_code": "    def tzname(self, dt, is_dst=None):\n        '''See datetime.tzinfo.tzname\n\n        is_dst is ignored for StaticTzInfo, and exists only to\n        retain compatibility with DstTzInfo.\n        '''\n        return self._tzname\n"
    },
    {
      "type": "method",
      "qualified_name": "pytz.tzfile.StaticTzInfo.utcoffset",
      "module": "pytz.tzfile",
      "signature": "(self, dt, is_dst=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "dt": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "is_dst": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "See datetime.tzinfo.utcoffset\n\nis_dst is ignored for StaticTzInfo, and exists only to\nretain compatibility with DstTzInfo.",
      "source_code": "    def utcoffset(self, dt, is_dst=None):\n        '''See datetime.tzinfo.utcoffset\n\n        is_dst is ignored for StaticTzInfo, and exists only to\n        retain compatibility with DstTzInfo.\n        '''\n        return self._utcoffset\n"
    },
    {
      "type": "method",
      "qualified_name": "pytz.tzinfo.DstTzInfo.dst",
      "module": "pytz.tzinfo",
      "signature": "(self, dt, is_dst=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "dt": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "is_dst": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [
        ">>> from pytz import timezone",
        ">>> tz = timezone('America/St_Johns')",
        ">>> normal = datetime(2009, 9, 1)",
        ">>> str(tz.dst(normal))",
        ">>> str(tz.dst(normal, is_dst=False))",
        ">>> str(tz.dst(normal, is_dst=True))",
        ">>> ambiguous = datetime(2009, 10, 31, 23, 30)",
        ">>> str(tz.dst(ambiguous, is_dst=False))",
        ">>> str(tz.dst(ambiguous, is_dst=True))",
        ">>> try:"
      ],
      "docstring": "See datetime.tzinfo.dst\n\nThe is_dst parameter may be used to remove ambiguity during DST\ntransitions.\n\n>>> from pytz import timezone\n>>> tz = timezone('America/St_Johns')\n\n>>> normal = datetime(2009, 9, 1)\n\n>>> str(tz.dst(normal))\n'1:00:00'\n>>> str(tz.dst(normal, is_dst=False))\n'1:00:00'\n>>> str(tz.dst(normal, is_dst=True))\n'1:00:00'\n\n>>> ambiguous = datetime(2009, 10, 31, 23, 30)\n\n>>> str(tz.dst(ambiguous, is_dst=False))\n'0:00:00'\n>>> str(tz.dst(ambiguous, is_dst=True))\n'1:00:00'\n>>> try:\n...     tz.dst(ambiguous)\n... except AmbiguousTimeError:\n...     print('Ambiguous')\nAmbiguous",
      "source_code": "    def dst(self, dt, is_dst=None):\n        '''See datetime.tzinfo.dst\n\n        The is_dst parameter may be used to remove ambiguity during DST\n        transitions.\n\n        >>> from pytz import timezone\n        >>> tz = timezone('America/St_Johns')\n\n        >>> normal = datetime(2009, 9, 1)\n\n        >>> str(tz.dst(normal))\n        '1:00:00'\n        >>> str(tz.dst(normal, is_dst=False))\n        '1:00:00'\n        >>> str(tz.dst(normal, is_dst=True))\n        '1:00:00'\n\n        >>> ambiguous = datetime(2009, 10, 31, 23, 30)\n\n        >>> str(tz.dst(ambiguous, is_dst=False))\n        '0:00:00'\n        >>> str(tz.dst(ambiguous, is_dst=True))\n        '1:00:00'\n        >>> try:\n        ...     tz.dst(ambiguous)\n        ... except AmbiguousTimeError:\n        ...     print('Ambiguous')\n        Ambiguous\n\n        '''\n        if dt is None:\n            return None\n        elif dt.tzinfo is not self:\n            dt = self.localize(dt, is_dst)\n            return dt.tzinfo._dst\n        else:\n            return self._dst\n"
    },
    {
      "type": "method",
      "qualified_name": "pytz.tzinfo.DstTzInfo.fromutc",
      "module": "pytz.tzinfo",
      "signature": "(self, dt)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "dt": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "See datetime.tzinfo.fromutc",
      "source_code": "    def fromutc(self, dt):\n        '''See datetime.tzinfo.fromutc'''\n        if (dt.tzinfo is not None and\n                getattr(dt.tzinfo, '_tzinfos', None) is not self._tzinfos):\n            raise ValueError('fromutc: dt.tzinfo is not self')\n        dt = dt.replace(tzinfo=None)\n        idx = max(0, bisect_right(self._utc_transition_times, dt) - 1)\n        inf = self._transition_info[idx]\n        return (dt + inf[0]).replace(tzinfo=self._tzinfos[inf])\n"
    },
    {
      "type": "method",
      "qualified_name": "pytz.tzinfo.DstTzInfo.localize",
      "module": "pytz.tzinfo",
      "signature": "(self, dt, is_dst=False)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "dt": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "is_dst": {
          "default": "False",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [
        ">>> from pytz import timezone",
        ">>> fmt = '%Y-%m-%d %H:%M:%S %Z (%z)'",
        ">>> amdam = timezone('Europe/Amsterdam')",
        ">>> dt  = datetime(2004, 10, 31, 2, 0, 0)",
        ">>> loc_dt1 = amdam.localize(dt, is_dst=True)",
        ">>> loc_dt2 = amdam.localize(dt, is_dst=False)",
        ">>> loc_dt1.strftime(fmt)",
        ">>> loc_dt2.strftime(fmt)",
        ">>> str(loc_dt2 - loc_dt1)",
        ">>> try:",
        ">>> amdam.localize(dt) == amdam.localize(dt, False)",
        ">>> pacific = timezone('US/Pacific')",
        ">>> dt = datetime(2008, 3, 9, 2, 0, 0)",
        ">>> ploc_dt1 = pacific.localize(dt, is_dst=True)",
        ">>> ploc_dt2 = pacific.localize(dt, is_dst=False)",
        ">>> ploc_dt1.strftime(fmt)",
        ">>> ploc_dt2.strftime(fmt)",
        ">>> str(ploc_dt2 - ploc_dt1)",
        ">>> try:"
      ],
      "docstring": "Convert naive time to local time.\n\nThis method should be used to construct localtimes, rather\nthan passing a tzinfo argument to a datetime constructor.\n\nis_dst is used to determine the correct timezone in the ambigous\nperiod at the end of daylight saving time.\n\n>>> from pytz import timezone\n>>> fmt = '%Y-%m-%d %H:%M:%S %Z (%z)'\n>>> amdam = timezone('Europe/Amsterdam')\n>>> dt  = datetime(2004, 10, 31, 2, 0, 0)\n>>> loc_dt1 = amdam.localize(dt, is_dst=True)\n>>> loc_dt2 = amdam.localize(dt, is_dst=False)\n>>> loc_dt1.strftime(fmt)\n'2004-10-31 02:00:00 CEST (+0200)'\n>>> loc_dt2.strftime(fmt)\n'2004-10-31 02:00:00 CET (+0100)'\n>>> str(loc_dt2 - loc_dt1)\n'1:00:00'\n\nUse is_dst=None to raise an AmbiguousTimeError for ambiguous\ntimes at the end of daylight saving time\n\n>>> try:\n...     loc_dt1 = amdam.localize(dt, is_dst=None)\n... except AmbiguousTimeError:\n...     print('Ambiguous')\nAmbiguous\n\nis_dst defaults to False\n\n>>> amdam.localize(dt) == amdam.localize(dt, False)\nTrue\n\nis_dst is also used to determine the correct timezone in the\nwallclock times jumped over at the start of daylight saving time.\n\n>>> pacific = timezone('US/Pacific')\n>>> dt = datetime(2008, 3, 9, 2, 0, 0)\n>>> ploc_dt1 = pacific.localize(dt, is_dst=True)\n>>> ploc_dt2 = pacific.localize(dt, is_dst=False)\n>>> ploc_dt1.strftime(fmt)\n'2008-03-09 02:00:00 PDT (-0700)'\n>>> ploc_dt2.strftime(fmt)\n'2008-03-09 02:00:00 PST (-0800)'\n>>> str(ploc_dt2 - ploc_dt1)\n'1:00:00'\n\nUse is_dst=None to raise a NonExistentTimeError for these skipped\ntimes.\n\n>>> try:\n...     loc_dt1 = pacific.localize(dt, is_dst=None)\n... except NonExistentTimeError:\n...     print('Non-existent')\nNon-existent",
      "source_code": "    def localize(self, dt, is_dst=False):\n        '''Convert naive time to local time.\n\n        This method should be used to construct localtimes, rather\n        than passing a tzinfo argument to a datetime constructor.\n\n        is_dst is used to determine the correct timezone in the ambigous\n        period at the end of daylight saving time.\n\n        >>> from pytz import timezone\n        >>> fmt = '%Y-%m-%d %H:%M:%S %Z (%z)'\n        >>> amdam = timezone('Europe/Amsterdam')\n        >>> dt  = datetime(2004, 10, 31, 2, 0, 0)\n        >>> loc_dt1 = amdam.localize(dt, is_dst=True)\n        >>> loc_dt2 = amdam.localize(dt, is_dst=False)\n        >>> loc_dt1.strftime(fmt)\n        '2004-10-31 02:00:00 CEST (+0200)'\n        >>> loc_dt2.strftime(fmt)\n        '2004-10-31 02:00:00 CET (+0100)'\n        >>> str(loc_dt2 - loc_dt1)\n        '1:00:00'\n\n        Use is_dst=None to raise an AmbiguousTimeError for ambiguous\n        times at the end of daylight saving time\n\n        >>> try:\n        ...     loc_dt1 = amdam.localize(dt, is_dst=None)\n        ... except AmbiguousTimeError:\n        ...     print('Ambiguous')\n        Ambiguous\n\n        is_dst defaults to False\n\n        >>> amdam.localize(dt) == amdam.localize(dt, False)\n        True\n\n        is_dst is also used to determine the correct timezone in the\n        wallclock times jumped over at the start of daylight saving time.\n\n        >>> pacific = timezone('US/Pacific')\n        >>> dt = datetime(2008, 3, 9, 2, 0, 0)\n        >>> ploc_dt1 = pacific.localize(dt, is_dst=True)\n        >>> ploc_dt2 = pacific.localize(dt, is_dst=False)\n        >>> ploc_dt1.strftime(fmt)\n        '2008-03-09 02:00:00 PDT (-0700)'\n        >>> ploc_dt2.strftime(fmt)\n        '2008-03-09 02:00:00 PST (-0800)'\n        >>> str(ploc_dt2 - ploc_dt1)\n        '1:00:00'\n\n        Use is_dst=None to raise a NonExistentTimeError for these skipped\n        times.\n\n        >>> try:\n        ...     loc_dt1 = pacific.localize(dt, is_dst=None)\n        ... except NonExistentTimeError:\n        ...     print('Non-existent')\n        Non-existent\n        '''\n        if dt.tzinfo is not None:\n            raise ValueError('Not naive datetime (tzinfo is already set)')\n\n        # Find the two best possibilities.\n        possible_loc_dt = set()\n        for delta in [timedelta(days=-1), timedelta(days=1)]:\n            loc_dt = dt + delta\n            idx = max(0, bisect_right(\n                self._utc_transition_times, loc_dt) - 1)\n            inf = self._transition_info[idx]\n            tzinfo = self._tzinfos[inf]\n            loc_dt = tzinfo.normalize(dt.replace(tzinfo=tzinfo))\n            if loc_dt.replace(tzinfo=None) == dt:\n                possible_loc_dt.add(loc_dt)\n\n        if len(possible_loc_dt) == 1:\n            return possible_loc_dt.pop()\n\n        # If there are no possibly correct timezones, we are attempting\n        # to convert a time that never happened - the time period jumped\n        # during the start-of-DST transition period.\n        if len(possible_loc_dt) == 0:\n            # If we refuse to guess, raise an exception.\n            if is_dst is None:\n                raise NonExistentTimeError(dt)\n\n            # If we are forcing the pre-DST side of the DST transition, we\n            # obtain the correct timezone by winding the clock forward a few\n            # hours.\n            elif is_dst:\n                return self.localize(\n                    dt + timedelta(hours=6), is_dst=True) - timedelta(hours=6)\n\n            # If we are forcing the post-DST side of the DST transition, we\n            # obtain the correct timezone by winding the clock back.\n            else:\n                return self.localize(\n                    dt - timedelta(hours=6),\n                    is_dst=False) + timedelta(hours=6)\n\n        # If we get this far, we have multiple possible timezones - this\n        # is an ambiguous case occurring during the end-of-DST transition.\n\n        # If told to be strict, raise an exception since we have an\n        # ambiguous case\n        if is_dst is None:\n            raise AmbiguousTimeError(dt)\n\n        # Filter out the possiblilities that don't match the requested\n        # is_dst\n        filtered_possible_loc_dt = [\n            p for p in possible_loc_dt if bool(p.tzinfo._dst) == is_dst\n        ]\n\n        # Hopefully we only have one possibility left. Return it.\n        if len(filtered_possible_loc_dt) == 1:\n            return filtered_possible_loc_dt[0]\n\n        if len(filtered_possible_loc_dt) == 0:\n            filtered_possible_loc_dt = list(possible_loc_dt)\n\n        # If we get this far, we have in a wierd timezone transition\n        # where the clocks have been wound back but is_dst is the same\n        # in both (eg. Europe/Warsaw 1915 when they switched to CET).\n        # At this point, we just have to guess unless we allow more\n        # hints to be passed in (such as the UTC offset or abbreviation),\n        # but that is just getting silly.\n        #\n        # Choose the earliest (by UTC) applicable timezone if is_dst=True\n        # Choose the latest (by UTC) applicable timezone if is_dst=False\n        # i.e., behave like end-of-DST transition\n        dates = {}  # utc -> local\n        for local_dt in filtered_possible_loc_dt:\n            utc_time = (\n                local_dt.replace(tzinfo=None) - local_dt.tzinfo._utcoffset)\n            assert utc_time not in dates\n            dates[utc_time] = local_dt\n        return dates[[min, max][not is_dst](dates)]\n"
    },
    {
      "type": "method",
      "qualified_name": "pytz.tzinfo.DstTzInfo.normalize",
      "module": "pytz.tzinfo",
      "signature": "(self, dt)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "dt": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [
        ">>> from pytz import timezone",
        ">>> utc = timezone('UTC')",
        ">>> eastern = timezone('US/Eastern')",
        ">>> fmt = '%Y-%m-%d %H:%M:%S %Z (%z)'",
        ">>> utc_dt = datetime(2002, 10, 27, 6, 0, 0, tzinfo=utc)",
        ">>> loc_dt = utc_dt.astimezone(eastern)",
        ">>> loc_dt.strftime(fmt)",
        ">>> before = loc_dt - timedelta(minutes=10)",
        ">>> before.strftime(fmt)",
        ">>> before = eastern.normalize(before)",
        ">>> before.strftime(fmt)",
        ">>> th = timezone('Asia/Bangkok')",
        ">>> am = timezone('Europe/Amsterdam')",
        ">>> dt = th.localize(datetime(2011, 5, 7, 1, 2, 3))",
        ">>> fmt = '%Y-%m-%d %H:%M:%S %Z (%z)'",
        ">>> am.normalize(dt).strftime(fmt)"
      ],
      "docstring": "Correct the timezone information on the given datetime\n\nIf date arithmetic crosses DST boundaries, the tzinfo\nis not magically adjusted. This method normalizes the\ntzinfo to the correct one.\n\nTo test, first we need to do some setup\n\n>>> from pytz import timezone\n>>> utc = timezone('UTC')\n>>> eastern = timezone('US/Eastern')\n>>> fmt = '%Y-%m-%d %H:%M:%S %Z (%z)'\n\nWe next create a datetime right on an end-of-DST transition point,\nthe instant when the wallclocks are wound back one hour.\n\n>>> utc_dt = datetime(2002, 10, 27, 6, 0, 0, tzinfo=utc)\n>>> loc_dt = utc_dt.astimezone(eastern)\n>>> loc_dt.strftime(fmt)\n'2002-10-27 01:00:00 EST (-0500)'\n\nNow, if we subtract a few minutes from it, note that the timezone\ninformation has not changed.\n\n>>> before = loc_dt - timedelta(minutes=10)\n>>> before.strftime(fmt)\n'2002-10-27 00:50:00 EST (-0500)'\n\nBut we can fix that by calling the normalize method\n\n>>> before = eastern.normalize(before)\n>>> before.strftime(fmt)\n'2002-10-27 01:50:00 EDT (-0400)'\n\nThe supported method of converting between timezones is to use\ndatetime.astimezone(). Currently, normalize() also works:\n\n>>> th = timezone('Asia/Bangkok')\n>>> am = timezone('Europe/Amsterdam')\n>>> dt = th.localize(datetime(2011, 5, 7, 1, 2, 3))\n>>> fmt = '%Y-%m-%d %H:%M:%S %Z (%z)'\n>>> am.normalize(dt).strftime(fmt)\n'2011-05-06 20:02:03 CEST (+0200)'",
      "source_code": "    def normalize(self, dt):\n        '''Correct the timezone information on the given datetime\n\n        If date arithmetic crosses DST boundaries, the tzinfo\n        is not magically adjusted. This method normalizes the\n        tzinfo to the correct one.\n\n        To test, first we need to do some setup\n\n        >>> from pytz import timezone\n        >>> utc = timezone('UTC')\n        >>> eastern = timezone('US/Eastern')\n        >>> fmt = '%Y-%m-%d %H:%M:%S %Z (%z)'\n\n        We next create a datetime right on an end-of-DST transition point,\n        the instant when the wallclocks are wound back one hour.\n\n        >>> utc_dt = datetime(2002, 10, 27, 6, 0, 0, tzinfo=utc)\n        >>> loc_dt = utc_dt.astimezone(eastern)\n        >>> loc_dt.strftime(fmt)\n        '2002-10-27 01:00:00 EST (-0500)'\n\n        Now, if we subtract a few minutes from it, note that the timezone\n        information has not changed.\n\n        >>> before = loc_dt - timedelta(minutes=10)\n        >>> before.strftime(fmt)\n        '2002-10-27 00:50:00 EST (-0500)'\n\n        But we can fix that by calling the normalize method\n\n        >>> before = eastern.normalize(before)\n        >>> before.strftime(fmt)\n        '2002-10-27 01:50:00 EDT (-0400)'\n\n        The supported method of converting between timezones is to use\n        datetime.astimezone(). Currently, normalize() also works:\n\n        >>> th = timezone('Asia/Bangkok')\n        >>> am = timezone('Europe/Amsterdam')\n        >>> dt = th.localize(datetime(2011, 5, 7, 1, 2, 3))\n        >>> fmt = '%Y-%m-%d %H:%M:%S %Z (%z)'\n        >>> am.normalize(dt).strftime(fmt)\n        '2011-05-06 20:02:03 CEST (+0200)'\n        '''\n        if dt.tzinfo is None:\n            raise ValueError('Naive time - no tzinfo set')\n\n        # Convert dt in localtime to UTC\n        offset = dt.tzinfo._utcoffset\n        dt = dt.replace(tzinfo=None)\n        dt = dt - offset\n        # convert it back, and return it\n        return self.fromutc(dt)\n"
    },
    {
      "type": "method",
      "qualified_name": "pytz.tzinfo.DstTzInfo.tzname",
      "module": "pytz.tzinfo",
      "signature": "(self, dt, is_dst=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "dt": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "is_dst": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [
        ">>> from pytz import timezone",
        ">>> tz = timezone('America/St_Johns')",
        ">>> normal = datetime(2009, 9, 1)",
        ">>> tz.tzname(normal)",
        ">>> tz.tzname(normal, is_dst=False)",
        ">>> tz.tzname(normal, is_dst=True)",
        ">>> ambiguous = datetime(2009, 10, 31, 23, 30)",
        ">>> tz.tzname(ambiguous, is_dst=False)",
        ">>> tz.tzname(ambiguous, is_dst=True)",
        ">>> try:"
      ],
      "docstring": "See datetime.tzinfo.tzname\n\nThe is_dst parameter may be used to remove ambiguity during DST\ntransitions.\n\n>>> from pytz import timezone\n>>> tz = timezone('America/St_Johns')\n\n>>> normal = datetime(2009, 9, 1)\n\n>>> tz.tzname(normal)\n'NDT'\n>>> tz.tzname(normal, is_dst=False)\n'NDT'\n>>> tz.tzname(normal, is_dst=True)\n'NDT'\n\n>>> ambiguous = datetime(2009, 10, 31, 23, 30)\n\n>>> tz.tzname(ambiguous, is_dst=False)\n'NST'\n>>> tz.tzname(ambiguous, is_dst=True)\n'NDT'\n>>> try:\n...     tz.tzname(ambiguous)\n... except AmbiguousTimeError:\n...     print('Ambiguous')\nAmbiguous",
      "source_code": "    def tzname(self, dt, is_dst=None):\n        '''See datetime.tzinfo.tzname\n\n        The is_dst parameter may be used to remove ambiguity during DST\n        transitions.\n\n        >>> from pytz import timezone\n        >>> tz = timezone('America/St_Johns')\n\n        >>> normal = datetime(2009, 9, 1)\n\n        >>> tz.tzname(normal)\n        'NDT'\n        >>> tz.tzname(normal, is_dst=False)\n        'NDT'\n        >>> tz.tzname(normal, is_dst=True)\n        'NDT'\n\n        >>> ambiguous = datetime(2009, 10, 31, 23, 30)\n\n        >>> tz.tzname(ambiguous, is_dst=False)\n        'NST'\n        >>> tz.tzname(ambiguous, is_dst=True)\n        'NDT'\n        >>> try:\n        ...     tz.tzname(ambiguous)\n        ... except AmbiguousTimeError:\n        ...     print('Ambiguous')\n        Ambiguous\n        '''\n        if dt is None:\n            return self.zone\n        elif dt.tzinfo is not self:\n            dt = self.localize(dt, is_dst)\n            return dt.tzinfo._tzname\n        else:\n            return self._tzname\n"
    },
    {
      "type": "method",
      "qualified_name": "pytz.tzinfo.DstTzInfo.utcoffset",
      "module": "pytz.tzinfo",
      "signature": "(self, dt, is_dst=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "dt": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "is_dst": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [
        ">>> from pytz import timezone",
        ">>> tz = timezone('America/St_Johns')",
        ">>> ambiguous = datetime(2009, 10, 31, 23, 30)",
        ">>> str(tz.utcoffset(ambiguous, is_dst=False))",
        ">>> str(tz.utcoffset(ambiguous, is_dst=True))",
        ">>> try:"
      ],
      "docstring": "See datetime.tzinfo.utcoffset\n\nThe is_dst parameter may be used to remove ambiguity during DST\ntransitions.\n\n>>> from pytz import timezone\n>>> tz = timezone('America/St_Johns')\n>>> ambiguous = datetime(2009, 10, 31, 23, 30)\n\n>>> str(tz.utcoffset(ambiguous, is_dst=False))\n'-1 day, 20:30:00'\n\n>>> str(tz.utcoffset(ambiguous, is_dst=True))\n'-1 day, 21:30:00'\n\n>>> try:\n...     tz.utcoffset(ambiguous)\n... except AmbiguousTimeError:\n...     print('Ambiguous')\nAmbiguous",
      "source_code": "    def utcoffset(self, dt, is_dst=None):\n        '''See datetime.tzinfo.utcoffset\n\n        The is_dst parameter may be used to remove ambiguity during DST\n        transitions.\n\n        >>> from pytz import timezone\n        >>> tz = timezone('America/St_Johns')\n        >>> ambiguous = datetime(2009, 10, 31, 23, 30)\n\n        >>> str(tz.utcoffset(ambiguous, is_dst=False))\n        '-1 day, 20:30:00'\n\n        >>> str(tz.utcoffset(ambiguous, is_dst=True))\n        '-1 day, 21:30:00'\n\n        >>> try:\n        ...     tz.utcoffset(ambiguous)\n        ... except AmbiguousTimeError:\n        ...     print('Ambiguous')\n        Ambiguous\n\n        '''\n        if dt is None:\n            return None\n        elif dt.tzinfo is not self:\n            dt = self.localize(dt, is_dst)\n            return dt.tzinfo._utcoffset\n        else:\n            return self._utcoffset\n"
    },
    {
      "type": "method",
      "qualified_name": "pytz.tzinfo.StaticTzInfo.dst",
      "module": "pytz.tzinfo",
      "signature": "(self, dt, is_dst=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "dt": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "is_dst": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "See datetime.tzinfo.dst\n\nis_dst is ignored for StaticTzInfo, and exists only to\nretain compatibility with DstTzInfo.",
      "source_code": "    def dst(self, dt, is_dst=None):\n        '''See datetime.tzinfo.dst\n\n        is_dst is ignored for StaticTzInfo, and exists only to\n        retain compatibility with DstTzInfo.\n        '''\n        return _notime\n"
    },
    {
      "type": "method",
      "qualified_name": "pytz.tzinfo.StaticTzInfo.fromutc",
      "module": "pytz.tzinfo",
      "signature": "(self, dt)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "dt": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "See datetime.tzinfo.fromutc",
      "source_code": "    def fromutc(self, dt):\n        '''See datetime.tzinfo.fromutc'''\n        if dt.tzinfo is not None and dt.tzinfo is not self:\n            raise ValueError('fromutc: dt.tzinfo is not self')\n        return (dt + self._utcoffset).replace(tzinfo=self)\n"
    },
    {
      "type": "method",
      "qualified_name": "pytz.tzinfo.StaticTzInfo.localize",
      "module": "pytz.tzinfo",
      "signature": "(self, dt, is_dst=False)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "dt": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "is_dst": {
          "default": "False",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "Convert naive time to local time",
      "source_code": "    def localize(self, dt, is_dst=False):\n        '''Convert naive time to local time'''\n        if dt.tzinfo is not None:\n            raise ValueError('Not naive datetime (tzinfo is already set)')\n        return dt.replace(tzinfo=self)\n"
    },
    {
      "type": "method",
      "qualified_name": "pytz.tzinfo.StaticTzInfo.normalize",
      "module": "pytz.tzinfo",
      "signature": "(self, dt, is_dst=False)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "dt": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "is_dst": {
          "default": "False",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [
        ">>> from pytz import timezone",
        ">>> gmt = timezone('GMT')",
        ">>> isinstance(gmt, StaticTzInfo)",
        ">>> dt = datetime(2011, 5, 8, 1, 2, 3, tzinfo=gmt)",
        ">>> gmt.normalize(dt) is dt",
        ">>> la = timezone('America/Los_Angeles')",
        ">>> dt = la.localize(datetime(2011, 5, 7, 1, 2, 3))",
        ">>> fmt = '%Y-%m-%d %H:%M:%S %Z (%z)'",
        ">>> gmt.normalize(dt).strftime(fmt)"
      ],
      "docstring": "Correct the timezone information on the given datetime.\n\nThis is normally a no-op, as StaticTzInfo timezones never have\nambiguous cases to correct:\n\n>>> from pytz import timezone\n>>> gmt = timezone('GMT')\n>>> isinstance(gmt, StaticTzInfo)\nTrue\n>>> dt = datetime(2011, 5, 8, 1, 2, 3, tzinfo=gmt)\n>>> gmt.normalize(dt) is dt\nTrue\n\nThe supported method of converting between timezones is to use\ndatetime.astimezone(). Currently normalize() also works:\n\n>>> la = timezone('America/Los_Angeles')\n>>> dt = la.localize(datetime(2011, 5, 7, 1, 2, 3))\n>>> fmt = '%Y-%m-%d %H:%M:%S %Z (%z)'\n>>> gmt.normalize(dt).strftime(fmt)\n'2011-05-07 08:02:03 GMT (+0000)'",
      "source_code": "    def normalize(self, dt, is_dst=False):\n        '''Correct the timezone information on the given datetime.\n\n        This is normally a no-op, as StaticTzInfo timezones never have\n        ambiguous cases to correct:\n\n        >>> from pytz import timezone\n        >>> gmt = timezone('GMT')\n        >>> isinstance(gmt, StaticTzInfo)\n        True\n        >>> dt = datetime(2011, 5, 8, 1, 2, 3, tzinfo=gmt)\n        >>> gmt.normalize(dt) is dt\n        True\n\n        The supported method of converting between timezones is to use\n        datetime.astimezone(). Currently normalize() also works:\n\n        >>> la = timezone('America/Los_Angeles')\n        >>> dt = la.localize(datetime(2011, 5, 7, 1, 2, 3))\n        >>> fmt = '%Y-%m-%d %H:%M:%S %Z (%z)'\n        >>> gmt.normalize(dt).strftime(fmt)\n        '2011-05-07 08:02:03 GMT (+0000)'\n        '''\n        if dt.tzinfo is self:\n            return dt\n        if dt.tzinfo is None:\n            raise ValueError('Naive time - no tzinfo set')\n        return dt.astimezone(self)\n"
    },
    {
      "type": "method",
      "qualified_name": "pytz.tzinfo.StaticTzInfo.tzname",
      "module": "pytz.tzinfo",
      "signature": "(self, dt, is_dst=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "dt": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "is_dst": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "See datetime.tzinfo.tzname\n\nis_dst is ignored for StaticTzInfo, and exists only to\nretain compatibility with DstTzInfo.",
      "source_code": "    def tzname(self, dt, is_dst=None):\n        '''See datetime.tzinfo.tzname\n\n        is_dst is ignored for StaticTzInfo, and exists only to\n        retain compatibility with DstTzInfo.\n        '''\n        return self._tzname\n"
    },
    {
      "type": "method",
      "qualified_name": "pytz.tzinfo.StaticTzInfo.utcoffset",
      "module": "pytz.tzinfo",
      "signature": "(self, dt, is_dst=None)",
      "parameters": {
        "self": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "dt": {
          "default": null,
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        },
        "is_dst": {
          "default": "None",
          "annotation": null,
          "kind": "POSITIONAL_OR_KEYWORD",
          "description": null
        }
      },
      "returns": null,
      "return_description": null,
      "raises": [],
      "decorators": [],
      "examples": [],
      "docstring": "See datetime.tzinfo.utcoffset\n\nis_dst is ignored for StaticTzInfo, and exists only to\nretain compatibility with DstTzInfo.",
      "source_code": "    def utcoffset(self, dt, is_dst=None):\n        '''See datetime.tzinfo.utcoffset\n\n        is_dst is ignored for StaticTzInfo, and exists only to\n        retain compatibility with DstTzInfo.\n        '''\n        return self._utcoffset\n"
    }
  ]
}